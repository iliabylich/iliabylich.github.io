<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon-precomposed sizes=192x192 href=/icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Evaluating Ruby in Ruby"><title>Evaluating Ruby in Ruby | Ilya Bylich - Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.c8a2df3058ea59fb74948f071267ef16e3a4d0b23b7ec84883692939ef5dea45.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/>Home</a></li><li><a tabindex=-1 class=menu-link href=https://github.com/iliabylich>GitHub</a></li><li><a tabindex=-1 class=menu-link href=https://twitter.com/IlyaBylich>Twitter</a></li><li><a tabindex=-1 class=menu-link href=mailto:ibylich@gmail.com>Email me</a></li><li><a tabindex=-1 class=menu-link href=/index.xml>RSS</a></li></ul></nav><div id=single-header><h1>Evaluating Ruby in Ruby</h1><div id=single-meta><span class=datesub>Jan 26, 2020</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://iliabylich.github.io/tags/ruby/>#ruby</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/vm/>#vm</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#how-ruby-evaluates-your-code>How Ruby evaluates your code.</a></li><li><a href=#the-structure-of-the-instruction-sequence-iseq>The structure of the instruction sequence (ISeq)</a></li><li><a href=#building-a-poc>Building a PoC</a></li><li><a href=#self>Self</a></li><li><a href=#frames>Frames</a></li><li><a href=#wrapping-the-iseq>Wrapping the ISeq</a></li><li><a href=#frame-stack>Frame stack</a></li><li><a href=#writing-the-evaluator>Writing the evaluator</a></li><li><a href=#instructions>Instructions</a><ul><li><a href=#putself-putobject-putnil-putstring-putiseq><code>putself</code>, <code>putobject</code>, <code>putnil</code>, <code>putstring</code>, <code>putiseq</code></a></li><li><a href=#optimized-instructions-like-opt_plus>optimized instructions like <code>opt_plus</code></a></li><li><a href=#opt_send_without_block-or-send-if-specialized-instructions-are-disabled><code>opt_send_without_block</code> (or <code>send</code> if specialized instructions are disabled)</a></li><li><a href=#method-definition>method definition</a></li><li><a href=#local-variables>local variables</a></li><li><a href=#method-arguments>method arguments</a></li><li><a href=#constants>constants</a></li><li><a href=#instanceclass-variables>Instance/Class variables</a></li><li><a href=#literals>Literals</a></li><li><a href=#splats>Splats</a></li><li><a href=#conditions-ifunless>conditions (if/unless)</a></li><li><a href=#string-interpolationconcatenation>String interpolation/concatenation</a></li><li><a href=#blocks>Blocks</a></li><li><a href=#lambdas>Lambdas</a></li><li><a href=#calling-a-block>Calling a block</a></li><li><a href=#super>Super</a></li><li><a href=#global-variables>Global variables</a></li><li><a href=#defined-keyword><code>defined?</code> keyword</a></li><li><a href=#range-literals>Range literals</a></li><li><a href=#long-jumps>Long jumps</a></li><li><a href=#longjmp-in-mri><code>longjmp</code> in MRI</a></li><li><a href=#rescueensure><code>rescue</code>/<code>ensure</code></a></li><li><a href=#throwcatch-methods><code>throw</code>/<code>catch</code> methods</a></li><li><a href=#utility-instructions>Utility instructions</a></li></ul></li><li><a href=#final-words>Final words</a></li></ul></nav></aside><main><h2 id=tldr>TL;DR</h2><p>This article is about instruction sequences and evaluating them using pure Ruby.</p><p>The repository is available <a href=https://github.com/iliabylich/my.rb target=_blank rel="noreferrer nofollow">here</a>
.</p><blockquote><p>Is it a Ruby implementation?</p></blockquote><p>No. It&rsquo;s just a runner of instructions. It is similar to MRI&rsquo;s virtual machine, but it lacks many features and it&rsquo;s 100 times slower.</p><blockquote><p>Can I use it in my applications?</p></blockquote><p>Of course, no. Well, if you want.</p><blockquote><p>Does it work at all?</p></blockquote><p>Yes, and it even passes most language specs from RubySpec test suite.</p><h2 id=how-ruby-evaluates-your-code>How Ruby evaluates your code.</h2><p>Well, I think I should start with explaining basics. There is a plenty of articles about it, so I&rsquo;ll be short:</p><ol><li>First, Ruby parses your code into AST (<code>parse.y</code>)</li><li>Then, it compiles it into instruction sequence (<code>compile.c</code>)</li><li>And every time when you let&rsquo;s say call a method it evaluates these instructions. (<code>insn.def</code>, <code>vm_eval.c</code>, <code>vm_insnhelper.c</code>)</li></ol><p>Long time ago there was no YARV and Ruby used to evaluate AST.</p><p><code>1+2</code> is just a small syntax tree with a <code>send</code> node in the root and two children: <code>int(1)</code> and <code>int(2)</code>. To evaluate it you need to &ldquo;traverse&rdquo; it by walking down recursively. Primitive nodes are getting substituted with values (integers 1 and 2 respectively), <code>send</code> node calls <code>+</code> on pre-reduced children and returns <code>3</code>.</p><p>On the other side, YARV is a stack-based Virtual Machine (VM) that evaluates an assembly-like language that consist of more than 100 predefined instructions that store their input/output values on the VM&rsquo;s stack.</p><p>These instructions have arguments, some of them are primitive values, some are inlined Ruby objects, some are flags.</p><p>You can view these instructions by running Ruby with <code>--dump=insns</code> flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> ruby <span style=color:#f92672>--</span>dump<span style=color:#f92672>=</span>insns <span style=color:#f92672>-</span>e <span style=color:#e6db74>&#39;puts 2 + 3&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span> <span style=color:#e6db74>disasm</span>: <span style=color:#75715e>#&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000</span> putself                                                          (   <span style=color:#ae81ff>1</span>)<span style=color:#f92672>[</span><span style=color:#66d9ef>Li</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0001</span> putobject                    <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0003</span> putobject                    <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0005</span> opt_plus                     <span style=color:#f92672>&lt;</span>callinfo!<span style=color:#e6db74>mid</span>:<span style=color:#f92672>+</span>, <span style=color:#e6db74>argc</span>:<span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>ARGS_SIMPLE</span><span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&lt;</span>callcache<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>000</span><span style=color:#ae81ff>8</span> opt_send_without_block       <span style=color:#f92672>&lt;</span>callinfo!<span style=color:#e6db74>mid</span>:puts, <span style=color:#e6db74>argc</span>:<span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>FCALL</span><span style=color:#f92672>|</span><span style=color:#66d9ef>ARGS_SIMPLE</span><span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&lt;</span>callcache<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0011</span> leave
</span></span></code></pre></div><p>As you can see, there are 5 instructions:</p><ol><li><code>putself</code> - pushes <code>self</code> at the top of the stack</li><li><code>putobject</code> - pushes given object (numbers 2 an 3)</li><li><code>opt_plus</code> - optimized instruction for <code>+</code> method</li><li><code>opt_send_without_block</code> - optimized instruction for a generic method call without block</li><li><code>leave</code> - an equivalent of <code>return</code></li></ol><h2 id=the-structure-of-the-instruction-sequence-iseq>The structure of the instruction sequence (ISeq)</h2><p>Let&rsquo;s start with the example above.</p><p>MRI has an API to compile an arbitrary code into instructions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#34;2+3&#34;</span>)<span style=color:#f92672>.</span>to_a
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#e6db74>&#34;YARVInstructionSequence/SimpleDataFormat&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span> {<span style=color:#e6db74>:arg_size</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:local_size</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:stack_max</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:node_id</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:code_location</span><span style=color:#f92672>=&gt;[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>},
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>:top</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[]</span>,
</span></span><span style=display:flex><span> {},
</span></span><span style=display:flex><span> <span style=color:#f92672>[]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:RUBY_EVENT_LINE</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:opt_plus</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:+</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>16</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]]</span>
</span></span></code></pre></div><p>Our code gets compiled into an array where:</p><ul><li>The first element returns the type of the instruction sequence</li><li>Then comes <code>MAJOR</code>/<code>MINOR</code>/<code>PATCH</code> parts of the Ruby version that was used to compile it</li><li>Then comes the hash with a meta information about this iseq</li><li>Then comes relative/full/some other file name. It is possible to override them similar to passing <code>file/line</code> arguments to <code>{class,module}_eval</code> (<code>Object.module_eval("[__FILE__, __LINE__]", '(file)', 42)</code>)</li><li>Then comes the line where the code begins (1 by default)</li><li>Then comes the type of the iseq (<code>:top</code> here means the code was parsed and compiled as a top-level block of code)</li><li>Then we have a few empty arrays and hashes (we will return to them later)</li><li>And the last item is an array of instructions</li></ul><p>Each instruction is either:</p><ul><li>a number</li><li>a special symbol</li><li>or an array</li></ul><p>Only arrays are &ldquo;real&rdquo; instructions, numbers and symbols are special debug entries that are used internally by the VM. In our case a number followed by the <code>:RUBY_EVENT_LINE</code> is a mark that MRI uses to know what is the number of the line that is currently being interpreted (for example, all backtrace entries include these numbers)</p><h2 id=building-a-poc>Building a PoC</h2><p>How can we evaluate instructions above? Well, we definitely need a stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>$stack <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span></code></pre></div><p>Then, we need to iterate over instructions (the last item of the iseq) and evaluate them one by one. We could write a giant <code>case-when</code>, but I promise that it won&rsquo;t fit on 10 screens. Let&rsquo;s use some meta-programming and dynamic dispatching:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_insn</span>(insn)
</span></span><span style=display:flex><span>  name, <span style=color:#f92672>*</span>payload <span style=color:#f92672>=</span> insn
</span></span><span style=display:flex><span>  send(<span style=color:#e6db74>:&#34;execute_</span><span style=color:#e6db74>#{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, payload)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This way we need to write a method per instruction type, let&rsquo;s start with <code>putobject</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_putobject</span>(object)
</span></span><span style=display:flex><span>  $stack<span style=color:#f92672>.</span>push(object)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_opt_plus</span>(options, flag)
</span></span><span style=display:flex><span>  rhs <span style=color:#f92672>=</span> $stack<span style=color:#f92672>.</span>pop
</span></span><span style=display:flex><span>  lhs <span style=color:#f92672>=</span> $stack<span style=color:#f92672>.</span>pop
</span></span><span style=display:flex><span>  $stack<span style=color:#f92672>.</span>push(lhs <span style=color:#f92672>+</span> rhs)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_leave</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># nothing here so far</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This code is enough to get <code>5</code> in the stack once it&rsquo;s executed. Here&rsquo;s the runner:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>iseq <span style=color:#f92672>=</span> <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#34;2+3&#34;</span>)<span style=color:#f92672>.</span>to_a
</span></span><span style=display:flex><span>insns <span style=color:#f92672>=</span> iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>].</span>grep(Array) <span style=color:#75715e># ignore numbers and symbols for now</span>
</span></span><span style=display:flex><span>insns<span style=color:#f92672>.</span>each { <span style=color:#f92672>|</span>insn<span style=color:#f92672>|</span> execute_insn(insn) }
</span></span><span style=display:flex><span>pp $stack
</span></span></code></pre></div><p>You should see <code>[5]</code>.</p><p>All instructions above simply pull some values from the stack, do some computations and push the result back.</p><h2 id=self>Self</h2><p>Let&rsquo;s think about <code>self</code> for a minute:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#34;self&#34;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>:RUBY_EVENT_LINE</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p><code>self</code> is stored somewhere internally, and even more, it&rsquo;s dynamic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>puts self
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>X</span>
</span></span><span style=display:flex><span>  puts self
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The first <code>puts self</code> prints <code>main</code>, while the second one prints <code>X</code>.</p><p>Here comes the concept of frames.</p><h2 id=frames>Frames</h2><p>Frame is an object inside the virtual machine that represents a closure. Or a <code>binding</code>. It&rsquo;s an isolated &ldquo;world&rdquo; with its own set of locals, its own <code>self</code>, its own <code>file</code>/<code>line</code> information, it&rsquo;s own <code>rescue</code> and <code>ensure</code> handlers etc.</p><p>Frame also has a type:</p><ol><li>it can be a <code>top</code> frame that wraps all the code in your file. All variables set in the global scope of your file belong to the top frame. Each parsed and evaluated file creates its own top frame.</li><li>it can be a <code>method</code> frame. All methods create it. One method frame per one method call.</li><li>it can be a <code>block</code> frame. All blocks and lambdas create it. One block frame per one block call.</li><li>it can be a <code>class</code> frame, however it does not mean that instantiating a class creates it. The whole <code>class X; ... end</code> does it. Later when you do <code>X.new</code> Ruby does not create any <code>class</code> frames. This frame represents a class definition.</li><li>it can be a <code>rescue</code> frame that represents a code inside <code>rescue => e; &lt;...>; end</code> block</li><li>it can be an <code>ensure</code> frame (well, I&rsquo;m sure you get it)</li><li>there are also <code>module</code> (for a module body), <code>sclass</code> (for a singleton class) and a very unique <code>eval</code> frame.</li></ol><p>And they are stored internally as a stack.</p><p>When you invoke <code>caller</code> method you see this stack (or some information based on it). Each entry in the error backtrace is based on the state of this stack when the error is thrown.</p><p>OK, let&rsquo;s write some code to extend our VM:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FrameClass</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>COMMON_FRAME_ATTRIBUTES</span> <span style=color:#f92672>=</span> <span style=color:#f92672>%</span>i<span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    _self
</span></span><span style=display:flex><span>    nesting
</span></span><span style=display:flex><span>    locals
</span></span><span style=display:flex><span>    file
</span></span><span style=display:flex><span>    line
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>  <span style=color:#f92672>].</span>freeze
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>self</span><span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>(<span style=color:#f92672>*</span>arguments, <span style=color:#f92672>&amp;</span>block)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Struct</span><span style=color:#f92672>.</span>new(
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span><span style=color:#66d9ef>COMMON_FRAME_ATTRIBUTES</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>arguments,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>keyword_init</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    ) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      class_eval(<span style=color:#f92672>&amp;</span>block)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>self</span><span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>(<span style=color:#e6db74>iseq</span>:, <span style=color:#f92672>**</span>attributes)
</span></span><span style=display:flex><span>        instance <span style=color:#f92672>=</span> allocate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        instance<span style=color:#f92672>.</span>file <span style=color:#f92672>=</span> iseq<span style=color:#f92672>.</span>file
</span></span><span style=display:flex><span>        instance<span style=color:#f92672>.</span>line <span style=color:#f92672>=</span> iseq<span style=color:#f92672>.</span>line
</span></span><span style=display:flex><span>        instance<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> iseq<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>        instance<span style=color:#f92672>.</span>locals <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        instance<span style=color:#f92672>.</span>send(<span style=color:#e6db74>:initialize</span>, <span style=color:#f92672>**</span>attributes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        instance
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>I like builders and I don&rsquo;t like inheritance (the fact that frames share some common attributes does not mean that they should be inherited from an <code>AbstractFrame</code> class; also I don&rsquo;t like abstract classes, they are dead by definition)</p><p>Here&rsquo;s the first version of the <code>TopFrame</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>TopFrame</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameClass</span><span style=color:#f92672>.</span>new <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(<span style=color:#f92672>**</span>)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_self <span style=color:#f92672>=</span> <span style=color:#66d9ef>TOPLEVEL_BINDING</span><span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#39;self&#39;</span>)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>nesting <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#66d9ef>Object</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pretty_name</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;TOP </span><span style=color:#e6db74>#{</span>file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Let&rsquo;s walk through the code:</p><ol><li>each frame has a common set of attributes:</li><li><code>_self</code> - what <code>self</code> returns inside the frame</li><li><code>nesting</code> - what <code>Module.nesting</code> returns (used for the relative constant lookup)</li><li><code>locals</code> - a set of local variables</li><li><code>file</code> and <code>line</code> - currently running <code>__FILE__:__LINE__</code></li><li><code>name</code> - a human-readable name of the frame, we will use it mostly for debugging</li><li><code>FrameClass</code> is a builder that is capable of building a custom <code>Frame</code> class (similar to <code>Struct</code> class)</li><li><code>FrameClass.new</code> takes:</li><li>a list of custom frame-class-specific attributes</li><li>and a block that is evaluated in a context of the created frame class</li></ol><p>So, the <code>TopFrame</code> class is a <code>Struct</code>-like class that:</p><ol><li>has a constructor that takes <strong>only</strong> common attributes (because we haven&rsquo;t specified any in <code>FrameClass.new</code>)</li><li>has a custom behavior in the constructor that sets <code>_self</code> and <code>nesting</code></li><li>has a custom <code>pretty_name</code> instance method</li></ol><p>We will create as many classes as we need to cover all kinds of frames (I will return to it later, I promise)</p><h2 id=wrapping-the-iseq>Wrapping the ISeq</h2><p>I don&rsquo;t like working with plain arrays, and as I mentioned above there&rsquo;s a ton of useful information in the instruction sequence that we get from <code>RubyVM::InstructionSequence.compile("code").to_a</code>.</p><p>Let&rsquo;s create a wrapper that knows the meaning of array items:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ISeq</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:insns</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(ruby_iseq)
</span></span><span style=display:flex><span>    @ruby_iseq <span style=color:#f92672>=</span> ruby_iseq
</span></span><span style=display:flex><span>    @insns <span style=color:#f92672>=</span> @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>].</span>dup
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>file</span>
</span></span><span style=display:flex><span>    @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>6</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>line</span>
</span></span><span style=display:flex><span>    @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>8</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>kind</span>
</span></span><span style=display:flex><span>    @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>9</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>name</span>
</span></span><span style=display:flex><span>    @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>5</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lvar_names</span>
</span></span><span style=display:flex><span>    @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>10</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>args_info</span>
</span></span><span style=display:flex><span>    @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>11</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Instance methods are self-descriptive, but just in case:</p><ol><li><code>file</code>/<code>line</code> return file/line where the iseq has been created</li><li><code>kind</code> returns a Symbol that we will later use to distinguish frames (<code>:top</code> for a <code>TopFrame</code>)</li><li><code>insns</code> returns a list of instructions</li><li><code>name</code> is an internal name of the frame that is used in stacktraces (for <code>class X; end</code> it returns <code>&lt;class:X></code>)</li><li><code>lvar_names</code> is an array of all local variable names that are used in the frame</li><li><code>args_info</code> is a special Hash with a meta-information about arguments (empty for all frames except methods)</li></ol><h2 id=frame-stack>Frame stack</h2><p>Frames are organized as a stack internally, every time when we enter a frame Ruby pushes it on a stack. When the frame ends (i.e. when its list of instruction ends or there&rsquo;s a special <code>[:leave]</code> instruction) it pops it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FrameStack</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:stack</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#66d9ef>Enumerable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>
</span></span><span style=display:flex><span>    @stack <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>each</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> to_enum(<span style=color:#e6db74>:each</span>) <span style=color:#66d9ef>unless</span> block_given?
</span></span><span style=display:flex><span>    @stack<span style=color:#f92672>.</span>each { <span style=color:#f92672>|</span>frame<span style=color:#f92672>|</span> <span style=color:#66d9ef>yield</span> frame }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>push</span>(frame)
</span></span><span style=display:flex><span>    @stack <span style=color:#f92672>&lt;&lt;</span> frame
</span></span><span style=display:flex><span>    frame
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>push_top</span>(<span style=color:#f92672>**</span>args)
</span></span><span style=display:flex><span>    push <span style=color:#66d9ef>TopFrame</span><span style=color:#f92672>.</span>new(<span style=color:#f92672>**</span>args)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pop</span>
</span></span><span style=display:flex><span>    @stack<span style=color:#f92672>.</span>pop
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>    @stack<span style=color:#f92672>.</span>last
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>size</span>
</span></span><span style=display:flex><span>    @stack<span style=color:#f92672>.</span>size
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>empty?</span>
</span></span><span style=display:flex><span>    @stack<span style=color:#f92672>.</span>empty?
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Each entry in the stack is a frame that we entered at some point, so we can quickly build a <code>caller</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BacktraceEntry</span> <span style=color:#f92672>&lt;</span> String
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(frame)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span>frame<span style=color:#f92672>.</span>file<span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>#{</span>frame<span style=color:#f92672>.</span>line<span style=color:#e6db74>}</span><span style=color:#e6db74>:in `</span><span style=color:#e6db74>#{</span>frame<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stack <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameStack</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;2 + 3&#39;</span>
</span></span><span style=display:flex><span>iseq <span style=color:#f92672>=</span> <span style=color:#66d9ef>ISeq</span><span style=color:#f92672>.</span>new(<span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(code, <span style=color:#e6db74>&#39;test.rb&#39;</span>, <span style=color:#e6db74>&#39;/path/to/test.rb&#39;</span>, <span style=color:#ae81ff>42</span>)<span style=color:#f92672>.</span>to_a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stack<span style=color:#f92672>.</span>push_top(<span style=color:#e6db74>iseq</span>: iseq)
</span></span><span style=display:flex><span>caller <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>map { <span style=color:#f92672>|</span>frame<span style=color:#f92672>|</span> <span style=color:#66d9ef>BacktraceEntry</span><span style=color:#f92672>.</span>new(frame) }<span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>puts caller
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; &#34;/path/to/test.rb:42: in `&lt;compiled&gt;&#39;&#34;</span>
</span></span></code></pre></div><h2 id=writing-the-evaluator>Writing the evaluator</h2><p>Let&rsquo;s write it in a &ldquo;script style&rdquo; (it is simplified for a good reason, real code is much more complicated):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>iseq <span style=color:#f92672>=</span> <span style=color:#66d9ef>ISeq</span><span style=color:#f92672>.</span>new(<span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile_file(<span style=color:#e6db74>&#39;path/to/file.rb&#39;</span>)<span style=color:#f92672>.</span>to_a)
</span></span><span style=display:flex><span>frame_stack <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameStack</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>stack <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>frame_stack<span style=color:#f92672>.</span>push_top(<span style=color:#e6db74>iseq</span>: iseq)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>until</span> frame_stack<span style=color:#f92672>.</span>empty?
</span></span><span style=display:flex><span>  current_frame <span style=color:#f92672>=</span> frame_stack<span style=color:#f92672>.</span>top
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> current_frame<span style=color:#f92672>.</span>nil?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> current_frame<span style=color:#f92672>.</span>insns<span style=color:#f92672>.</span>empty?
</span></span><span style=display:flex><span>    frame_stack<span style=color:#f92672>.</span>pop_frame
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>next</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  current_insn <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>insns<span style=color:#f92672>.</span>shift
</span></span><span style=display:flex><span>  execute_insn(current_insn)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Generally speaking, the code above is the core of the VM. Once it&rsquo;s executed both <code>frame_stack</code> and <code>stack</code> must be empty. I added a bunch of consistency checks in my implementation, but for the sake of simplicity I&rsquo;m going to omit them here.</p><h2 id=instructions>Instructions</h2><p>I&rsquo;ll try to be short here, there are about 100 instructions in Ruby, and some of them look similar.</p><h3 id=putself-putobject-putnil-putstring-putiseq><code>putself</code>, <code>putobject</code>, <code>putnil</code>, <code>putstring</code>, <code>putiseq</code></h3><p>All of these guys push a simple object at the top of the stack. <code>putnil</code> pushes a known global <code>nil</code> object, others have an argument that is used in <code>stack.push(argument)</code></p><h3 id=optimized-instructions-like-opt_plus>optimized instructions like <code>opt_plus</code></h3><p>Ruby has a mode (that is turned on by default) that optimizes some frequently used method calls, like <code>+</code> or <code>.size</code>. It is possible to turn them off by manipulating <code>RubyVM::InstructionSequence.compile_option</code> (if you set <code>:specialized_instruction</code> to <code>false</code> you&rsquo;ll get a normal method call instead of the specialized instruction).</p><p>All of them do one specific thing, here&rsquo;s an example of the <code>opt_size</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_opt_size</span>(_)
</span></span><span style=display:flex><span>  push(pop<span style=color:#f92672>.</span>size)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Of course we do it this way because we cannot optimize it. MRI does a different thing:</p><ol><li>if there&rsquo;s a string/array/hash on top of the stack</li><li>and <code>String#size</code> (or <code>Array#size</code> if it&rsquo;s an array) is not redefined</li><li>then it <strong>directly</strong> calls a C method <code>rb_str_length</code> (or <code>RARRAY_LEN</code> if it&rsquo;s an array)</li><li>otherwise (if it&rsquo;s an object of some other type or a method has been redefined) it calls a method through the regular method dispatch mechanism (which is obviously slower)</li></ol><p>We could do the same sequence of steps, but we can&rsquo;t invoke a C method, and so calling a check + <code>.size</code> afterwards is even slower. It&rsquo;s better for us to fall to the slow branch from the beginning.</p><p>You can print all available specialized instructions by running</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>INSTRUCTION_NAMES</span><span style=color:#f92672>.</span>grep(<span style=color:#e6db74>/\Aopt_/</span>)
</span></span></code></pre></div><p>On Ruby 2.6.4 there are 34 of them.</p><h3 id=opt_send_without_block-or-send-if-specialized-instructions-are-disabled><code>opt_send_without_block</code> (or <code>send</code> if specialized instructions are disabled)</h3><p>This is an instruction that is used to invoke methods. <code>puts 123</code> looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#e6db74>:opt_send_without_block</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:puts</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>It has 2 arguments:</p><ol><li>a hash with options</li><li><code>mid</code> - a method ID (method name)</li><li><code>flag</code> - a bitmask with a metadata about the invocation</li><li><code>orig_argc</code> - a number of arguments passed to a method call</li><li>a boolean flag that is called <code>CALL_DATA</code> in C. I have no idea what it does</li></ol><p>Here&rsquo;s the rough implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_opt_send_without_block</span>(options, _)
</span></span><span style=display:flex><span>  mid <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:mid</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  args <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>].</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>  recv <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> recv<span style=color:#f92672>.</span>send(mid, <span style=color:#f92672>*</span>args)
</span></span><span style=display:flex><span>  push(result)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>So here we</p><ol><li>take a method from the <code>options</code> hash (<code>mid</code>)</li><li>then we pop N arguments from the stack (<code>args</code>)</li><li>then we pop the receiver of the method (<code>recv</code>)</li><li>then call <code>recv.send(mid, *args)</code> (in our case it&rsquo;s <code>self.send(:puts, *[123])</code></li><li>and then we push the result back to the stack</li></ol><h3 id=method-definition>method definition</h3><p>I intentionally started with method calls because Ruby defines methods via method calls. Yes.</p><p>Ruby has a special singleton object called <code>Frozen Core</code>. When you define a method via <code>def m; end</code> Ruby invokes <code>frozen_core.send("core#define_method", method_iseq)</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> ruby <span style=color:#f92672>--</span>dump<span style=color:#f92672>=</span>insns <span style=color:#f92672>-</span>e <span style=color:#e6db74>&#39;def m; end&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span> <span style=color:#e6db74>disasm</span>: <span style=color:#75715e>#&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000</span> putspecialobject             <span style=color:#ae81ff>1</span>                                   (   <span style=color:#ae81ff>1</span>)<span style=color:#f92672>[</span><span style=color:#66d9ef>Li</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0002</span> putobject                    <span style=color:#e6db74>:m</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0004</span> putiseq                      m
</span></span><span style=display:flex><span><span style=color:#ae81ff>0006</span> opt_send_without_block       <span style=color:#f92672>&lt;</span>callinfo!<span style=color:#e6db74>mid</span>:core<span style=color:#75715e>#define_method, argc:2, ARGS_SIMPLE&gt;, &lt;callcache&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>000</span><span style=color:#ae81ff>9</span> leave
</span></span></code></pre></div><p>The object itself is defined <a href=https://github.com/ruby/ruby/blob/beae6cbf0fd8b6619e5212552de98022d4c4d4d4/vm.c#L2983-L2996 target=_blank rel="noreferrer nofollow">here</a>
.</p><p>Of course, we don&rsquo;t have access to the Frozen Core. But we have an instruction that pushes it at the top of the stack. We can create our own <code>FrozenCore = Object.new.freeze</code> and check if <code>recv</code> is equal to this frozen core.</p><p>As you may notice there are also <code>putobject :m</code> and <code>putiseq</code> instructions. And <code>argc</code> of the method call is 2. Hmmm.</p><p><code>core#define_method</code> takes two arguments:</p><ol><li>a method name that is pushed by a <code>putobject</code> instruction</li><li>and an iseq that is &mldr; pushed by the <code>putiseq</code> instruction. Yes, instruction is an argument for another instruction.</li></ol><p>Here&rsquo;s the code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>if</span> recv<span style=color:#f92672>.</span>equal?(<span style=color:#66d9ef>FrozenCore</span>) <span style=color:#f92672>&amp;&amp;</span> mid <span style=color:#f92672>==</span> <span style=color:#e6db74>:&#39;core#define_method&#39;</span>
</span></span><span style=display:flex><span>  method_name, body_iseq <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>args
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> __define_method(<span style=color:#e6db74>method_name</span>: method_name, <span style=color:#e6db74>body_iseq</span>: body_iseq)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Here&rsquo;s how <code>__define_method</code> looks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__define_method</span>(<span style=color:#e6db74>method_name</span>:, <span style=color:#e6db74>body_iseq</span>:)
</span></span><span style=display:flex><span>  parent_nesting <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>nesting
</span></span><span style=display:flex><span>  define_on <span style=color:#f92672>=</span> <span style=color:#66d9ef>MethodDefinitionScope</span><span style=color:#f92672>.</span>new(current_frame)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  define_on<span style=color:#f92672>.</span>define_method(method_name) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|*</span>method_args, <span style=color:#f92672>&amp;</span>block<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>    execute(body_iseq, <span style=color:#e6db74>_self</span>: self, <span style=color:#e6db74>method_args</span>: method_args, <span style=color:#e6db74>block</span>: block, <span style=color:#e6db74>parent_nesting</span>: parent_nesting)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  method_name
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>When we enter a method in Ruby it inherits <code>Module.nesting</code> of a frame that defines it. This is why we also copy <code>current_frame.nesting</code> to a method frame.</p><p><code>define_on = MethodDefinitionScope.new(current_frame)</code> is also quite simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MethodDefinitionScope</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>self</span><span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>(frame)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>Class</span>, <span style=color:#66d9ef>Module</span>
</span></span><span style=display:flex><span>      frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>TOPLEVEL_BINDING</span><span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#39;self&#39;</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>Object</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      frame<span style=color:#f92672>.</span>_self<span style=color:#f92672>.</span>singleton_class
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><ul><li>If we define a method in a global scope it is defined on the <code>Object</code> class.</li><li>If we define a method inside a class/module context - well, class/module is where the method will be defined.</li><li>If we define a method inside some other context (inside <code>instance_eval</code> for example) - the method is defined on the singleton class of the object.</li></ul><p>These code constructions are equivalent:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#75715e># and</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Object</span><span style=color:#f92672>.</span>define_method(<span style=color:#e6db74>:m</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>X</span>; <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#66d9ef>end</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#75715e># and</span>
</span></span><span style=display:flex><span>X<span style=color:#f92672>.</span>define_method(<span style=color:#e6db74>:m</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>Object</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>o<span style=color:#f92672>.</span>instance_eval { <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#66d9ef>end</span> }
</span></span><span style=display:flex><span><span style=color:#75715e># and</span>
</span></span><span style=display:flex><span>o<span style=color:#f92672>.</span>singleton_class<span style=color:#f92672>.</span>define_method(<span style=color:#e6db74>:m</span>) {}
</span></span></code></pre></div><p>Then comes this part:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>define_on<span style=color:#f92672>.</span>define_method(method_name) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|*</span>method_args, <span style=color:#f92672>&amp;</span>block<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  execute(body_iseq, <span style=color:#e6db74>_self</span>: self, <span style=color:#e6db74>method_args</span>: method_args, <span style=color:#e6db74>block</span>: block, <span style=color:#e6db74>parent_nesting</span>: parent_nesting)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>We define a method that takes any arguments (it breaks <code>Method#parameters</code>, but let&rsquo;s ignore it) and an optional block and executes the ISeq of the method body in a context of <code>self</code>.</p><p>I admit that it&rsquo;s a very hacky trick, but it allows us to dynamically assign <code>self</code>.</p><p>Plus, we pass all other things that can (and in most cases will) be used in a method body:</p><ol><li><code>method_args</code> - what was given to a particular invocation of our method</li><li><code>block</code> - a block given to a method call</li><li><code>parent_nesting</code> - <code>Module.nesting</code> in the outer scope. We have to store in the beginning of the method definition because it may change before the method gets called.</li></ol><p><code>execute(iseq, **options)</code> is a tiny wrapper that pushes the frame into the <code>frame_stack</code> depending on the <code>kind</code> of the given iseq:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute</span>(iseq, <span style=color:#f92672>**</span>payload)
</span></span><span style=display:flex><span>  iseq <span style=color:#f92672>=</span> <span style=color:#66d9ef>ISeq</span><span style=color:#f92672>.</span>new(iseq)
</span></span><span style=display:flex><span>  push_frame(iseq, <span style=color:#f92672>**</span>payload)
</span></span><span style=display:flex><span>  evaluate_last_frame
</span></span><span style=display:flex><span>  pop_frame
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>push_frame</span>(iseq, <span style=color:#f92672>**</span>payload)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> iseq<span style=color:#f92672>.</span>kind
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#e6db74>:top</span>
</span></span><span style=display:flex><span>    @frame_stack<span style=color:#f92672>.</span>push_top(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>iseq</span>: iseq
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#e6db74>:method</span>
</span></span><span style=display:flex><span>    @frame_stack<span style=color:#f92672>.</span>push_method(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>iseq</span>: iseq,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>parent_nesting</span>: payload<span style=color:#f92672>[</span><span style=color:#e6db74>:parent_nesting</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>_self</span>: payload<span style=color:#f92672>[</span><span style=color:#e6db74>:_self</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>arg_values</span>: payload<span style=color:#f92672>[</span><span style=color:#e6db74>:method_args</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>block</span>: payload<span style=color:#f92672>[</span><span style=color:#e6db74>:block</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span>, <span style=color:#e6db74>&#34;Unknown iseq kind </span><span style=color:#e6db74>#{</span>iseq<span style=color:#f92672>.</span>kind<span style=color:#f92672>.</span>inspect<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=local-variables>local variables</h3><p>there are 2 most-commonly used instructions to get/set locals:</p><ul><li><code>getlocal</code></li><li><code>setlocal</code></li></ul><p>Both take two arguments:</p><ul><li>an offset of the frame where the variable is stored</li><li>an ID of the variable</li></ul><p>Here&rsquo;s an example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;a = 10; b = 20; a; b&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>10</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>20</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>We push <code>10</code> to the stack, then we pop it and assign to a variable with ID = 4 in the current frame (<code>setlocal_WC_0</code> here is a specialized instruction that is <code>setlocal 0, 4</code> when the optimization is turned off).</p><p>Here&rsquo;s the code to maintain locals:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;set&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># A simple struct that represents a single local variable;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># has a name, an ID and a value (or no value)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Local</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Struct</span><span style=color:#f92672>.</span>new(<span style=color:#e6db74>:name</span>, <span style=color:#e6db74>:id</span>, <span style=color:#e6db74>:value</span>, <span style=color:#e6db74>keyword_init</span>: <span style=color:#66d9ef>true</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get</span>
</span></span><span style=display:flex><span>    value
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set</span>(value)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>    value
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># A wrapper around &#34;Set&#34; that holds all locals for some frame;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Absolutely each frame has its own instance of &#34;Locals&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Locals</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>UNDEFINED</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Object</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>UNDEFINED</span><span style=color:#f92672>.</span><span style=color:#a6e22e>inspect</span>; <span style=color:#e6db74>&#39;UNDEFINED&#39;</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(initial_names)
</span></span><span style=display:flex><span>    @set <span style=color:#f92672>=</span> <span style=color:#66d9ef>Set</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    initial_names<span style=color:#f92672>.</span>reverse_each<span style=color:#f92672>.</span>with_index(<span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>arg_name, idx<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># implicit args (like a virtual attribute that holds mlhs value) have numeric names</span>
</span></span><span style=display:flex><span>      arg_name <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> arg_name<span style=color:#f92672>.</span>is_a?(Integer)
</span></span><span style=display:flex><span>      declare(name: arg_name, id: idx)<span style=color:#f92672>.</span>set(<span style=color:#66d9ef>Locals</span><span style=color:#f92672>::</span><span style=color:#66d9ef>UNDEFINED</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>declared?</span>(name: <span style=color:#66d9ef>nil</span>, id: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>!</span>find_if_declared(name: name, id: id)<span style=color:#f92672>.</span>nil?
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>declare</span>(name: <span style=color:#66d9ef>nil</span>, id: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    local <span style=color:#f92672>=</span> <span style=color:#66d9ef>Local</span><span style=color:#f92672>.</span>new(name: name, id: id, <span style=color:#e6db74>value</span>: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    @set <span style=color:#f92672>&lt;&lt;</span> local
</span></span><span style=display:flex><span>    local
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_if_declared</span>(name: <span style=color:#66d9ef>nil</span>, id: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> name
</span></span><span style=display:flex><span>      @set<span style=color:#f92672>.</span>detect { <span style=color:#f92672>|</span>var<span style=color:#f92672>|</span> var<span style=color:#f92672>.</span>name <span style=color:#f92672>==</span> name }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elsif</span> id
</span></span><span style=display:flex><span>      @set<span style=color:#f92672>.</span>detect { <span style=color:#f92672>|</span>var<span style=color:#f92672>|</span> var<span style=color:#f92672>.</span>id <span style=color:#f92672>==</span> id }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span>, <span style=color:#e6db74>&#34;At least one of name:/id: is required&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find</span>(name: <span style=color:#66d9ef>nil</span>, id: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> find_if_declared(name: name, id: id)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> result<span style=color:#f92672>.</span>nil?
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>InternalError</span>, <span style=color:#e6db74>&#34;No local name=</span><span style=color:#e6db74>#{</span>name<span style=color:#f92672>.</span>inspect<span style=color:#e6db74>}</span><span style=color:#e6db74>/id=</span><span style=color:#e6db74>#{</span>id<span style=color:#f92672>.</span>inspect<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pretty</span>
</span></span><span style=display:flex><span>    @set
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>map { <span style=color:#f92672>|</span>local<span style=color:#f92672>|</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span>local<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>(</span><span style=color:#e6db74>#{</span>local<span style=color:#f92672>.</span>id<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>, local<span style=color:#f92672>.</span>value<span style=color:#f92672>]</span> }
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>sort_by { <span style=color:#f92672>|</span>(name, value)<span style=color:#f92672>|</span> name }
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>to_h
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>So <code>locals</code> inside a frame is just a set. It is possible to declare a local, to check if it&rsquo;s declared and to get it.</p><p>Here&rsquo;s the implementation of <code>getlocal</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_getlocal</span>(local_var_id, n)
</span></span><span style=display:flex><span>  frame <span style=color:#f92672>=</span> n<span style=color:#f92672>.</span>times<span style=color:#f92672>.</span>inject(current_frame) { <span style=color:#f92672>|</span>f<span style=color:#f92672>|</span> f<span style=color:#f92672>.</span>parent_frame }
</span></span><span style=display:flex><span>  local <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>locals<span style=color:#f92672>.</span>find(id: local_var_id)
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> local<span style=color:#f92672>.</span>get
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> value<span style=color:#f92672>.</span>equal?(<span style=color:#66d9ef>Locals</span><span style=color:#f92672>::</span><span style=color:#66d9ef>UNDEFINED</span>)
</span></span><span style=display:flex><span>    value <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  push(value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>We jump out <code>n</code> times to get the Nth frame, we find a local, we return <code>nil</code> if it&rsquo;s <code>undefined</code> and we push the value back to the stack (so the result can be used by a subsequent instruction)</p><p>Here&rsquo;s the implementation of <code>setlocal</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_setlocal</span>(local_var_id, n)
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  frame <span style=color:#f92672>=</span> n<span style=color:#f92672>.</span>times<span style=color:#f92672>.</span>inject(current_frame) { <span style=color:#f92672>|</span>f<span style=color:#f92672>|</span> f<span style=color:#f92672>.</span>parent_frame }
</span></span><span style=display:flex><span>  local <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (existing_local <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>locals<span style=color:#f92672>.</span>find_if_declared(id: local_var_id))
</span></span><span style=display:flex><span>      existing_local
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elsif</span> frame<span style=color:#f92672>.</span>equal?(current_frame)
</span></span><span style=display:flex><span>      frame<span style=color:#f92672>.</span>locals<span style=color:#f92672>.</span>declare(id: local_var_id)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>InternalError</span>, <span style=color:#e6db74>&#39;locals are malformed&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  local<span style=color:#f92672>.</span>set(value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This one is a bit more complicated:</p><ol><li>first, we <code>pop</code> the value from the stack (it was pushed by a previous instruction <code>putobject 10</code>)</li><li>then we find Nth frame</li><li>then we get a local from this frame</li><li>if it&rsquo;s there we use it; if not - we declare it in the current frame</li><li>and then we set the value</li></ol><h3 id=method-arguments>method arguments</h3><p>Every method has a list of arguments. Yes, sometimes it&rsquo;s empty, but even in such case we do an arity check. In general arguments initialization is a part of every method call.</p><p>This part of Ruby is really complicated, because we have 12 argument types:</p><ul><li>required positional argument - <code>def m(x)</code></li><li>optional positional argument - <code>def m(x = 42)</code></li><li>rest argument - <code>def m(*x)</code></li><li>post argument - <code>def m(*, x = 1)</code></li><li><code>mlhs</code> argument (can be used as a post argument too) - <code>def m( (x, *y, z) )</code></li><li>required keyword argument - <code>def m(x:)</code></li><li>optional keyword argument - <code>def m(x: 42)</code></li><li>rest keyword argument - <code>def m(**x)</code></li><li>block argument - <code>def m(&amp;x)</code></li><li>shadow argument - <code>proc { |;x| }</code> (I did not implement it because I never used it)</li><li><code>nil</code> keyword argument (since 2.7) - <code>def m(**nil)</code></li><li>arguments forwarding (also since 2.7) - <code>def m(...)</code></li></ul><p>First, let&rsquo;s take a look at the iseq to see what we have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;def m(a, b = 42, *c, d); end&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>][</span><span style=color:#ae81ff>4</span><span style=color:#f92672>][</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#e6db74>&#34;YARVInstructionSequence/SimpleDataFormat&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span> {<span style=color:#e6db74>:arg_size</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:local_size</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:stack_max</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:node_id</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:code_location</span><span style=color:#f92672>=&gt;[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>28</span><span style=color:#f92672>]</span>},
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;m&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>:method</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:a</span>, <span style=color:#e6db74>:b</span>, <span style=color:#e6db74>:c</span>, <span style=color:#e6db74>:d</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> {<span style=color:#e6db74>:opt</span><span style=color:#f92672>=&gt;[</span><span style=color:#e6db74>:label_0</span>, <span style=color:#e6db74>:label_4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:lead_num</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:post_num</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:post_start</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:rest_start</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>2</span>},
</span></span><span style=display:flex><span> <span style=color:#f92672>[]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:label_0</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:label_4</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:putnil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:RUBY_EVENT_RETURN</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]]</span>
</span></span></code></pre></div><p>There are two entries that we are interested in:</p><ol><li>a list of argument names (well, it&rsquo;s a list of all variables, but it works for our case)</li><li>a hash with arguments information</li></ol><p>Let&rsquo;s prepare and group it first, it&rsquo;s hard to work with such format:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CategorizedArguments</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:req</span>, <span style=color:#e6db74>:opt</span>, <span style=color:#e6db74>:rest</span>, <span style=color:#e6db74>:post</span>, <span style=color:#e6db74>:kw</span>, <span style=color:#e6db74>:kwrest</span>, <span style=color:#e6db74>:block</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(arg_names, args_info)
</span></span><span style=display:flex><span>    @req <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>    @opt <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>    @rest <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    @post <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    parse!(arg_names<span style=color:#f92672>.</span>dup, args_info<span style=color:#f92672>.</span>dup)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse!</span>(arg_names, args_info)
</span></span><span style=display:flex><span>    (args_info<span style=color:#f92672>[</span><span style=color:#e6db74>:lead_num</span><span style=color:#f92672>]</span> <span style=color:#f92672>||</span> <span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>times <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      req <span style=color:#f92672>&lt;&lt;</span> take_arg(arg_names)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    opt_info <span style=color:#f92672>=</span> args_info<span style=color:#f92672>[</span><span style=color:#e6db74>:opt</span><span style=color:#f92672>].</span>dup <span style=color:#f92672>||</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>    opt_info<span style=color:#f92672>.</span>shift
</span></span><span style=display:flex><span>    opt_info<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>label<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      opt <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>[</span>take_arg(arg_names), label<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args_info<span style=color:#f92672>[</span><span style=color:#e6db74>:rest_start</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>      @rest <span style=color:#f92672>=</span> take_arg(arg_names)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (args_info<span style=color:#f92672>[</span><span style=color:#e6db74>:post_num</span><span style=color:#f92672>]</span> <span style=color:#f92672>||</span> <span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>times <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      post <span style=color:#f92672>&lt;&lt;</span> take_arg(arg_names)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>take_arg</span>(arg_names)
</span></span><span style=display:flex><span>    arg_name_or_idx <span style=color:#f92672>=</span> arg_names<span style=color:#f92672>.</span>shift
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> arg_name_or_idx<span style=color:#f92672>.</span>is_a?(Integer)
</span></span><span style=display:flex><span>      arg_name_or_idx <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    arg_name_or_idx
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>I intentionally skip keyword arguments here, but they are not that much different from other types of arguments. The only noticeable difference is that optional keyword arguments have &ldquo;inlined&rdquo; default values if they are simple enough (like plain strings or numbers, but not expressions like <code>2+2</code>). If you are interested you can go to the repository and check this file.</p><p>Then, we should parse arguments and assign them into local variables <strong>when we push a method frame</strong> (so they are available once we start executing instructions of a method body):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MethodArguments</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:args</span>, <span style=color:#e6db74>:values</span>, <span style=color:#e6db74>:locals</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(<span style=color:#e6db74>iseq</span>:, <span style=color:#e6db74>values</span>:, <span style=color:#e6db74>locals</span>:)
</span></span><span style=display:flex><span>    @values <span style=color:#f92672>=</span> values<span style=color:#f92672>.</span>dup
</span></span><span style=display:flex><span>    @locals <span style=color:#f92672>=</span> locals
</span></span><span style=display:flex><span>    @iseq <span style=color:#f92672>=</span> iseq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @args <span style=color:#f92672>=</span> <span style=color:#66d9ef>CategorizedArguments</span><span style=color:#f92672>.</span>new(
</span></span><span style=display:flex><span>      iseq<span style=color:#f92672>.</span>lvar_names,
</span></span><span style=display:flex><span>      iseq<span style=color:#f92672>.</span>args_info
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>extract</span>(<span style=color:#e6db74>arity_check</span>: <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> arity_check <span style=color:#f92672>&amp;&amp;</span> values<span style=color:#f92672>.</span>length <span style=color:#f92672>&lt;</span> args<span style=color:#f92672>.</span>req<span style=color:#f92672>.</span>count <span style=color:#f92672>+</span> args<span style=color:#f92672>.</span>post<span style=color:#f92672>.</span>count
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>ArgumentError</span>, <span style=color:#e6db74>&#39;wrong number of arguments (too few)&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Required positional args</span>
</span></span><span style=display:flex><span>    args<span style=color:#f92672>.</span>req<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>name<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> arity_check <span style=color:#f92672>&amp;&amp;</span> values<span style=color:#f92672>.</span>empty?
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>ArgumentError</span>, <span style=color:#e6db74>&#39;wrong number of arguments (too few)&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      value <span style=color:#f92672>=</span> values<span style=color:#f92672>.</span>shift
</span></span><span style=display:flex><span>      locals<span style=color:#f92672>.</span>find(name: name)<span style=color:#f92672>.</span>set(value)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Optional positional args</span>
</span></span><span style=display:flex><span>    args<span style=color:#f92672>.</span>opt<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>(name, label)<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span> <span style=color:#66d9ef>if</span> values<span style=color:#f92672>.</span>length <span style=color:#f92672>&lt;=</span> args<span style=color:#f92672>.</span>post<span style=color:#f92672>.</span>count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      value <span style=color:#f92672>=</span> values<span style=color:#f92672>.</span>shift
</span></span><span style=display:flex><span>      locals<span style=color:#f92672>.</span>find(name: name)<span style=color:#f92672>.</span>set(value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>VM</span><span style=color:#f92672>.</span>jump(label)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Rest positional argument</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>=</span> args<span style=color:#f92672>.</span>rest)
</span></span><span style=display:flex><span>      value <span style=color:#f92672>=</span> values<span style=color:#f92672>.</span>first(<span style=color:#f92672>[</span>values<span style=color:#f92672>.</span>length <span style=color:#f92672>-</span> args<span style=color:#f92672>.</span>post<span style=color:#f92672>.</span>length, <span style=color:#ae81ff>0</span><span style=color:#f92672>].</span>max)
</span></span><span style=display:flex><span>      @values <span style=color:#f92672>=</span> values<span style=color:#f92672>.</span>last(args<span style=color:#f92672>.</span>post<span style=color:#f92672>.</span>length)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      locals<span style=color:#f92672>.</span>find(name: name)<span style=color:#f92672>.</span>set(value)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Required post positional arguments</span>
</span></span><span style=display:flex><span>    args<span style=color:#f92672>.</span>post<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>name<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> arity_check <span style=color:#f92672>&amp;&amp;</span> values<span style=color:#f92672>.</span>empty?
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>ArgumentError</span>, <span style=color:#e6db74>&#39;Broken arguments, cannot extract required argument&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      value <span style=color:#f92672>=</span> values<span style=color:#f92672>.</span>shift
</span></span><span style=display:flex><span>      locals<span style=color:#f92672>.</span>find(name: name)<span style=color:#f92672>.</span>set(value)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Make sure there are no arguments left</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> arity_check <span style=color:#f92672>&amp;&amp;</span> values<span style=color:#f92672>.</span>any?
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>ArgumentError</span>, <span style=color:#e6db74>&#39;wrong number of arguments (too many)&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Here <code>values</code> is what we get in a method call in <code>*method_args</code>, <code>locals</code> is equal to <code>MethodFrame#locals</code> that is set to <code>Locals.new</code> by default.</p><p>Let&rsquo;s write <code>MethodFrame</code> class!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>MethodFrame</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameClass</span><span style=color:#f92672>.</span>new <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:arg_values</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:block</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(<span style=color:#e6db74>parent_nesting</span>:, <span style=color:#e6db74>_self</span>:, <span style=color:#e6db74>arg_values</span>:, <span style=color:#e6db74>block</span>:)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_self <span style=color:#f92672>=</span> _self
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>nesting <span style=color:#f92672>=</span> parent_nesting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @block <span style=color:#f92672>=</span> block
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>MethodArguments</span><span style=color:#f92672>.</span>new(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>iseq</span>: iseq,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>values</span>: arg_values,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>locals</span>: locals,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>block</span>: iseq<span style=color:#f92672>.</span>args_info<span style=color:#f92672>[</span><span style=color:#e6db74>:block_start</span><span style=color:#f92672>]</span> ? block : <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    )<span style=color:#f92672>.</span>extract(<span style=color:#e6db74>arity_check</span>: <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pretty_name</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span>_self<span style=color:#f92672>.</span>class<span style=color:#e6db74>}</span><span style=color:#e6db74>#</span><span style=color:#e6db74>#{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Method frame is just a regular frame that extracts arguments during its initialization.</p><h3 id=constants>constants</h3><p>A regular constant assignment (like <code>A = 1</code>) is based on a scope (<code>Module.nesting</code> for relative lookup) and two instructions:</p><ol><li><code>setconstant</code></li><li><code>getconstant</code></li></ol><p>Both have a single argument - a constant name. But how does Ruby distinguish relative and absolute constant lookup? I mean, what&rsquo;s the difference between <code>A</code> and <code>::A</code>?</p><p>Ruby uses a special instruction to set a &ldquo;constant scope&rdquo; that:</p><ul><li>for relative lookup<ul><li>in the optimized mode does <code>opt_getinlinecache</code> before <code>get/setconstant</code></li><li>in the non-optimized mode does <code>pushnil</code> (that works as a flag)</li></ul></li><li>for absolute lookup Ruby computes it via a sequence of instructions</li></ul><p>Let&rsquo;s take a look at the non-optimized mode (because we can&rsquo;t optimize it anyway):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;A; ::B; Kernel::D&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putnil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getconstant</span>, <span style=color:#e6db74>:A</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:pop</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#66d9ef>Object</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getconstant</span>, <span style=color:#e6db74>:B</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:pop</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putnil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getconstant</span>, <span style=color:#e6db74>:Kernel</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getconstant</span>, <span style=color:#e6db74>:D</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p><code>A</code> constant performs a relative lookup, so <code>putnil</code> is used.</p><p><code>::B</code> constant performs a global lookup on the <code>Object</code> that is a known object, and so it&rsquo;s inlined in the <code>putobject</code> instruction.</p><p><code>Kernel::D</code> first searches for <code>Kernel</code> constant locally, then it uses it as a &ldquo;scope&rdquo; for a constant <code>D</code>.</p><p>Quite easy, right? Not so fast. Ruby uses <code>Module.nesting</code> to perform a bottom-top search. This is why it&rsquo;s so important to maintain <code>nesting</code> value in frames. Thus, the lookup is performed on <code>current_scope.nesting</code> <strong>in reverse order</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_getconstant</span>(name)
</span></span><span style=display:flex><span>  scope <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  search_in <span style=color:#f92672>=</span> scope<span style=color:#f92672>.</span>nil? ? current_scope<span style=color:#f92672>.</span>nesting<span style=color:#f92672>.</span>reverse : <span style=color:#f92672>[</span>scope<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  search_in<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>mod<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> mod<span style=color:#f92672>.</span>const_defined?(name)
</span></span><span style=display:flex><span>      const <span style=color:#f92672>=</span> mod<span style=color:#f92672>.</span>const_get(name)
</span></span><span style=display:flex><span>      push(const)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NameError</span>, <span style=color:#e6db74>&#34;uninitialized constant </span><span style=color:#e6db74>#{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>If the scope is given (via <code>push</code> in a previous instruction) we use it. Otherwise we have a relative lookup and so we must use <code>current_scope.nesting.reverse</code>.</p><p><code>setconstant</code> is a bit simpler, because it always defines a constant on a scope set by a previous instruction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;A = 10; ::B = 20; Kernel::D = 30&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>10</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putspecialobject</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setconstant</span>, <span style=color:#e6db74>:A</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>20</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#66d9ef>Object</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setconstant</span>, <span style=color:#e6db74>:B</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>30</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putnil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getconstant</span>, <span style=color:#e6db74>:Kernel</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setconstant</span>, <span style=color:#e6db74>:D</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p><code>putspecialobject</code> is an instruction that is (when called with 3) pushes a &ldquo;current&rdquo; scope.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>putspecialobject</span>(kind)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> kind
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    push(current_frame<span style=color:#f92672>.</span>nesting<span style=color:#f92672>.</span>last) <span style=color:#75715e># push &#34;current&#34; scope</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span>, <span style=color:#e6db74>&#34;Unknown special object </span><span style=color:#e6db74>#{</span>kind<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setconstant</span>(name)
</span></span><span style=display:flex><span>  scope <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  scope<span style=color:#f92672>.</span>const_set(name, value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=instanceclass-variables>Instance/Class variables</h3><p>Instance variables are always picked from the <code>self</code> of the current frame (they literally look like a simplified version of local variables that are always stored in <code>self</code> of the current scope):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;@a = 42; @a&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setinstancevariable</span>, <span style=color:#e6db74>:@a</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getinstancevariable</span>, <span style=color:#e6db74>:@a</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>I guess you know how the code should look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_getinstancevariable</span>(name, _)
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>_self<span style=color:#f92672>.</span>instance_variable_get(name)
</span></span><span style=display:flex><span>  push(value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_setinstancevariable</span>(name, _)
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  current_frame<span style=color:#f92672>.</span>_self<span style=color:#f92672>.</span>instance_variable_set(name, value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Class variables are similar, but it is possible to get it in the instance method, so it uses <code>self</code> if our current frame is a <code>ClassFrame</code> or <code>self.class</code> otherwise:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;@@a = 42; @@a&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setclassvariable</span>, <span style=color:#e6db74>:@@a</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getclassvariable</span>, <span style=color:#e6db74>:@@a</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_setclassvariable</span>(name)
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  klass <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>  klass <span style=color:#f92672>=</span> klass<span style=color:#f92672>.</span>class <span style=color:#66d9ef>unless</span> klass<span style=color:#f92672>.</span>is_a?(<span style=color:#66d9ef>Class</span>)
</span></span><span style=display:flex><span>  klass<span style=color:#f92672>.</span>class_variable_set(name, value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_getclassvariable</span>(name)
</span></span><span style=display:flex><span>  klass <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>  klass <span style=color:#f92672>=</span> klass<span style=color:#f92672>.</span>class <span style=color:#66d9ef>unless</span> klass<span style=color:#f92672>.</span>is_a?(<span style=color:#66d9ef>Class</span>)
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> klass<span style=color:#f92672>.</span>class_variable_get(name)
</span></span><span style=display:flex><span>  push(value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=literals>Literals</h3><p>But how can we construct arrays, hashes?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;[ [:foo,a,:bar], [4,5], 42 ]&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>:foo</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:a</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>28</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>:bar</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newarray</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:duparray</span>, <span style=color:#f92672>[</span><span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>]]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newarray</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>As you can see the strategy of building an array depends on its dynamicity:</p><ul><li>for dynamic <code>[:foo, a, :bar]</code> MRI uses <code>newarray</code> (because <code>a</code> has to be computed in runtime)</li><li>for primitive <code>[4, 5]</code> it uses <code>duparray</code> (because it&rsquo;s faster)</li></ul><p>The whole array is also dynamic (because one of its elements is also dynamic). Let&rsquo;s define them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_duparray</span>(array)
</span></span><span style=display:flex><span>  push(array<span style=color:#f92672>.</span>dup)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_newarray</span>(size)
</span></span><span style=display:flex><span>  array <span style=color:#f92672>=</span> size<span style=color:#f92672>.</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>  push(array)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Do hashes support inlining?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;{ primitive: { foo: :bar }, dynamic: { c: d } }&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>:primitive</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:duphash</span>, {<span style=color:#e6db74>:foo</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:bar</span>}<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>:dynamic</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>:c</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:d</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>28</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newhash</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newhash</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Yes! <code>duphash</code> contains an inlined hash that should be pushed to the stack as is. <code>newhash</code> has a numeric argument that represents the number of keys and values on the hash (i.e. <code>keys * 2</code> or <code>values * 2</code>, there&rsquo;s no difference). And once again, if at least one element of the hash is dynamic, the whole has is also dynamic and so it uses <code>newhash</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_duphash</span>(hash)
</span></span><span style=display:flex><span>  push(hash<span style=color:#f92672>.</span>dup)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_newhash</span>(size)
</span></span><span style=display:flex><span>  hash <span style=color:#f92672>=</span> size<span style=color:#f92672>.</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse<span style=color:#f92672>.</span>each_slice(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>.</span>to_h
</span></span><span style=display:flex><span>  push(hash)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Why do we need <code>.dup</code> in <code>duphash</code> and <code>duparray</code>? The reason is simple: this instruction can be executed multiple times (if it&rsquo;s a part of a method or block, for example), and so the same value will be pushed to the stack multiple times. One of the next instructions can modify it but literals have to stay static no matter what. Without using <code>.dup</code> the code like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#ae81ff>2</span><span style=color:#f92672>.</span>times <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  p <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>].</span>pop
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>would print <code>3</code> and <code>2</code>.</p><h3 id=splats>Splats</h3><p>Splat is one of the most beautiful features of Ruby. Splat is <code>foo, bar = *baz</code> (and also <code>[*foo, *bar]</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;a, b = *c, 42&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:c</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>28</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:splatarray</span>, <span style=color:#66d9ef>true</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newarray</span>, <span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:concatarray</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:expandarray</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p><code>splatarray</code> pops the object from the stack, converts it to <code>Array</code> by calling <code>to_a</code> (if it&rsquo;s not an array; otherwise there&rsquo;s no type casting), and pushes the result back to the stack.</p><p><code>concatarray</code> constructs an array from two top elements and pushes it back. So it changes the stack <code>[a, b]</code> to <code>[ [a,b] ]</code>. If items are arrays it expands and merges them.</p><p><code>expandarray</code> expands it by doing <code>pop</code> and pushing items back to the stack. It takes the number of elements that need to be returned, so if an array is bigger it drops some items, if it&rsquo;s too small - it pushes as many <code>nil</code>s as needed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_splatarray</span>(_)
</span></span><span style=display:flex><span>  array <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  array <span style=color:#f92672>=</span> array<span style=color:#f92672>.</span>to_a <span style=color:#66d9ef>unless</span> array<span style=color:#f92672>.</span>is_a?(Array)
</span></span><span style=display:flex><span>  push(array)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_concatarray</span>(_)
</span></span><span style=display:flex><span>  last <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  first <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  push(<span style=color:#f92672>[*</span>first, <span style=color:#f92672>*</span>last<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_expandarray</span>(size, _flag)
</span></span><span style=display:flex><span>  array <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> array<span style=color:#f92672>.</span>size <span style=color:#f92672>&lt;</span> size
</span></span><span style=display:flex><span>    array<span style=color:#f92672>.</span>push(<span style=color:#66d9ef>nil</span>) <span style=color:#66d9ef>until</span> array<span style=color:#f92672>.</span>size <span style=color:#f92672>==</span> size
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>elsif</span> array<span style=color:#f92672>.</span>size <span style=color:#f92672>&gt;</span> size
</span></span><span style=display:flex><span>    array<span style=color:#f92672>.</span>pop <span style=color:#66d9ef>until</span> array<span style=color:#f92672>.</span>size <span style=color:#f92672>==</span> size
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># they are equal</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  array<span style=color:#f92672>.</span>reverse_each { <span style=color:#f92672>|</span>item<span style=color:#f92672>|</span> push(item) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>In fact <code>expandarray</code> is much, much more complicated, you can go to the repository and check it if you want.</p><p>Keyword splats (like <code>{ **x, **y }</code>) are really similar to array splats, I&rsquo;m not going to cover them here.</p><h3 id=conditions-ifunless>conditions (if/unless)</h3><p>To handle conditions Ruby uses local <code>goto</code> (just like in C). Target of the <code>goto</code>-like instruction is a label:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#34;a = b = c = 42; if a; b; else; c; end&#34;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:branchunless</span>, <span style=color:#e6db74>:label_20</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:jump</span>, <span style=color:#e6db74>:label_16</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:label_16</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:jump</span>, <span style=color:#e6db74>:label_22</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:label_20</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:label_22</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Do you see these <code>:label_&lt;NN></code> symbols? They are used as markers. <code>branchunless</code> takes a single argument: a label that it to jump to if the value on the top of the stack is <code>false</code> or <code>nil</code>. If it&rsquo;s <code>true</code>-like it does nothing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_branchunless</span>(label)
</span></span><span style=display:flex><span>  cond <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unless</span> cond
</span></span><span style=display:flex><span>    jump(label)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>jump</span>(label)
</span></span><span style=display:flex><span>  insns <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>iseq<span style=color:#f92672>.</span>insns
</span></span><span style=display:flex><span>  insns<span style=color:#f92672>.</span>drop_while { <span style=color:#f92672>|</span>insn<span style=color:#f92672>|</span> insn <span style=color:#f92672>!=</span> label }
</span></span><span style=display:flex><span>  insns<span style=color:#f92672>.</span>shift <span style=color:#75715e># to drop the label too</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Here we do <code>pop</code>, check it and call <code>jump</code> if it&rsquo;s <code>false</code>. <code>jump</code> skips instructions until it sees a given label.</p><p>MRI also has <code>branchif</code> and <code>branchnil</code>:</p><ul><li><code>branchif</code> does <code>if cond</code> as a main check</li><li><code>branchnil</code> does <code>if cond.nil?</code></li></ul><h3 id=string-interpolationconcatenation>String interpolation/concatenation</h3><p>Ruby has a few compile-time optimizations that optimize code like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#e6db74>&#34;a&#34;&#34;b&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span><span style=color:#e6db74>&#39;a&#39;</span><span style=color:#e6db74>}#{</span><span style=color:#e6db74>&#39;b&#39;</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>into a string <code>"ab"</code>. However more complicated cases with dynamic interpolation involve a few new instructions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;&#34;#{a}#{:sym}&#34;&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:a</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>28</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:checktype</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:branchif</span>, <span style=color:#e6db74>:label_18</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:to_s</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:tostring</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>:label_18</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>:sym</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:checktype</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:branchif</span>, <span style=color:#e6db74>:label_31</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:dup</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:to_s</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:tostring</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>:label_31</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:concatstrings</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Parts above are split into sections.</p><ol><li>There&rsquo;s an &ldquo;invisible&rdquo; beginning of the string (<code>putobject ""</code>)</li><li>Then we have an interpolated method call <code>a</code>:</li><li>First we call <code>a</code> via <code>send</code></li><li>then we run <code>checktype</code> instruction that checks for an argument <code>5</code> that what&rsquo;s popped is a string. it pushes back a boolean value</li><li>then we conditionally invoke <code>to_s</code> if the object is not a string</li><li>then we have an interpolated symbol <code>:sym</code> that gets interpolated in the same way</li><li>and finally we invoke <code>concatstrings 3</code> that does <code>pop</code> 3 times, concatenates 3 strings and pushes the result back to the stack</li></ol><p>First let&rsquo;s take a look at the <code>checktype</code> instruction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>CHECK_TYPE</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-&gt;</span>(klass, obj) {
</span></span><span style=display:flex><span>  klass <span style=color:#f92672>===</span> obj
</span></span><span style=display:flex><span>}<span style=color:#f92672>.</span>curry
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RB_OBJ_TYPES</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_NONE</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x01</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>CHECK_TYPE</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Object</span><span style=color:#f92672>]</span>,                        <span style=color:#75715e># RUBY_T_OBJECT</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x02</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_CLASS</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x03</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_MODULE</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x04</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_FLOAT</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x05</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>CHECK_TYPE</span><span style=color:#f92672>[</span>String<span style=color:#f92672>]</span>,                        <span style=color:#75715e># RUBY_T_STRING</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x06</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_REGEXP</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x07</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_ARRAY</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x08</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_HASH</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x09</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_STRUCT</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x0a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_BIGNUM</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x0b</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_FILE</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x0c</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_DATA</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x0d</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_MATCH</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x0e</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_COMPLEX</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x0f</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_RATIONAL</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x11</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_NIL</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x12</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_TRUE</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x13</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_FALSE</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x14</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_SYMBOL</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x15</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_FIXNUM</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_UNDEF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x1a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_IMEMO</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x1b</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_NODE</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x1c</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_ICLASS</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x1d</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_ZOMBIE</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x1e</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_MOVED</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x1f</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-&gt;</span>(obj) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>NotImplementedError</span> },     <span style=color:#75715e># RUBY_T_MASK</span>
</span></span><span style=display:flex><span>}<span style=color:#f92672>.</span>freeze
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_checktype</span>(type)
</span></span><span style=display:flex><span>  item_to_check <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  check <span style=color:#f92672>=</span> <span style=color:#66d9ef>RB_OBJ_TYPES</span><span style=color:#f92672>.</span>fetch(type) { <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>InternalError</span>, <span style=color:#e6db74>&#34;checktype - unknown type </span><span style=color:#e6db74>#{</span>type<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> }
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> check<span style=color:#f92672>.</span>call(item_to_check)
</span></span><span style=display:flex><span>  push(result)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>I blindly took it from MRI and yes, this instruction supports many types. I implemented only two of them, but the rest looks simple (except <code>imemo</code> and friends). Honestly I have no idea why, but about 95% of specs from the RubySpec (only language group, I did not check the whole test suite) are passing with these missing parts. I have no idea how to trigger MRI to use them. Maybe it uses them internally?</p><p><code>concatstrings</code> looks just like <code>newarray</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_concatstrings</span>(count)
</span></span><span style=display:flex><span>  strings <span style=color:#f92672>=</span> count<span style=color:#f92672>.</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>  push(strings<span style=color:#f92672>.</span>join)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=blocks>Blocks</h3><p>Blocks are passed to method calls as a third argument:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;m { |a| a + 42 }&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>,
</span></span><span style=display:flex><span>  {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:m</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>4</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>},
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;YARVInstructionSequence/SimpleDataFormat&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>   {<span style=color:#e6db74>:arg_size</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:local_size</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:stack_max</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:node_id</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:code_location</span><span style=color:#f92672>=&gt;[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>16</span><span style=color:#f92672>]</span>},
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;block in &lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>:block</span>,
</span></span><span style=display:flex><span>   <span style=color:#f92672>[</span><span style=color:#e6db74>:a</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>   {<span style=color:#e6db74>:lead_num</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>:ambiguous_param0</span><span style=color:#f92672>=&gt;</span><span style=color:#66d9ef>true</span>},
</span></span><span style=display:flex><span>   <span style=color:#f92672>[[</span><span style=color:#e6db74>:redo</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#e6db74>:label_1</span>, <span style=color:#e6db74>:label_9</span>, <span style=color:#e6db74>:label_1</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:next</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#e6db74>:label_1</span>, <span style=color:#e6db74>:label_9</span>, <span style=color:#e6db74>:label_9</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]]</span>,
</span></span><span style=display:flex><span>   <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:RUBY_EVENT_B_CALL</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:nop</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:label_1</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:RUBY_EVENT_LINE</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:+</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>16</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:label_9</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:nop</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:RUBY_EVENT_B_RETURN</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]]]]</span>
</span></span></code></pre></div><p>Block definitely needs a frame that looks pretty much like a <code>MethodFrame</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>BlockFrame</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameClass</span><span style=color:#f92672>.</span>new(<span style=color:#e6db74>:arg_values</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(<span style=color:#e6db74>arg_values</span>:)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_self <span style=color:#f92672>=</span> parent_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>nesting <span style=color:#f92672>=</span> parent_frame<span style=color:#f92672>.</span>nesting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>MethodArguments</span><span style=color:#f92672>.</span>new(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>iseq</span>: iseq,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>values</span>: arg_values,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>locals</span>: locals,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>block</span>: <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    )<span style=color:#f92672>.</span>extract(<span style=color:#e6db74>arity_check</span>: <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pretty_name</span>
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>(For simplicity let&rsquo;s ignore that blocks can also take blocks; also let&rsquo;s ignore lambdas, we will return to them later)</p><p>The code above looks <strong>almost</strong> like a method frame. The only difference is the <code>arity_check</code> value that we pass to the <code>MethodArguments</code> class.</p><p>But when should we create this frame? And how can we get a proc from it?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>VM_CALL_ARGS_BLOCKARG</span>   <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0x01</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_send</span>(options, flag, block_iseq)
</span></span><span style=display:flex><span>  _self <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>  mid <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:mid</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  args <span style=color:#f92672>=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  block <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> block_iseq
</span></span><span style=display:flex><span>      proc <span style=color:#66d9ef>do</span> <span style=color:#f92672>|*</span>args<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>        execute(block_iseq, self: _self, <span style=color:#e6db74>arg_values</span>: args)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elsif</span> flag <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>VM_CALL_ARGS_BLOCKARG</span>
</span></span><span style=display:flex><span>      pop
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  args <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>].</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>  recv <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> recv<span style=color:#f92672>.</span>send(mid, <span style=color:#f92672>*</span>args, <span style=color:#f92672>&amp;</span>block)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  push(result)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>It looks like a more generalized version of <code>opt_send_without_block</code>, because <code>opt_send_without_block</code> is a specialized implementation of <code>send</code>.</p><p>This instruction also pops a receiver and arguments, but what&rsquo;s important, it also computes the block.</p><ol><li>If <code>block_iseq</code> is given we create a proc that (once called) executes a block instruction (i.e. a block body) with given arguments. This block uses <code>self</code> of the place where it was created. (i.e. <code>self == proc { self }.call</code> always returns true)</li><li>If there&rsquo;s no <code>block_iseq</code> the block can be given via a <code>&amp;block</code> argument. MRI marks method call as <code>VM_CALL_ARGS_BLOCKARG</code> (this flag is just a bitmask)</li><li>and then we simply call a method with a generated proc object.</li></ol><p>Implicit block like <code>b = proc {}; m(&amp;b)</code> does not need any additional implementation. Method <code>proc</code> here takes a block (handled by the first <code>if</code> branch), it gets stored in a local variable and we pass it to the method as a block argument (<code>elseif</code> branch).</p><h3 id=lambdas>Lambdas</h3><p>It&rsquo;s complicated and I don&rsquo;t have a complete solution that covers all cases (I guess because MRI does not expose enough APIs to do it. Or I&rsquo;m just not smart enough).</p><p>Arrow lambda (<code>->(){}</code>) is just a method call <code>FrozenCore#lambda</code>, and so we can easily determine that it&rsquo;s a lambda and not a proc. But what about <code>lambda {}</code>? It can be overwritten.</p><p>An incomplete (and somewhat unreliable) solution is to check that our receiver does not override <code>lambda</code> method inherited from a <code>Kernel</code> module:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>creating_a_lambda <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> mid <span style=color:#f92672>==</span> <span style=color:#e6db74>:lambda</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> recv<span style=color:#f92672>.</span>equal?(<span style=color:#66d9ef>FrozenCore</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># -&gt;{} syntax</span>
</span></span><span style=display:flex><span>    creating_a_lambda <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> recv<span style=color:#f92672>.</span>class<span style=color:#f92672>.</span>instance_method(<span style=color:#e6db74>:lambda</span>)<span style=color:#f92672>.</span>owner <span style=color:#f92672>==</span> <span style=color:#66d9ef>Kernel</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>Kernel</span><span style=color:#f92672>.</span>instance_method(<span style=color:#e6db74>:lambda</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>RubyRb</span><span style=color:#f92672>::</span><span style=color:#66d9ef>REAL_KERNEL_LAMBDA</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># an original &#34;lambda&#34; method from a Kernel module</span>
</span></span><span style=display:flex><span>      creating_a_lambda <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Then we can set it on our block frame as an attribute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># in the branch that creates a proc from the `block_iseq`</span>
</span></span><span style=display:flex><span>proc <span style=color:#66d9ef>do</span> <span style=color:#f92672>|*</span>args<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  execute(block_iseq, self: _self, <span style=color:#e6db74>arg_values</span>: args, <span style=color:#e6db74>is_lambda</span>: creating_a_lambda)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>BlockFrame</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameClass</span><span style=color:#f92672>.</span>new(<span style=color:#e6db74>:arg_values</span>, <span style=color:#e6db74>:is_lambda</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(<span style=color:#e6db74>arg_values</span>:, <span style=color:#e6db74>is_lambda</span>:)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>is_lambda <span style=color:#f92672>=</span> is_lambda
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_self <span style=color:#f92672>=</span> parent_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>nesting <span style=color:#f92672>=</span> parent_frame<span style=color:#f92672>.</span>nesting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>MethodArguments</span><span style=color:#f92672>.</span>new(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>iseq</span>: iseq,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>values</span>: arg_values,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>locals</span>: locals,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>block</span>: <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    )<span style=color:#f92672>.</span>extract(<span style=color:#e6db74>arity_check</span>: is_lambda)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Arity check is enabled only if our proc is a lambda.</p><h3 id=calling-a-block>Calling a block</h3><p>If you remember when we define a method we tell it to save given block in a method frame:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>define_on<span style=color:#f92672>.</span>define_method(method_name) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|*</span>method_args, <span style=color:#f92672>&amp;</span>block<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  execute(body_iseq, <span style=color:#e6db74>_self</span>: self, <span style=color:#e6db74>method_args</span>: method_args, <span style=color:#e6db74>block</span>: block, <span style=color:#e6db74>parent_nesting</span>: parent_nesting)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>And the frame itself saves it in the <code>attr_reader</code>.</p><p>So both explicit and implicit blocks are available in a method body via <code>current_frame.block</code>. It&rsquo;s possible to invoke it by calling <code>block.call(arguments)</code> (if it&rsquo;s available as an explicit block argument) or to call <code>yield(arguments)</code> (in such case it does not even have to be declared in a method signature).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;def m; yield; end&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>][</span><span style=color:#ae81ff>4</span><span style=color:#f92672>][</span><span style=color:#ae81ff>1</span><span style=color:#f92672>][</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:invokeblock</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#66d9ef>nil</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>16</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>0</span>}<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Honestly even before I started working on this article I expected MRI to do something like this. <code>yield</code> is equivalent to <code>&lt;current block>.call(args)</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_invokeblock</span>(options)
</span></span><span style=display:flex><span>  args <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>].</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  frame <span style=color:#f92672>=</span> current_frame
</span></span><span style=display:flex><span>  frame <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>parent_frame <span style=color:#66d9ef>until</span> frame<span style=color:#f92672>.</span>can_yield?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>block<span style=color:#f92672>.</span>call(<span style=color:#f92672>*</span>args)
</span></span><span style=display:flex><span>  push(result)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Do you see <code>frame = frame.parent_frame until frame.can_yield?</code>? The reason for this line is that you may have a code like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span><span style=color:#f92672>].</span>each { <span style=color:#f92672>|</span>item<span style=color:#f92672>|</span> <span style=color:#66d9ef>yield</span> item }
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>^ <code>yield</code> here belongs to the method <code>m</code>, not to the <code>BlockFrame</code> of the <code>.each</code> method. There can be more nested blocks, so we have to go up until we see something that supports <code>yield</code>. Well, we know that only one frame can do <code>yield</code>: it&rsquo;s a <code>MethodFrame</code>.</p><p>Our frame class factory need to be extended to generate this method by default and return false from it. <code>MethodFrame</code> has to override it and return <code>true</code>. Polymorphism!</p><h3 id=super>Super</h3><p>Calling <code>super</code> is very similar to calling <code>yield</code>: it can be replaced with <code>method(__method__).super_method.call(args)</code>.</p><p><code>__method__</code> can be retrieved from <code>current_frame.name</code>, <code>args</code> are processed using <code>options[:orig_argc]</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_invokesuper</span>(options, _, _)
</span></span><span style=display:flex><span>  recv <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>  mid <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>  super_method <span style=color:#f92672>=</span> recv<span style=color:#f92672>.</span>method(mid)<span style=color:#f92672>.</span>super_method
</span></span><span style=display:flex><span>  args <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>].</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> super_method<span style=color:#f92672>.</span>call(<span style=color:#f92672>*</span>args)
</span></span><span style=display:flex><span>  push(result)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This implementation is incorrect, it can&rsquo;t handle a sequence of <code>super</code> calls (<code>class A &lt; B &lt; C</code>, each has a method that calls <code>super</code>). I guess it&rsquo;s possible to implement it by recording the class where the method was defined (i.e. by storing <code>current_frame._self</code> before calling <code>define_method</code> and passing it to the <code>MethodFrame</code> constructor as a <code>defined_in</code> attribute). This way we could do something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_invokesuper</span>(options, _, _)
</span></span><span style=display:flex><span>  recv <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>  mid <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  dispatchers <span style=color:#f92672>=</span> recv<span style=color:#f92672>.</span>class<span style=color:#f92672>.</span>ancestors
</span></span><span style=display:flex><span>  current_dispatcher_idx <span style=color:#f92672>=</span> dispatchers<span style=color:#f92672>.</span>index(current_frame<span style=color:#f92672>.</span>defined_in)
</span></span><span style=display:flex><span>  next_dispatcher <span style=color:#f92672>=</span> dispatchers<span style=color:#f92672>[</span>current_dispatcher_idx <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  super_method <span style=color:#f92672>=</span> next_dispatcher<span style=color:#f92672>.</span>instance_method(mid)<span style=color:#f92672>.</span>bind(recv)
</span></span><span style=display:flex><span>  args <span style=color:#f92672>=</span> options<span style=color:#f92672>[</span><span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>].</span>times<span style=color:#f92672>.</span>map { pop }<span style=color:#f92672>.</span>reverse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> super_method<span style=color:#f92672>.</span>call(<span style=color:#f92672>*</span>args)
</span></span><span style=display:flex><span>  push(result)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>I did not implement it because MSpec does not rely on it and I usually try to avoid sequences of <code>super</code> calls.</p><h3 id=global-variables>Global variables</h3><p>Similar to locals and instance variables, there are <code>getglobal</code>/<code>setglobal</code> instructions. They also take a variable name as an argument.</p><p>Unfortunately, Ruby has no API to dynamically get/set global variables. But we have <code>eval</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_getglobal</span>((name))
</span></span><span style=display:flex><span>  push eval(name<span style=color:#f92672>.</span>to_s)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_setglobal</span>((name))
</span></span><span style=display:flex><span>  <span style=color:#75715e># there&#39;s no way to set a gvar by name/value</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># but eval can reference locals</span>
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  eval(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> = value&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=defined-keyword><code>defined?</code> keyword</h3><p>As you may know this keyword can handle pretty much anything:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;defined?(42)&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>&#34;expression&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;a = 42; defined?(a)&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#e6db74>&#34;local-variable&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>In some simple cases it does not do any computations. It&rsquo;s obvious that <code>42</code> is an expression and <code>a</code> is a local variable (and there&rsquo;s no way to remove it by any code between assignment and <code>defined?</code> check)</p><p>More advanced checks use a <code>defined</code> instruction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;@a = 42; defined?(@a)&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>42</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setinstancevariable</span>, <span style=color:#e6db74>:@a</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putnil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:defined</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>:@a</span>, <span style=color:#66d9ef>true</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>The first argument is a special <code>enum</code> flag that specifies what are we trying to check here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>module</span> DefinedType
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_NOT_DEFINED</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_NIL</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_IVAR</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_LVAR</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_GVAR</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_CVAR</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_CONST</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_METHOD</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_YIELD</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_ZSUPER</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_SELF</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_TRUE</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_FALSE</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_ASGN</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_EXPR</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_IVAR2</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_REF</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>DEFINED_FUNC</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>I&rsquo;ll show you the branch that handles instance variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_defined</span>(defined_type, obj, needstr)
</span></span><span style=display:flex><span>  <span style=color:#75715e># used only in DEFINED_FUNC/DEFINED_METHOD branches</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># but we still have to do `pop` here (even if it&#39;s unused)</span>
</span></span><span style=display:flex><span>  context <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  verdict <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> defined_type
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>DefinedType</span><span style=color:#f92672>::</span><span style=color:#66d9ef>DEFINED_IVAR</span>
</span></span><span style=display:flex><span>      ivar_name <span style=color:#f92672>=</span> obj
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> current_frame<span style=color:#f92672>.</span>_self<span style=color:#f92672>.</span>instance_variable_defined?(ivar_name)
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;instance-variable&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... other branches</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  push(verdict)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>All other branches are similar, they do some check and push a constant string or <code>nil</code> back to the stack.</p><h3 id=range-literals>Range literals</h3><p>For static ranges (like <code>(1..2)</code>) Ruby uses inlining and a well-known <code>putobject</code> instruction. But what if it&rsquo;s dynamic? Like <code>(a..b)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;a = 3; b = 4; p (a..b); p (a...b)&#39;</span>)<span style=color:#f92672>.</span>to_a<span style=color:#f92672>[</span><span style=color:#ae81ff>13</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putobject</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:setlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newrange</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:p</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:pop</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:newrange</span>, <span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:p</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>There&rsquo;s a special <code>newrange</code> instruction that takes a flag as an argument to specify inclusion of the right side (i.e. to distinguish <code>..</code> vs <code>...</code>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_newrange</span>(flag)
</span></span><span style=display:flex><span>  high <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  low <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>  push(<span style=color:#66d9ef>Range</span><span style=color:#f92672>.</span>new(low, high, flag <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=long-jumps>Long jumps</h3><p>This is probably the most complicated part. What if you have a method that has a loop inside a loop that does <code>return</code>? You want to stop executing both loops and simply exit the method, right?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2</span><span style=color:#f92672>.</span>times <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>i<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>3</span><span style=color:#f92672>.</span>times <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>j<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#f92672>[</span>i,j<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>m
</span></span></code></pre></div><p>Of course you can just find the closest frame that supports <code>return</code> (i.e. a <code>MethodFrame</code>), but you also need to stop execution of two running methods and blocks. In our case it&rsquo;s even more complicated because we don&rsquo;t control them (they are written in C).</p><p>The only way I was able to find is to throw an exception. An exception destroys all frames (including YARV&rsquo;s C frames) until it finds someone who can catch and handle it. If there&rsquo;s no such frame the programs exits with an error.</p><p>Let&rsquo;s create a special exception class called <code>VM::LongJumpError</code>. Each frame class has to know what it can handle (for example, you can do <code>break</code> in a block, but not in a method; <code>return</code> is normally supported only by methods and lambdas, etc):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LongJumpError</span>  <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>InternalError</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:value</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(value)
</span></span><span style=display:flex><span>    @value <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>do_jump!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>InternalError</span>, <span style=color:#e6db74>&#39;Not implemented&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>message</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span>self<span style=color:#f92672>.</span>class<span style=color:#e6db74>}</span><span style=color:#e6db74>(</span><span style=color:#e6db74>#{</span>@value<span style=color:#f92672>.</span>inspect<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReturnError</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>LongJumpError</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>do_jump!</span>
</span></span><span style=display:flex><span>    frame <span style=color:#f92672>=</span> current_frame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> frame<span style=color:#f92672>.</span>can_return?
</span></span><span style=display:flex><span>      <span style=color:#75715e># swallow and consume</span>
</span></span><span style=display:flex><span>      frame<span style=color:#f92672>.</span>returning <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      pop_frame(<span style=color:#e6db74>reason</span>: <span style=color:#e6db74>&#34;longjmp (return) </span><span style=color:#e6db74>#{</span>self<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> self
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Each <code>longjmp</code> exception wraps the value that it &ldquo;returns&rdquo; with (or &ldquo;breaks&rdquo; with, for <code>break</code> we need a separate class, but I&rsquo;m going to skip it here. <code>break</code>/<code>next</code> and other friends are really similar to <code>return</code>).</p><p>But we need to catch them, right? Without a <code>rescue</code> handler we will have something conceptually similar to segfault:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute</span>(iseq, <span style=color:#f92672>**</span>payload)
</span></span><span style=display:flex><span>  iseq <span style=color:#f92672>=</span> <span style=color:#66d9ef>ISeq</span><span style=color:#f92672>.</span>new(iseq)
</span></span><span style=display:flex><span>  push_frame(iseq, <span style=color:#f92672>**</span>payload)
</span></span><span style=display:flex><span>  <span style=color:#75715e># here comes the difference:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># we wrap executing instructions into a rescue handler</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    evaluate_last_frame
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>rescue</span> <span style=color:#66d9ef>LongJumpError</span> <span style=color:#f92672>=&gt;</span> e
</span></span><span style=display:flex><span>    e<span style=color:#f92672>.</span>do_jump!
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  pop_frame
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The only missing thing is the implementation of <code>can_return?</code> method in our frames. All frames except <code>MethodFrame</code> (and <code>BlockFrame</code> it it&rsquo;s marked as <code>lambda</code>) must return <code>false</code>, <code>MethodFrame</code> must return <code>true</code>.</p><p>MRI uses a special instruction called <code>throw</code> that has a single argument that is a <code>throw_type</code> (an <code>enum</code>, for <code>return</code> it&rsquo;s 1, <code>break</code> is 3, <code>next</code> is 4, there are also <code>retry</code>/<code>redo</code> and a few more). The value that must be attached to the thrown exception comes from the stack (so this instruction does a single <code>pop</code>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>VM_THROW_STATE_MASK</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xff</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_NONE</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_RETURN</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_BREAK</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_NEXT</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x3</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_RETRY</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_REDO</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_RAISE</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x6</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_THROW</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x7</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_FATAL</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x8</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUBY_TAG_MASK</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xf</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_throw</span>(throw_type)
</span></span><span style=display:flex><span>  throw_type <span style=color:#f92672>=</span> throw_type <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>VM_THROW_STATE_MASK</span>
</span></span><span style=display:flex><span>  throw_obj <span style=color:#f92672>=</span> pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> throw_type
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>RUBY_TAG_RETURN</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>VM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>ReturnError</span>, throw_obj
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>RUBY_TAG_BREAK</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>VM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>BreakError</span>, throw_obj
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>RUBY_TAG_NEXT</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#66d9ef>VM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>NextError</span>, throw_obj
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=longjmp-in-mri><code>longjmp</code> in MRI</h3><p>But does it work in the same way in MRI? C does not have exceptions. And at the same time there is a bunch of places where MRI does something like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> ARY_MAX_SIZE) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rb_raise</span>(rb_eArgError, <span style=color:#e6db74>&#34;array size too big&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// handle validated data
</span></span></span></code></pre></div><p>This <code>rb_raise</code> somehow exits a C function. Well, here&rsquo;s the trick: non-local <code>goto</code>.</p><p>There are C calls that perform a <code>goto</code> to any place (that was previously marked of course, similar to jump to labels for a local <code>goto</code>):</p><ul><li><a href=https://linux.die.net/man/3/sigsetjmp target=_blank rel="noreferrer nofollow"><code>setjmp</code></a></li><li><a href=https://linux.die.net/man/3/longjmp target=_blank rel="noreferrer nofollow"><code>longjmp</code></a></li></ul><blockquote><p><code>setjmp()</code> saves the stack context/environment in <code>env</code> for later use by <code>longjmp</code></p></blockquote><p>&mldr; also known as &ldquo;context switch&rdquo;. And it&rsquo;s relatively expensive.</p><p>Even if you don&rsquo;t <code>raise</code> an exception and only do <code>begin; ...; rescue; end</code> in your code you still have to save the context (to jump to it once you <code>raise</code> an error). MRI does not know at compile time which methods can throw an error (and do you throw them at all), so each <code>rescue</code> produces a <code>setjmp</code> call (and each <code>raise</code> triggers a <code>longjmp</code> and passes <code>closest rescue</code> -> <code>saved env</code> as an argument)</p><h3 id=rescueensure><code>rescue</code>/<code>ensure</code></h3><p>So now we know that raise/rescue works via long jumps under the hood. Let&rsquo;s implement our own exceptions.</p><p>By sticking to MRI exceptions we can unwrap both internal and our stacks at the same time. I&rsquo;m not going to override <code>raise</code>, it should do what it originally does, but we still need to support our own <code>rescue</code> blocks. Let&rsquo;s see what MRI gives us:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> pp <span style=color:#66d9ef>RubyVM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InstructionSequence</span><span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;begin; p &#34;x&#34;; rescue A; p &#34;y&#34;; end&#39;</span>)<span style=color:#f92672>.</span>to_a
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> <span style=color:#75715e># ...snip</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>[[</span><span style=color:#e6db74>:rescue</span>,
</span></span><span style=display:flex><span>   <span style=color:#f92672>[</span> <span style=color:#75715e># ...snip</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;rescue in &lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&lt;compiled&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:rescue</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#e6db74>:&#34;</span><span style=color:#ae81ff>\#</span><span style=color:#e6db74>$!&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    {},
</span></span><span style=display:flex><span>    <span style=color:#f92672>[]</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:putnil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:getconstant</span>, <span style=color:#e6db74>:A</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:checkmatch</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:branchif</span>, <span style=color:#e6db74>:label_11</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:jump</span>, <span style=color:#e6db74>:label_19</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#e6db74>:label_11</span>,
</span></span><span style=display:flex><span>     <span style=color:#e6db74>:RUBY_EVENT_LINE</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:putstring</span>, <span style=color:#e6db74>&#34;y&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:p</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#e6db74>:label_19</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:getlocal_WC_0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#e6db74>:throw</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]]]</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>:label_0</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>:label_7</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>:label_8</span>,
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:retry</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#e6db74>:label_7</span>, <span style=color:#e6db74>:label_8</span>, <span style=color:#e6db74>:label_0</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>]]</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>[</span><span style=color:#e6db74>:label_0</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:RUBY_EVENT_LINE</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:putself</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:putstring</span>, <span style=color:#e6db74>&#34;x&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:send</span>, {<span style=color:#e6db74>:mid</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>:p</span>, <span style=color:#e6db74>:flag</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>:orig_argc</span><span style=color:#f92672>=&gt;</span><span style=color:#ae81ff>1</span>}, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:label_7</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:nop</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:label_8</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]]]</span>
</span></span></code></pre></div><p>An instruction sequence that has some <code>rescue</code> blocks inside includes all information about them (in the element #12, right above an instructions list). Each rescue handler is a frame with its own list of variables and instructions. Its <code>kind</code> is <code>:rescue</code> and is has at least one local variable: <code>$!</code>. It starts with a dollar sign, but it&rsquo;s a local variable. According to its semantics it has to be a local variable, but unfortunately it can&rsquo;t look like a local variable (because it&rsquo;d would potentially conflict with method calls). I mean, that&rsquo;s how I explain it to myself, I don&rsquo;t know for sure what was the initial reason to design it this way.</p><p>It also has a few labels at the bottom - <code>:label_7, :label_8, :label_0</code>:</p><ul><li>the first label is a &ldquo;begin&rdquo; label. It marks where the (potentially) critical section of your code begins</li><li>the second label is an &ldquo;end&rdquo; label</li><li>the third label is an &ldquo;exit&rdquo; label. It marks where we should jump to if the error has been caught and handled.</li></ul><p>A top-level instruction also contains these labels, and the meaning of them is:</p><ul><li>if we evaluate instructions and we see a label that is a &ldquo;begin&rdquo; label of some rescue handler we <strong>enable</strong> the handler</li><li>if we see a label that is an &ldquo;end&rdquo; of some rescue handler we <strong>disable</strong> it</li><li>if we execute a single instruction and catch an exception we:<ul><li>iterate over all <strong>enabled</strong> rescue handlers</li><li>and for each of them we push a <code>RescueFrame</code> with a rescue iseq</li><li>and we set a <code>$!</code> variable in this frame to the error that we have just caught</li><li>the rescue frame decides where to go next:<ul><li>back to the original frame via <code>jump</code> to the &ldquo;exit&rdquo; label after doing <code>pop_frame</code></li><li>or somewhere else via re-raise (if the iseq contains it)</li></ul></li></ul></li></ul><p>Let&rsquo;s code it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ISeq</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:rescue_handlers</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:ensure_handlers</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(ruby_iseq)
</span></span><span style=display:flex><span>    @ruby_iseq <span style=color:#f92672>=</span> ruby_iseq
</span></span><span style=display:flex><span>    reset!
</span></span><span style=display:flex><span>    setup_rescue_handlers!
</span></span><span style=display:flex><span>    setup_ensure_handlers!
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ... other existing methods on ISeq class</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup_rescue_handlers!</span>
</span></span><span style=display:flex><span>    @rescue_handler <span style=color:#f92672>=</span> @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>12</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>select { <span style=color:#f92672>|</span>handler<span style=color:#f92672>|</span> handler<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>:rescue</span> }
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>map { <span style=color:#f92672>|</span>(_, iseq, begin_label, end_label, exit_label)<span style=color:#f92672>|</span> <span style=color:#66d9ef>Handler</span><span style=color:#f92672>.</span>new(iseq, begin_label, end_label, exit_label) }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup_ensure_handlers!</span>
</span></span><span style=display:flex><span>    @ensure_handler <span style=color:#f92672>=</span> @ruby_iseq<span style=color:#f92672>[</span><span style=color:#ae81ff>12</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>select { <span style=color:#f92672>|</span>handler<span style=color:#f92672>|</span> handler<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>:ensure</span> }
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>map { <span style=color:#f92672>|</span>(_, iseq, begin_label, end_label, exit_label)<span style=color:#f92672>|</span> <span style=color:#66d9ef>Handler</span><span style=color:#f92672>.</span>new(iseq, begin_label, end_label, exit_label) }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Handler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:iseq</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:begin_label</span>, <span style=color:#e6db74>:end_label</span>, <span style=color:#e6db74>:exit_label</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(iseq, begin_label, end_label, exit_label)
</span></span><span style=display:flex><span>      @iseq <span style=color:#f92672>=</span> iseq
</span></span><span style=display:flex><span>      @begin_label, @end_label, @exit_label <span style=color:#f92672>=</span> begin_label, end_label, exit_label
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>So now each <code>iseq</code> object has two getters:</p><ul><li><code>rescue_handlers</code></li><li><code>ensure_handlers</code></li></ul><p>Frames must know which handlers are active (but not instruction sequences, because methods can recursively call themselves and so the same iseq will be reused; it&rsquo;s a per-frame property):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FrameClass</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>self</span><span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Struct</span><span style=color:#f92672>.</span>new {
</span></span><span style=display:flex><span>      <span style=color:#75715e># Both must be set to `Set.new` in the constructor</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>attr_accessor</span> <span style=color:#e6db74>:enabled_rescue_handlers</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>attr_accessor</span> <span style=color:#e6db74>:enabled_ensure_handlers</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>So this way all frames have it too. Every time when we see a label in our execution loop we need to check if it matches any <code>begin_label</code> or <code>end_label</code> of our <code>current_frame.iseq.rescue_handlers</code> (or <code>ensure_handlers</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>on_label</span>(label)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    current_iseq<span style=color:#f92672>.</span>rescue_handlers <span style=color:#f92672>=&gt;</span> current_frame<span style=color:#f92672>.</span>enabled_rescue_handlers,
</span></span><span style=display:flex><span>    current_iseq<span style=color:#f92672>.</span>ensure_handlers <span style=color:#f92672>=&gt;</span> current_frame<span style=color:#f92672>.</span>enabled_ensure_handlers,
</span></span><span style=display:flex><span>  }<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>all_handlers, enabled_handlers<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>    all_handlers
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>select { <span style=color:#f92672>|</span>handler<span style=color:#f92672>|</span> handler<span style=color:#f92672>.</span>begin_label <span style=color:#f92672>==</span> label }
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>each { <span style=color:#f92672>|</span>handler<span style=color:#f92672>|</span> enabled_handlers <span style=color:#f92672>&lt;&lt;</span> handler }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    all_handlers
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>select { <span style=color:#f92672>|</span>handler<span style=color:#f92672>|</span> handler<span style=color:#f92672>.</span>end_label <span style=color:#f92672>==</span> label }
</span></span><span style=display:flex><span>      <span style=color:#f92672>.</span>each { <span style=color:#f92672>|</span>handler<span style=color:#f92672>|</span> enabled_handlers<span style=color:#f92672>.</span>delete(handler) }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>side note: when we do a local <code>jump</code> we should also walk through skipped instructions and enable/disable our handlers; this is important</p><p>OK, now the only missing part is the reworked execution loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># a generic runner that is used inside the loop</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_insn</span>(insn)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> insn
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#f92672>[</span><span style=color:#e6db74>:leave</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    current_frame<span style=color:#f92672>.</span>returning <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> Array
</span></span><span style=display:flex><span>    name, <span style=color:#f92672>*</span>payload <span style=color:#f92672>=</span> insn
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    with_error_handling <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      send(<span style=color:#e6db74>:&#34;execute_</span><span style=color:#e6db74>#{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, payload)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># -- new branch for labels --</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> <span style=color:#66d9ef>Regexp</span><span style=color:#f92672>.</span>new(<span style=color:#e6db74>&#34;label_</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>d+&#34;</span>)
</span></span><span style=display:flex><span>    on_label(insn)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># ignore</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># a wrapper that catches and handles error</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>with_error_handling</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>yield</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>rescue</span> <span style=color:#66d9ef>VM</span><span style=color:#f92672>::</span><span style=color:#66d9ef>InternalError</span> <span style=color:#f92672>=&gt;</span> e
</span></span><span style=display:flex><span>  <span style=color:#75715e># internal errors like LongJumpError should be invisible for users</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>rescue</span> <span style=color:#66d9ef>Exception</span> <span style=color:#f92672>=&gt;</span> e
</span></span><span style=display:flex><span>  handle_error(e)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>handle_error</span>(error)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (rescue_handler <span style=color:#f92672>=</span> current_frame<span style=color:#f92672>.</span>enabled_rescue_handler<span style=color:#f92672>.</span>first)
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> execute(rescue_handler<span style=color:#f92672>.</span>iseq, <span style=color:#e6db74>caught</span>: error, <span style=color:#e6db74>exit_to</span>: rescue_handler<span style=color:#f92672>.</span>exit_label)
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>.</span>push(result)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> error
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># This guy also needs customization to support `jump(exit_label)`</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pop_frame</span>
</span></span><span style=display:flex><span>  frame <span style=color:#f92672>=</span> @frame_stack<span style=color:#f92672>.</span>pop
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> frame<span style=color:#f92672>.</span>is_a?(<span style=color:#66d9ef>RescueFrame</span>)
</span></span><span style=display:flex><span>    jump(frame<span style=color:#f92672>.</span>exit_to)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  frame<span style=color:#f92672>.</span>returning
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># And here&#39;s the rescue frame implementation</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RescueFrame</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>FrameClass</span><span style=color:#f92672>.</span>new <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>attr_reader</span> <span style=color:#e6db74>:parent_frame</span>, <span style=color:#e6db74>:caught</span>, <span style=color:#e6db74>:exit_to</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize</span>(<span style=color:#e6db74>parent_frame</span>:, <span style=color:#e6db74>caught</span>:, <span style=color:#e6db74>exit_to</span>:)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_self <span style=color:#f92672>=</span> parent_frame<span style=color:#f92672>.</span>_self
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>nesting <span style=color:#f92672>=</span> parent_frame<span style=color:#f92672>.</span>nesting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @parent_frame <span style=color:#f92672>=</span> parent_frame
</span></span><span style=display:flex><span>    @caught <span style=color:#f92672>=</span> caught
</span></span><span style=display:flex><span>    @exit_to <span style=color:#f92672>=</span> exit_to
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># $! always has an ID = 3</span>
</span></span><span style=display:flex><span>    locals<span style=color:#f92672>.</span>declare(id: <span style=color:#ae81ff>3</span>, name: <span style=color:#e6db74>:&#34;</span><span style=color:#ae81ff>\#</span><span style=color:#e6db74>$!&#34;</span>)
</span></span><span style=display:flex><span>    locals<span style=color:#f92672>.</span>find(id: <span style=color:#ae81ff>3</span>)<span style=color:#f92672>.</span>set(caught)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>But why do we handle only the first handler? Can there be multiple handlers? The answer is no, because:</p><ul><li>MRI merges multiple consecutive <code>rescue</code> handlers (by using <code>case error</code> branching in a rescue body)</li><li><code>rescue</code> itself is frame, and so nested <code>rescue</code> is a rescue handler of the rescue handler</li></ul><h3 id=throwcatch-methods><code>throw</code>/<code>catch</code> methods</h3><p>As a side (and I personally think a very interesting) note, while I was working on this project I have realized that specs for <code>Kernel#throw</code> are not working for me at all. They were literally completely broken (even after I finished working on a very basic implementation of exceptions):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>catch</span>(<span style=color:#e6db74>:x</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>:x</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>rescue</span> <span style=color:#66d9ef>Exception</span> <span style=color:#f92672>=&gt;</span> e
</span></span><span style=display:flex><span>    puts e
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This code does not print anything. However, if you do just <code>throw :x</code> you get an exception:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>:x</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Traceback</span> (most recent call last):
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2</span>: from (irb):<span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>: from (irb):<span style=color:#ae81ff>14</span><span style=color:#e6db74>:in</span> <span style=color:#e6db74>`throw&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>UncaughtThrowError (uncaught throw :x)
</span></span></span></code></pre></div><p>Huh, what&rsquo;s going on? Let&rsquo;s take a look at the implementation of <code>Kernel#throw</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rb_throw_obj</span>(VALUE tag, VALUE value)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>rb_execution_context_t</span> <span style=color:#f92672>*</span>ec <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_EC</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rb_vm_tag <span style=color:#f92672>*</span>tt <span style=color:#f92672>=</span> ec<span style=color:#f92672>-&gt;</span>tag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (tt) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (tt<span style=color:#f92672>-&gt;</span>tag <span style=color:#f92672>==</span> tag) {
</span></span><span style=display:flex><span>          tt<span style=color:#f92672>-&gt;</span>retval <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      tt <span style=color:#f92672>=</span> tt<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tt) {
</span></span><span style=display:flex><span>      VALUE desc[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>      desc[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> tag;
</span></span><span style=display:flex><span>      desc[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>      desc[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>rb_str_new_cstr</span>(<span style=color:#e6db74>&#34;uncaught throw %p&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>rb_exc_raise</span>(<span style=color:#a6e22e>rb_class_new_instance</span>(<span style=color:#a6e22e>numberof</span>(desc), desc, rb_eUncaughtThrow));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ec<span style=color:#f92672>-&gt;</span>errinfo <span style=color:#f92672>=</span> (VALUE)<span style=color:#a6e22e>THROW_DATA_NEW</span>(tag, NULL, TAG_THROW);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>EC_JUMP_TAG</span>(ec, TAG_THROW);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code raises an instance of <code>rb_eUncaughtThrow</code> only in one case: if there&rsquo;s no frame above that may &ldquo;catch&rdquo; it (like in the case when we did just <code>throw :x</code>).</p><p>However if there&rsquo;s a frame somewhere above that has the same tag MRI performs a manual <code>longjmp</code>. This is why we can&rsquo;t catch this exception. There&rsquo;s simply no exception if there&rsquo;s a <code>catch(:x)</code> above (but there would be an exception if we would do <code>catch(:y) { throw :x }</code>).</p><p>Is it faster? Let&rsquo;s see</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;benchmark/ips&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Benchmark</span><span style=color:#f92672>.</span>ips <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>x<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  x<span style=color:#f92672>.</span>config(<span style=color:#e6db74>:time</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  x<span style=color:#f92672>.</span>report(<span style=color:#e6db74>&#39;raise&#39;</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#e6db74>&#39;x&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>rescue</span> <span style=color:#f92672>=&gt;</span> e
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  x<span style=color:#f92672>.</span>report(<span style=color:#e6db74>&#39;throw&#39;</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span>(<span style=color:#e6db74>:x</span>) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>:x</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  x<span style=color:#f92672>.</span>compare!
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> ruby benchmark<span style=color:#f92672>.</span>rb
</span></span><span style=display:flex><span><span style=color:#66d9ef>Warming</span> up <span style=color:#f92672>--------------------------------------</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>raise</span>   <span style=color:#ae81ff>101</span><span style=color:#f92672>.</span><span style=color:#ae81ff>832</span>k i<span style=color:#f92672>/</span><span style=color:#ae81ff>100</span>ms
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>throw</span>   <span style=color:#ae81ff>256</span><span style=color:#f92672>.</span><span style=color:#ae81ff>893</span>k i<span style=color:#f92672>/</span><span style=color:#ae81ff>100</span>ms
</span></span><span style=display:flex><span><span style=color:#66d9ef>Calculating</span> <span style=color:#f92672>-------------------------------------</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>raise</span>      <span style=color:#ae81ff>1</span><span style=color:#f92672>.</span><span style=color:#ae81ff>310</span>M (<span style=color:#960050;background-color:#1e0010></span> <span style=color:#ae81ff>4</span><span style=color:#f92672>.</span><span style=color:#ae81ff>2</span><span style=color:#e6db74>%) i/s -      3.971M in   3.037942s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>               throw      4.853M ( 3.0%)</span> i<span style=color:#f92672>/</span>s <span style=color:#f92672>-</span>     <span style=color:#ae81ff>14</span><span style=color:#f92672>.</span><span style=color:#ae81ff>643</span>M <span style=color:#66d9ef>in</span>   <span style=color:#ae81ff>3</span><span style=color:#f92672>.</span><span style=color:#ae81ff>020227</span>s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>Comparison</span>:
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>throw</span>:  <span style=color:#ae81ff>4852821</span><span style=color:#f92672>.</span><span style=color:#ae81ff>4</span> i<span style=color:#f92672>/</span>s
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>raise</span>:  <span style=color:#ae81ff>1309915</span><span style=color:#f92672>.</span><span style=color:#ae81ff>6</span> i<span style=color:#f92672>/</span>s <span style=color:#f92672>-</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>.</span><span style=color:#ae81ff>70</span>x  slower
</span></span></code></pre></div><p>As expected, it&rsquo;s faster. But what&rsquo;s more important, let&rsquo;s see what if there are more frames between <code>raise/rescue</code> and <code>throw/catch</code>. First, let&rsquo;s create a small method that wraps given code into N frames:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>in_n_frames</span>(depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, n, blk)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>==</span> n
</span></span><span style=display:flex><span>    blk<span style=color:#f92672>.</span>call
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    in_n_frames(depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n, blk)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>  in_n_frames(<span style=color:#ae81ff>1000</span>, proc { <span style=color:#66d9ef>raise</span> <span style=color:#e6db74>&#39;err&#39;</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>rescue</span> <span style=color:#f92672>=&gt;</span> e
</span></span><span style=display:flex><span>  p e<span style=color:#f92672>.</span>backtrace<span style=color:#f92672>.</span>length
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>It prints <code>1003</code>, because there&rsquo;s also a <code>TopFrame</code> and a <code>BlockFrame</code> (and a small bug that does +1), but that&rsquo;s absolutely fine for us.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> ruby benchmark<span style=color:#f92672>.</span>rb
</span></span><span style=display:flex><span><span style=color:#66d9ef>Warming</span> up <span style=color:#f92672>--------------------------------------</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>raise</span>     <span style=color:#ae81ff>1</span><span style=color:#f92672>.</span><span style=color:#ae81ff>061</span>k i<span style=color:#f92672>/</span><span style=color:#ae81ff>100</span>ms
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>throw</span>     <span style=color:#ae81ff>1</span><span style=color:#f92672>.</span><span style=color:#ae81ff>115</span>k i<span style=color:#f92672>/</span><span style=color:#ae81ff>100</span>ms
</span></span><span style=display:flex><span><span style=color:#66d9ef>Calculating</span> <span style=color:#f92672>-------------------------------------</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>raise</span>     <span style=color:#ae81ff>10</span><span style=color:#f92672>.</span><span style=color:#ae81ff>628</span>k (<span style=color:#960050;background-color:#1e0010></span> <span style=color:#ae81ff>1</span><span style=color:#f92672>.</span><span style=color:#ae81ff>3</span><span style=color:#e6db74>%) i/s -     32.891k in   3.095347s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>               throw     11.183k ( 1.5%)</span> i<span style=color:#f92672>/</span>s <span style=color:#f92672>-</span>     <span style=color:#ae81ff>34</span><span style=color:#f92672>.</span><span style=color:#ae81ff>565</span>k <span style=color:#66d9ef>in</span>   <span style=color:#ae81ff>3</span><span style=color:#f92672>.</span><span style=color:#ae81ff>091514</span>s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>Comparison</span>:
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>throw</span>:    <span style=color:#ae81ff>11183</span><span style=color:#f92672>.</span><span style=color:#ae81ff>1</span> i<span style=color:#f92672>/</span>s
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>raise</span>:    <span style=color:#ae81ff>10627</span><span style=color:#f92672>.</span><span style=color:#ae81ff>8</span> i<span style=color:#f92672>/</span>s <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>.</span><span style=color:#ae81ff>05</span>x  slower
</span></span></code></pre></div><p>There&rsquo;s almost no difference! The reason is simple: the only thing that is different is creation of the exception object. <code>throw</code> does not do it.</p><h3 id=utility-instructions>Utility instructions</h3><p>There are also a few interesting instructions that MRI uses to evaluate your complex code:</p><ul><li><code>adjuststack(n)</code> - does <code>n.times { pop }</code></li><li><code>nop</code> - literally does nothing</li><li><code>dupn(n)</code> - does <code>pop</code> N times and then pushes them twice (or basically duplicates N last items)</li><li><code>setn(n)</code> - does <code>stack[-n-1] = stack.top</code></li><li><code>topn(n)</code> - does <code>push(stack[-n-1])</code></li><li><code>swap</code> - swaps top two stack elements</li><li><code>dup</code> - like <code>dupn(1)</code></li><li><code>reverse(n)</code> - reverses N stack elements (i.e. does <code>n.times.map { pop }.each { |value| push(value) }</code>)</li></ul><h2 id=final-words>Final words</h2><p>First of all, I&rsquo;d like to say thank you to everyone who made YARV. I was not able to find a single place where MRI behaves inefficiently (and I spent many hours looking into instructions).</p><p>Once again, the code is available <a href=https://github.com/iliabylich/my.rb target=_blank rel="noreferrer nofollow">here</a>
, feel free to create issues/message me in Twitter. And please, don&rsquo;t use it in the real world.</p></main><br><footer><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=e.textContent;navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script></footer></body></html>