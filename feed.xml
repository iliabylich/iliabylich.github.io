<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://iliabylich.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://iliabylich.github.io/" rel="alternate" type="text/html" /><updated>2022-04-03T18:19:40+00:00</updated><id>https://iliabylich.github.io/feed.xml</id><title type="html">Ilya Bylich</title><subtitle>I&apos;m a Ruby/Rust developer, sometimes I write long technical stories</subtitle><entry><title type="html">Writing bindings upside down</title><link href="https://iliabylich.github.io/2021/12/27/writing-bindings-upside-down.html" rel="alternate" type="text/html" title="Writing bindings upside down" /><published>2021-12-27T21:00:00+00:00</published><updated>2021-12-27T21:00:00+00:00</updated><id>https://iliabylich.github.io/2021/12/27/writing-bindings-upside-down</id><content type="html" xml:base="https://iliabylich.github.io/2021/12/27/writing-bindings-upside-down.html"><![CDATA[<p>Quite a long time ago I started writing C/C++/Ruby/Node.JS/WASM bindings so I could call <a href="https://github.com/lib-ruby-parser/lib-ruby-parser">my Rust project</a> from those languages. It is a Ruby language parser.</p>

<p>I tried multiple ways and found one that is very (VERY) controversial, but I think it deserves it’s own article.</p>

<h2 id="traditional-way">Traditional way</h2>

<p>Let’s say you have a library in C. Just for simplicity, Rust is not special here.</p>

<p><img src="https://raw.githubusercontent.com/iliabylich/writing-bindings-upside-down/master/images/library-puzzle-piece.png" alt="library-puzzle-piece.png" /></p>

<p>How can you use it in C++? A very simple solution is to wrap your header file with</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
<span class="cp">#endif
</span>
<span class="c1">// C bindings</span>

<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>then change your includes to be slightly more compatible with C++ (<code class="language-plaintext highlighter-rouge">stdio.h</code> -&gt; <code class="language-plaintext highlighter-rouge">cstdio</code> etc) and call it a day.</p>

<ul>
  <li>Pros: very simple.</li>
  <li>Cons: your API has raw pointers, raw array/string structures that expose everything and are error-prone when used.</li>
</ul>

<p>How can you use it in Ruby/Node.JS? Again, let’s start with “traditional” solution. For Ruby take your C library, for Node.JS take C++ library and “wrap” it using a “native” extension.</p>

<p>It is possible to “attach” any arbitrary data to Ruby/Node.JS objects</p>
<ul>
  <li>Ruby has <a href="https://docs.ruby-lang.org/en/2.4.0/extension_rdoc.html#label-C+struct+to+Ruby+object"><code class="language-plaintext highlighter-rouge">TypedData_Wrap_Struct</code> function</a></li>
  <li>Node.JS has <a href="https://github.com/nodejs/node-addon-api/blob/main/doc/external.md"><code class="language-plaintext highlighter-rouge">Napi::External</code></a></li>
</ul>

<p>In both cases it’s possible to get pointer to attached data at any moment, both require you to specify a function that GC calls to free attached data.</p>

<p>Pros: still quite simple.
Cons: really error-prone, libraries designed this way quite frequently have memory leaks and segfaults.</p>

<p><img src="https://raw.githubusercontent.com/iliabylich/writing-bindings-upside-down/master/images/traditional-bindings.png" alt="traditional-bindings.png" /></p>

<h2 id="slow-but-more-reliable-solution">Slow but more reliable solution</h2>

<p>Of course it’d be unfair to not mention that it’s always possible to type-cast structures from low-level language to high-level:</p>

<ol>
  <li>C -&gt; C++ - by converting C structs to pretty C++ classes with smart pointers and collections</li>
  <li>C -&gt; Ruby - by creating Ruby objects from C structs</li>
  <li>C++ -&gt; Node.JS - by creating JavaScript objects from C++ classes</li>
</ol>

<ul>
  <li>Pros: this way it’s actually less dangerous. You can cover it with unit-tests and check with ASAN/Valgrind/LSAN that you have no segfaults, memory leaks or incorrect memory access.</li>
  <li>Cons: you have to copy a bunch of data and it will hurt performance. Many of your methods have to be rewritten to target language OR you have convert C++/Ruby/JS objects back to C to call original C functions.</li>
</ul>

<p>A small note on copying: it is possible to “move” some data in certain cases and languages:</p>

<ul>
  <li>Ruby has a family of <code class="language-plaintext highlighter-rouge">rb_str_new_*</code> functions, but literally all of them take <code class="language-plaintext highlighter-rouge">const char *ptr, size_t len</code>, however, it’s possible to create a “dummy” heap-allocated Ruby <code class="language-plaintext highlighter-rouge">String</code> and set <code class="language-plaintext highlighter-rouge">ptr</code> and <code class="language-plaintext highlighter-rouge">len</code> on it. It is possible only (and only) because internals of all Ruby objects (including <code class="language-plaintext highlighter-rouge">String</code>) are fully exposed on C layer.</li>
  <li>Node.JS has a <a href="https://github.com/nodejs/node-addon-api/blob/main/doc/string.md"><code class="language-plaintext highlighter-rouge">Napi::String</code></a> class for that but it takes either a C++ <code class="language-plaintext highlighter-rouge">const std::string&amp;</code> or <code class="language-plaintext highlighter-rouge">const char *</code>. From what I know internals are not available, so copying is necessary.</li>
  <li>C++ has a <code class="language-plaintext highlighter-rouge">std::string</code> that doesn’t have a “take-and-store-what’s-given” constructor that takes a <code class="language-plaintext highlighter-rouge">char *</code> (I would call it a “move” constructor, but this name has a different meaning in C++ :D). There’s a <code class="language-plaintext highlighter-rouge">const char *</code> constructor that performs copying. Of course it’s possible to create a compiler-dependent type-casting to a class with the same set of fields, move pointer + len + capacity there and convert it back to <code class="language-plaintext highlighter-rouge">std::string</code>. It’s ugly, but definitely doable.</li>
</ul>

<h2 id="a-demo-small-but-representative">A demo, small but representative</h2>

<p>Let’s start. I’d like to demonstrate a different solution on a tiny example. Let’s write a micro-library that has several Rust structs, something like a function that, let’s say, takes a <code class="language-plaintext highlighter-rouge">String</code> and returns a <code class="language-plaintext highlighter-rouge">Vec</code> of all non-ascii chars. It’s called <code class="language-plaintext highlighter-rouge">foo</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pub fn foo(s: &amp;str) -&gt; Vec&lt;char&gt; {
    s.chars().filter(|c| !c.is_ascii()).collect()
}

#[test]
fn test_foo() {
    let chars = foo("abc😋中国def");
    assert_eq!(chars, vec!['😋', '中', '国']);
}
</code></pre></div></div>

<p>There are two structs that belong to Rust world exclusively: <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">char</code>.</p>

<h2 id="foreign-implementation">“Foreign” implementation</h2>

<p>Can we expose these two types in C? <code class="language-plaintext highlighter-rouge">Vec</code> is defined in Rust standard library and it has <code class="language-plaintext highlighter-rouge">#[repr(Rust)]</code>, <code class="language-plaintext highlighter-rouge">char</code> is a 4-byte structure with no public layout.</p>

<p>We could define our own <code class="language-plaintext highlighter-rouge">repr(C)</code> structs together with <code class="language-plaintext highlighter-rouge">impl From&lt;RustType&gt; for CType</code> and call <code class="language-plaintext highlighter-rouge">.into()</code>, but that’s not really the goal here.</p>

<p>Let’s think for a moment about C++, Ruby and Node:</p>

<ul>
  <li>In C++ I’d really like to use <code class="language-plaintext highlighter-rouge">std::vector</code> for <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">std::string</code> for <code class="language-plaintext highlighter-rouge">char</code>.</li>
  <li>For both Ruby and Node.JS I want <code class="language-plaintext highlighter-rouge">Array</code> for <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">String</code> for <code class="language-plaintext highlighter-rouge">char</code>.</li>
</ul>

<p>What if our library could depend on some contract that requires bindings to provide primitives? The contract will be the same for all bindings, but implementation will be different.</p>

<p>Rust doesn’t know what is C++ <code class="language-plaintext highlighter-rouge">std::vector</code> or Ruby <code class="language-plaintext highlighter-rouge">String</code>, but we know it, our bindings know it and by providing a set of foreign utility functions (implemented on the bindings side) we could work with it just like with native <code class="language-plaintext highlighter-rouge">std::Vec&lt;T&gt;</code>.</p>

<p><img src="https://raw.githubusercontent.com/iliabylich/writing-bindings-upside-down/master/images/library-with-external-primitives.png?v1" alt="library-with-external-primitives.png" /></p>

<p>Here “Primitives” will be:</p>

<ul>
  <li>Rust structures for Rust version of the library</li>
  <li>C structs for C version</li>
  <li>C++ classes for C++ version</li>
  <li>Ruby classes for Ruby version</li>
</ul>

<p>“Functions to work with primitives” will be a set of <code class="language-plaintext highlighter-rouge">extern "C"</code> functions that take and return these “foreign” objects. Rust can call them without any knowledge of these objects.</p>

<p>By swapping implementations at link time we can get the same algorithm that works with a different set of structures from different languages. “Link-time polymorphism” seems to be a good name for this concept.</p>

<h2 id="example">Example</h2>

<p>I think it makes sense to start with C, this is what I would like to get eventually:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef STRUCTS_H
#define STRUCTS_H

#include &lt;stddef.h&gt;
#include &lt;stdbool.h&gt;

typedef struct Char
{
    char bytes[4];
} Char;

typedef struct CharList
{
    Char *ptr;
    size_t len;
} CharList;

#endif // STRUCTS_H
</code></pre></div></div>

<p>Now the question is: how can we return this <code class="language-plaintext highlighter-rouge">CharList</code> from our Rust code? We could use bindgen and something-something. No, no and no.</p>

<p>Instead, let’s make Rust think that <code class="language-plaintext highlighter-rouge">CharList</code> on its side is some struct of some (AOT-known) size without any meaningful fields. To do that we need to dump sizes of our structs and make them available in C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include "structs.h"

int main()
{
    printf("CHAR_SIZE=%lu\n", sizeof(Char));
    printf("CHAR_LIST_SIZE=%lu\n", sizeof(CharList));

    return 0;
}
</code></pre></div></div>

<p>We compile it, we run it, and we save its output to a text file called <code class="language-plaintext highlighter-rouge">sizes</code>, here’s what I have locally</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CHAR_SIZE=4
CHAR_LIST_SIZE=16
</code></pre></div></div>

<p>Now our Rust library has to be changed to work in 2 different modes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">native</code> - when Rust structs are used as fields.</li>
  <li><code class="language-plaintext highlighter-rouge">external</code> - when only size of structs is known, but fields and their positions are not.</li>
</ul>

<p>We a new feature to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[features]
default = []

# enables "external" mode, when structs have only size but no fields
external = []
</code></pre></div></div>

<p>and we create a build script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#[cfg(feature = "external")]
fn main() {
    // read path of the `sizes` file from the ENV var
    let sizes_filepath = env!("SIZES_FILEPATH");
    // read `sizes` file
    let sizes = std::fs::read_to_string(sizes_filepath)
                  .expect("SIZES_FILEPATH has to point to a file");

    // parse it line by line and re-write to Rust
    let sizes_rs = sizes
        .lines()
        .map(|line| {
            let parts = line.split("=").collect::&lt;Vec&lt;_&gt;&gt;();
            let name = parts[0];
            let value = parts[1];
            format!("pub(crate) const {}: usize = {};", name, value)
        })
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .join("\n");

    // write it back to sizes.rs
    std::fs::write("src/sizes.rs", sizes_rs).unwrap();
}

#[cfg(not(feature = "external"))]
fn main() {
    // dummy main for "native" mode when no work is needed
}
</code></pre></div></div>

<p>Note: also there should be a <code class="language-plaintext highlighter-rouge">rerun-if-changed</code> line, but for the sake of implicitly I ignore dependencies here.</p>

<p>After running <code class="language-plaintext highlighter-rouge">SIZES_FILEPATH=path/to/sizes cargo build --features=external</code> we get <code class="language-plaintext highlighter-rouge">src/sizes.rs</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">const</span> <span class="n">CHAR_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">const</span> <span class="n">CHAR_LIST_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</code></pre></div></div>

<p>Time to use it! First we wrap existing definition of <code class="language-plaintext highlighter-rouge">Char</code> and <code class="language-plaintext highlighter-rouge">CharList</code> with</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">))]</span>
<span class="k">mod</span> <span class="n">native</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">type</span> <span class="n">Char</span> <span class="o">=</span> <span class="nb">char</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">type</span> <span class="n">CharList</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">))]</span>
<span class="k">use</span> <span class="nn">native</span><span class="p">::{</span><span class="n">Char</span><span class="p">,</span> <span class="n">CharList</span><span class="p">};</span>
</code></pre></div></div>

<p>(note that we use <code class="language-plaintext highlighter-rouge">not(feature = "external")</code> above, which means “native” mode, they are opposite, and so one feature is enough) and then we add conditionally included <code class="language-plaintext highlighter-rouge">external</code> module with <strong>all</strong> structs that we use:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">)]</span>
<span class="k">mod</span> <span class="n">sizes</span><span class="p">;</span>
<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">)]</span>
<span class="k">mod</span> <span class="n">external</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">sizes</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[repr(C)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Char</span> <span class="p">{</span>
        <span class="n">bytes</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">CHAR_SIZE</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="nd">#[repr(C)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">CharList</span> <span class="p">{</span>
        <span class="n">bytes</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">CHAR_LIST_SIZE</span><span class="p">],</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">)]</span>
<span class="k">use</span> <span class="nn">external</span><span class="p">::{</span><span class="n">Char</span><span class="p">,</span> <span class="n">CharList</span><span class="p">};</span>
</code></pre></div></div>

<p>Now if we try to return <code class="language-plaintext highlighter-rouge">CharList</code> from our <code class="language-plaintext highlighter-rouge">foo</code> function we get compilation errors:</p>

<ul>
  <li>there’s no way to construct a <code class="language-plaintext highlighter-rouge">Char</code> from <code class="language-plaintext highlighter-rouge">char</code></li>
  <li>we can’t <code class="language-plaintext highlighter-rouge">collect()</code> <code class="language-plaintext highlighter-rouge">CharList</code> from <code class="language-plaintext highlighter-rouge">Iterator&lt;char&gt;</code></li>
</ul>

<p>How can we implement it? Let’s take a look again at used APIs.</p>

<ol>
  <li>we iterate over given string (it’ll be a <code class="language-plaintext highlighter-rouge">const *u8</code> in C API) - we have it</li>
  <li>we check <code class="language-plaintext highlighter-rouge">c.is_ascii()</code> - that’s also ok</li>
  <li>we need to map <code class="language-plaintext highlighter-rouge">char</code> to foreign <code class="language-plaintext highlighter-rouge">Char</code> - <strong>this requires a constructor</strong></li>
  <li>we need a way to construct <code class="language-plaintext highlighter-rouge">CharList</code> from chars - <strong>this requires methods like <code class="language-plaintext highlighter-rouge">CharList::new()</code> and <code class="language-plaintext highlighter-rouge">CharList::push()</code></strong></li>
  <li>we have a unit-test that needs <code class="language-plaintext highlighter-rouge">CharList::len()</code>, <code class="language-plaintext highlighter-rouge">CharList::at()</code>, <code class="language-plaintext highlighter-rouge">impl PartialEq for Char</code> (to compare individual chars) and <code class="language-plaintext highlighter-rouge">impl std::fmt::Debug for Char</code> (to print LHS/RHS if assertions fails)</li>
</ol>

<p>So, here’s a list of “external” (i.e. in the <code class="language-plaintext highlighter-rouge">mod external {}</code> block) methods we want to have:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Char</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For now all of them can return <code class="language-plaintext highlighter-rouge">todo!()</code>, but we’ll implement them later. Time to rewrite our Rust implementation to use these new language-independent functionality:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">char_list</span> <span class="o">=</span> <span class="nn">CharList</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="nb">char</span> <span class="k">in</span> <span class="n">s</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nb">char</span><span class="nf">.is_ascii</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">char_list</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nb">char</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">char_list</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abc😋中国"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">chars</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="sc">'😋'</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="sc">'中'</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.at</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="sc">'国'</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That was easy, right? Way less elegant but still easy.</p>

<h2 id="implementing-bindings">Implementing bindings</h2>

<p>At this point you might have a guess on what’s going to happen next. We are going to define a bunch of external C-ABI functions and blindly call them in all <code class="language-plaintext highlighter-rouge">todo!()</code> places. Later these functions will be implemented by the bindings library on C side:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">char__new</span><span class="p">(</span><span class="n">c1</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">c2</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">c3</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">c4</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Char</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">char__at</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">Char</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">byte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char__at</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
        <span class="n">c</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char__new</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">Char</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">zero_idx</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">bytes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">zero_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">zero_idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.chars</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">idx</span><span class="p">|</span> <span class="k">self</span><span class="nf">.byte_at</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span><span class="nf">.byte_at</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="nn">char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">char_list__new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">CharList</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CharList</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Char</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">CharList</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">CharList</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">const</span> <span class="n">Char</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__new</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Char</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ok, now we have a contract. Rust relies on it, but C so far doesn’t provide anything. If we try to run tests with <code class="language-plaintext highlighter-rouge">--features=external</code> we get a bunch of linkage errors, which is 100% expected. Time to implement in on C side.</p>

<p>This is a “shared” version that we’ll use for C++/Ruby/Node.JS bindings</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_H
#define BINDINGS_H
</span>
<span class="cp">#include DEFINITIONS_FILE
</span>
<span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
<span class="cp">#endif
</span>
    <span class="n">Char_BLOB</span> <span class="n">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">char__bytes</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

    <span class="n">CharList_BLOB</span> <span class="n">char_list__new</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Char_BLOB</span> <span class="n">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
</span>
<span class="cp">#endif // BINDINGS_H
</span></code></pre></div></div>

<p>It includes <code class="language-plaintext highlighter-rouge">DEFINITIONS_FILE</code> because we want it to be generic (and we’ll pass it as a dynamic define via <code class="language-plaintext highlighter-rouge">-D</code> flag). Also you might notice that methods take/return <code class="language-plaintext highlighter-rouge">&lt;type&gt;_BLOB</code> type, that’s because we want to pass C-compatible types. C types are C-compatible, and so we make another file <code class="language-plaintext highlighter-rouge">bindings-support.h</code> with</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_SUPPORT_H
#define BINDINGS_SUPPORT_H
</span>
<span class="cp">#include</span> <span class="cpf">"structs.h"</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="n">Char</span> <span class="n">Char_BLOB</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">CharList</span> <span class="n">CharList_BLOB</span><span class="p">;</span>

<span class="cp">#endif // BINDINGS_SUPPORT_H
</span></code></pre></div></div>

<p>… to create aliases. For C++ we’ll have to convert our classes to something C understands (I’ll cover it later).</p>

<p>Implementation time!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Char_BLOB</span> <span class="nf">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Char_BLOB</span><span class="p">){.</span><span class="n">bytes</span> <span class="o">=</span> <span class="p">{</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">}};</span>
<span class="p">}</span>
<span class="kt">uint8_t</span> <span class="nf">char__at</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">CharList_BLOB</span> <span class="nf">char_list__new</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">CharList_BLOB</span><span class="p">){.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Char</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Char</span><span class="p">));</span>
        <span class="n">free</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">size_t</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Char_BLOB</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We compile it</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang c-bindings/bindings.c <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-o</span> c-bindings/all.o
<span class="nv">$ </span>ar rc c-bindings/libbindings.a c-bindings/all.o
</code></pre></div></div>

<p>And change our <code class="language-plaintext highlighter-rouge">build.rs</code> script to link with it (the purpose of these env variables is to make external primitives implementation “pluggable”):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">external_lib_path</span> <span class="o">=</span> <span class="nd">env!</span><span class="p">(</span><span class="s">"EXTERNAL_LIB_PATH"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-search={}"</span><span class="p">,</span> <span class="n">external_lib_path</span><span class="p">);</span>

<span class="k">let</span> <span class="n">external_lib_name</span> <span class="o">=</span> <span class="nd">env!</span><span class="p">(</span><span class="s">"EXTERNAL_LIB_NAME"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-lib=static={}"</span><span class="p">,</span> <span class="n">external_lib_name</span><span class="p">);</span>
</code></pre></div></div>

<p>And now we can run tests:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>rust-lib
<span class="nv">$ EXTERNAL_LIB_PATH</span><span class="o">=</span><span class="s2">"../c-bindings"</span> <span class="se">\</span>
    <span class="nv">EXTERNAL_LIB_NAME</span><span class="o">=</span><span class="s2">"bindings"</span> <span class="se">\</span>
    <span class="nv">SIZES_FILEPATH</span><span class="o">=</span><span class="s2">"../c-bindings/sizes"</span> <span class="se">\</span>
    cargo <span class="nb">test</span> <span class="nt">--features</span><span class="o">=</span>external
</code></pre></div></div>

<p>and we get 1 passing test!</p>

<h2 id="c-bindings-quickly">C++ bindings, quickly</h2>

<p>I want this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef STRUCTS_HPP
#define STRUCTS_HPP
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Char</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">Char</span><span class="p">()</span> <span class="o">:</span> <span class="n">Char</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">explicit</span> <span class="n">Char</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c4</span><span class="p">)</span> <span class="o">:</span> <span class="n">bytes</span><span class="p">{</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">}</span> <span class="p">{}</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">size</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">size</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">as_string</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">CharList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Char</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cp">#endif // STRUCTS_HPP
</span></code></pre></div></div>

<p>C functions are the same, but these classes are incompatible with C FFI, so we need to define our BLOBs:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_SUPPORT_HPP
#define BINDINGS_SUPPORT_HPP
</span>
<span class="cp">#include</span> <span class="cpf">"structs.hpp"</span><span class="cp">
</span>
<span class="cp">#define DECLARE_BLOB(T)               \
    extern "C"                        \
    {                                 \
        struct T##_BLOB               \
        {                             \
            uint8_t bytes[sizeof(T)]; \
        };                            \
    }                                 \
    union T##_UNION                   \
    {                                 \
        T value;                      \
        T##_BLOB blob;                \
                                      \
        ~T##_UNION() {}               \
        T##_UNION()                   \
        {                             \
            new (&amp;value) T();         \
        }                             \
    };                                \
    T##_BLOB PACK_##T(T value)        \
    {                                 \
        T##_UNION u;                  \
        u.value = std::move(value);   \
        return u.blob;                \
    };                                \
    T UNPACK_##T(T##_BLOB blob)       \
    {                                 \
        T##_UNION u;                  \
        u.blob = blob;                \
        return std::move(u.value);    \
    }
</span>
<span class="n">DECLARE_BLOB</span><span class="p">(</span><span class="n">Char</span><span class="p">);</span>
<span class="n">DECLARE_BLOB</span><span class="p">(</span><span class="n">CharList</span><span class="p">);</span>

<span class="cp">#endif // BINDINGS_SUPPORT_HPP
</span></code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">DECLARE_BLOB</code> macro for given <code class="language-plaintext highlighter-rouge">Type</code> defines:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Type_BLOB</code> struct that is C-compatible</li>
  <li><code class="language-plaintext highlighter-rouge">Type_UNION</code> union that is a union of <code class="language-plaintext highlighter-rouge">Type</code> and <code class="language-plaintext highlighter-rouge">Type_BLOB</code></li>
  <li><code class="language-plaintext highlighter-rouge">PACK_Type</code> function that converts an instance of <code class="language-plaintext highlighter-rouge">Type</code> to <code class="language-plaintext highlighter-rouge">Type_BLOB</code> so we can return if <strong>from</strong> <code class="language-plaintext highlighter-rouge">extern "C"</code> function</li>
  <li><code class="language-plaintext highlighter-rouge">UNPACK_Type</code> function that converts <code class="language-plaintext highlighter-rouge">Type_BLOB</code> to <code class="language-plaintext highlighter-rouge">Type</code> so we can “unpack” blob that is passed <strong>to</strong> <code class="language-plaintext highlighter-rouge">extern "C"</code> function</li>
</ul>

<p>This conversion with <code class="language-plaintext highlighter-rouge">union</code> is an equivalent of <code class="language-plaintext highlighter-rouge">std::mem::transmute</code> from Rust (C++20 has <code class="language-plaintext highlighter-rouge">std::bit_cast</code> for that, but <code class="language-plaintext highlighter-rouge">union</code> shows better what happens under the hood). Also we <code class="language-plaintext highlighter-rouge">std::move</code> the value to and from <code class="language-plaintext highlighter-rouge">union</code> on conversion, this is important (otherwise, copyable types are copied).</p>

<p>However, it has a requirement for <code class="language-plaintext highlighter-rouge">T</code> to be both movable and constructible with no args. We could do <code class="language-plaintext highlighter-rouge">std::memset(this, 0, sizeof(T))</code>, but some move constructors/assignment operators swap fields of <code class="language-plaintext highlighter-rouge">this</code> and given <code class="language-plaintext highlighter-rouge">other</code>, and so sometimes it’s invalid to call a destructor on an object full of zeroes (of course it totally depends on the structure of the object).</p>

<p>With these blobs implementing binding functions is trivial:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
    <span class="n">Char_BLOB</span> <span class="n">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PACK_Char</span><span class="p">(</span><span class="n">Char</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">char__at</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Char</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">CharList_BLOB</span> <span class="n">char_list__new</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PACK_CharList</span><span class="p">(</span><span class="n">CharList</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="p">((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">UNPACK_Char</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">Char_BLOB</span> <span class="n">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PACK_Char</span><span class="p">(((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We compile and build a static library:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang++ <span class="nt">-std</span><span class="o">=</span>c++17 cpp-bindings/bindings.cpp <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-fPIE</span> <span class="nt">-o</span> cpp-bindings/all.o
<span class="nv">$ </span>ar rc cpp-bindings/libbindings.a cpp-bindings/all.o
</code></pre></div></div>

<p>One extra step that is specific to C++ libraries - we need to link with C++ runtime, so this extra code goes to <code class="language-plaintext highlighter-rouge">Cargo.toml</code> and <code class="language-plaintext highlighter-rouge">build.rs</code> respectively:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[features]</span>
<span class="c"># enables linking with C++ runtime</span>
<span class="py">link-with-cxx-runtime</span> <span class="p">=</span> <span class="p">[]</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">feature</span> <span class="o">=</span> <span class="s">"link-with-cxx-runtime"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">target_os</span> <span class="o">=</span> <span class="s">"linux"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-lib=dylib=stdc++"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-lib=dylib=c++"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally we can run our tests:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">EXTERNAL_LIB_PATH</span><span class="o">=</span><span class="s2">"../cpp-bindings"</span> <span class="se">\</span>
  <span class="nv">EXTERNAL_LIB_NAME</span><span class="o">=</span><span class="s2">"bindings"</span> <span class="se">\</span>
  <span class="nv">SIZES_FILEPATH</span><span class="o">=</span><span class="s2">"../cpp-bindings/sizes"</span> <span class="se">\</span>
  cargo <span class="nb">test</span> <span class="nt">--features</span><span class="o">=</span>external,link-with-cxx-runtime
</code></pre></div></div>

<h2 id="ruby-bindings-also-quickly">Ruby bindings, also quickly</h2>

<p>We want our <code class="language-plaintext highlighter-rouge">Char</code> to be a Ruby <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">CharList</code> to be an <code class="language-plaintext highlighter-rouge">Array</code>, in Ruby C API they are both represented as <code class="language-plaintext highlighter-rouge">VALUE</code> (that is technically a pointer to a tagged union (unless it’s a small number/<code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code>/<code class="language-plaintext highlighter-rouge">nil</code>, then it’s basically the value itself)).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef STRUCTS_H
#define STRUCTS_H
</span>
<span class="cp">#include</span> <span class="cpf">&lt;ruby.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="n">VALUE</span> <span class="n">Char</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">VALUE</span> <span class="n">CharList</span><span class="p">;</span>

<span class="cp">#endif // STRUCTS_H
</span></code></pre></div></div>

<p>and so sizes are these:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CHAR_SIZE=8
CHAR_LIST_SIZE=8
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">VALUE</code> is simply an alias to <code class="language-plaintext highlighter-rouge">unsigned long</code> on x86_64, so blobs are aliases:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_SUPPORT_H
#define BINDINGS_SUPPORT_H
</span>
<span class="cp">#include</span> <span class="cpf">"structs.h"</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="n">Char</span> <span class="n">Char_BLOB</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">CharList</span> <span class="n">CharList_BLOB</span><span class="p">;</span>

<span class="cp">#endif // BINDINGS_SUPPORT_H
</span></code></pre></div></div>

<p>Bindings implementation (uses Ruby C API):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bindings-support.h"</span><span class="cp">
</span>
<span class="n">Char_BLOB</span> <span class="nf">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">char</span><span class="p">)</span><span class="n">c1</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">c2</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">c3</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">c4</span><span class="p">};</span>
    <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c3</span><span class="p">)</span> <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c4</span><span class="p">)</span> <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">rb_utf8_str_new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">uint8_t</span> <span class="nf">char__at</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">this</span> <span class="o">=</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">StringValuePtr</span><span class="p">(</span><span class="n">this</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">CharList_BLOB</span> <span class="nf">char_list__new</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_ary_new</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">rb_ary_push</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">size_t</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_array_len</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Char_BLOB</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_ary_entry</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looks similar to C++ bindings, right? Ok, can we run Rust tests with Ruby primitives? Unfortunately, no. These methods expect Ruby VM to be up and running and embedding Ruby is not something many Ruby developers do.</p>

<p>Instead, we need to re-compile it to a dynamically-loaded library that (once loaded) registers a <code class="language-plaintext highlighter-rouge">foo</code> method that takes a string, passes its <code class="language-plaintext highlighter-rouge">const char *</code> pointer to our <code class="language-plaintext highlighter-rouge">foo</code> function defined in Rust and returns <code class="language-plaintext highlighter-rouge">CharList</code> back to Ruby space.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ruby.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"structs.h"</span><span class="cp">
</span>
<span class="n">CharList</span> <span class="nf">c_foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="n">VALUE</span> <span class="nf">rb_foo</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
    <span class="n">Check_Type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">T_STRING</span><span class="p">);</span>
    <span class="n">CharList</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">c_foo</span><span class="p">(</span><span class="n">StringValueCStr</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">chars</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Init_foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">rb_define_global_function</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="n">rb_foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">c_foo</code> is defined on Rust side with C linkage:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">c_foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ffi</span><span class="p">::</span><span class="nn">CStr</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="nf">.to_str</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">};</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now if we compile it to <code class="language-plaintext highlighter-rouge">.bundle</code> (this is for Mac, on Linux and Windows it’s a <code class="language-plaintext highlighter-rouge">.so</code> extension)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-Ipath</span>/to/ruby/includes ruby-bindings/init.c <span class="nt">-c</span> <span class="nt">-o</span> ruby-bindings/init.o
<span class="nv">$ </span>clang <span class="nt">-Ipath</span>/to/ruby/includes ruby-bindings/bindings.c <span class="nt">-c</span> <span class="nt">-o</span> ruby-bindings/bindings.o
<span class="nv">$ </span>ar rc ruby-bindings/libbindings.a ruby-bindings/bindings.o

<span class="nv">$ </span><span class="nb">cd </span>rust-lib
<span class="nv">$ EXTERNAL_LIB_PATH</span><span class="o">=</span><span class="s2">"../ruby-bindings"</span> <span class="se">\</span>
    <span class="nv">EXTERNAL_LIB_NAME</span><span class="o">=</span>bindings <span class="se">\</span>
    <span class="nv">SIZES_FILEPATH</span><span class="o">=</span><span class="s2">"../ruby-bindings/sizes"</span> <span class="se">\</span>
    cargo build <span class="nt">--features</span><span class="o">=</span>external
<span class="nv">$ </span><span class="nb">cd</span> ..

<span class="nv">$ </span>clang <span class="se">\</span>
    <span class="nt">-dynamic</span> <span class="se">\</span>
    <span class="nt">-bundle</span> <span class="se">\</span>
    <span class="nt">-o</span> ruby-bindings/foo.bundle <span class="se">\</span>
    ruby-bindings/init.o rust-foo/librust-foo-rust.a <span class="se">\</span>
    <span class="nt">-Wl</span>,-undefined,dynamic_lookup
</code></pre></div></div>

<p>.. we get <code class="language-plaintext highlighter-rouge">ruby-bindings/foo.bundle</code> that can be imported from Ruby:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ruby <span class="nt">-r</span>./ruby-bindings/foo <span class="nt">-e</span> <span class="s1">'p foo("abc😋中国")'</span>
<span class="o">[</span><span class="s2">"😋"</span>, <span class="s2">"中"</span>, <span class="s2">"国"</span><span class="o">]</span>
</code></pre></div></div>

<p>In fact there are many more options that are passed to <code class="language-plaintext highlighter-rouge">clang</code> above, check out <a href="https://github.com/iliabylich/writing-bindings-upside-down">the repo</a> if you want to try it yourself.</p>

<h2 id="memory-leaks">Memory leaks</h2>

<p>All versions above have a memory leak that can be easily identified by compiling with</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">detect_leaks</span><span class="o">=</span>1 <span class="nv">CXXFLAGS</span><span class="o">=</span><span class="s2">"-fsanitize=address"</span> clang++
</code></pre></div></div>

<p>or (to track it when running Rust tests)</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">RUSTFLAGS</span><span class="o">=</span><span class="s2">"-Z sanitizer=address"</span> ... cargo <span class="nb">test</span>
</code></pre></div></div>

<p>(On Mac make sure to use <code class="language-plaintext highlighter-rouge">clang</code> from Homebrew, version that ships with OS doesn’t support ASAN)</p>

<p>Running tests with this options shows that we have a leak somewhere in</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Direct leak of 96 byte(s) in 1 object(s) allocated from:
...
    #9 0x105905990 in char_list__push bindings.cpp:34
    #10 0x105904c04 in rust_foo::external::CharList::push::hf5bdccdb764b0c62 lib.rs:91
    #11 0x1059043bb in rust_foo::foo::hf9387b4435c6f8b6 lib.rs:108
    #12 0x10590442d in c_foo lib.rs:117
    #13 0x1059006e8 in cpp_foo(char const*) test.cpp:14
    #14 0x105900a10 in main test.cpp:24
</code></pre></div></div>

<p>And the reason is that our <code class="language-plaintext highlighter-rouge">CharList</code> is heap-allocated, but it has no destructor on the Rust side. To fix it we need to add 2 more functions to our bindings:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Char</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CharList</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char__drop</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Of course, we need to add it to <code class="language-plaintext highlighter-rouge">bindings.h</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifdef __cplusplus
extern "C"
{
#endif

    void char__drop(Char_BLOB *self);
    void char_list__drop(CharList_BLOB *self);

#ifdef __cplusplus
}
#endif
</code></pre></div></div>

<p>Here’s a C implementation (depending on your implementation <code class="language-plaintext highlighter-rouge">char__drop</code> could to something):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Char has no allocations</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C++ implementation:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Char has no allocations</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">vector</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ruby:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Ruby has GC</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Ruby has GC</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="performance">Performance</h2>

<p>How about performance? When we compile with Rust primitives we use LTO and so things from Rust standard library can be optimized together with our code. Luckily, there’s a way to do that for external primitives too.</p>

<p>I’d like to demonstrate it on the low level, first let’s compile everything to LLVM IR:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang-13 <span class="nt">-S</span> <span class="nt">-emit-llvm</span> c-bindings/bindings.c <span class="nt">-o</span> c-bindings/bindings.ll
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> c-bindings/bindings.ll
define dso_local i32 @char__new<span class="o">(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span class="o">)</span> <span class="c">#0 {</span>
define dso_local zeroext i8 @char__at<span class="o">(</span>%struct.Char<span class="k">*</span> %0, i8 zeroext %1<span class="o">)</span> <span class="c">#0 {</span>
define dso_local void @char__drop<span class="o">(</span>%struct.Char<span class="k">*</span> %0<span class="o">)</span> <span class="c">#0 {</span>
</code></pre></div></div>

<p>^ that was the file with bindings implementation, C part. It defines all <code class="language-plaintext highlighter-rouge">char__</code> functions.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>rust-foo
<span class="nv">$ </span>rustc <span class="nt">--crate-name</span> rust_foo src/lib.rs <span class="nt">--crate-type</span> staticlib <span class="nt">--emit</span><span class="o">=</span>llvm-ir <span class="nt">--cfg</span> <span class="s1">'feature="default"'</span> <span class="nt">--cfg</span> <span class="s1">'feature="external"'</span>
<span class="nv">$ </span><span class="nb">cd</span> ..
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> rust-foo/rust_foo.ll
  %8 <span class="o">=</span> call i32 @char__new<span class="o">(</span>i8 zeroext %_8, i8 zeroext %_10, i8 zeroext %_12, i8 zeroext %_14<span class="o">)</span>
<span class="nb">declare </span>i32 @char__new<span class="o">(</span>i8 zeroext, i8 zeroext, i8 zeroext, i8 zeroext<span class="o">)</span> unnamed_addr <span class="c">#1</span>
</code></pre></div></div>

<p>^ that was the Rust part. It declares (as external) and calls some of our <code class="language-plaintext highlighter-rouge">char__</code> functions.</p>

<p>Let’s link them together:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llvm-link-13 c-bindings/bindings.ll rust-foo/rust_foo.ll <span class="nt">-S</span> <span class="nt">-o</span> merged.ll
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> merged.ll
define dso_local i32 @char__new<span class="o">(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span class="o">)</span> <span class="c">#0 {</span>
define dso_local zeroext i8 @char__at<span class="o">(</span>%struct.Char<span class="k">*</span> %0, i8 zeroext %1<span class="o">)</span> <span class="c">#0 {</span>
define dso_local void @char__drop<span class="o">(</span>%struct.Char<span class="k">*</span> %0<span class="o">)</span> <span class="c">#0 {</span>
  %8 <span class="o">=</span> call i32 @char__new<span class="o">(</span>i8 zeroext %_8, i8 zeroext %_10, i8 zeroext %_12, i8 zeroext %_14<span class="o">)</span>
</code></pre></div></div>

<p>These 2 modules have been merged, time to optimize them together:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>opt-13 <span class="nt">-O3</span> merged.ll <span class="nt">-S</span> <span class="nt">-o</span> optimized.ll
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> optimized.ll
define dso_local i32 @char__new<span class="o">(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span class="o">)</span> local_unnamed_addr <span class="c">#0 {</span>
define dso_local zeroext i8 @char__at<span class="o">(</span>%struct.Char<span class="k">*</span> nocapture <span class="nb">readonly</span> %0, i8 zeroext %1<span class="o">)</span> local_unnamed_addr <span class="c">#1 {</span>
define dso_local void @char__drop<span class="o">(</span>%struct.Char<span class="k">*</span> nocapture %0<span class="o">)</span> local_unnamed_addr <span class="c">#0 {</span>
</code></pre></div></div>

<p>Now we have only definitions, actual calls have been successfully inlined. Now we can compile it to an object file to see a final result:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llc-13 <span class="nt">-O3</span> <span class="nt">-filetype</span><span class="o">=</span>obj optimized.ll <span class="nt">-o</span> optimized.o
<span class="nv">$ </span>clang-13 test.c optimized.o <span class="nt">-O3</span> <span class="nt">-o</span> test-runner
<span class="nv">$ </span>objdump <span class="nt">-D</span> test-runner | <span class="nb">grep</span> <span class="s2">"call"</span> | <span class="nb">grep</span> <span class="s2">"char__"</span>
<span class="c"># no output</span>
<span class="nv">$ </span>objdump <span class="nt">-D</span> test-runner | <span class="nb">grep</span> <span class="s2">"call"</span> | <span class="nb">grep</span> <span class="s2">"char_list"</span>
  406bba: e8 01 01 00 00        callq  406cc0 &lt;char_list__drop&gt;
  406d21: e8 fa fe ff ff        callq  406c20 &lt;char_list__new&gt;
</code></pre></div></div>

<p>As you can see all <code class="language-plaintext highlighter-rouge">char__new</code> or <code class="language-plaintext highlighter-rouge">char__at</code> calls have been inlined, <code class="language-plaintext highlighter-rouge">char_list__drop</code> and <code class="language-plaintext highlighter-rouge">char_list__new</code> haven’t, because of how LLVM decides on what should or should not be inlined. Anyway, it works.</p>

<p>Of course, there’s an easier way to get the same result:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">RUSTFLAGS</span><span class="o">=</span><span class="s2">"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld"</span>
<span class="nv">$ </span><span class="nb">export </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-flto"</span>
</code></pre></div></div>

<p>^ this should be enough to get the same result. By adding <code class="language-plaintext highlighter-rouge">-Clinker-plugin-lto</code> we ask Rust to compile all object files to LLVM IR:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ RUSTFLAGS</span><span class="o">=</span><span class="s2">"-Clinker-plugin-lto -Clinker=clang-13 -Clink-arg=-fuse-ld=lld"</span> cargo build <span class="nt">--features</span><span class="o">=</span>external

<span class="nv">$ </span><span class="nb">mkdir </span>objects
<span class="nv">$ </span><span class="nb">cd </span>objects
<span class="nv">$ </span>ar x ../target/release/librust_foo.a
<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span>
<span class="c"># a ton of object files, that's what static library is about</span>

<span class="nv">$ </span>file <span class="k">*</span>.o

... snip ...
popcountti2.o:                                                                              ELF 64-bit LSB relocatable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, with debug_info, not stripped
powixf2.o:                                                                                  ELF 64-bit LSB relocatable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, with debug_info, not stripped
rust_foo-0f1418f7365bf15b.2nf5cb5qlud0f6qs.rcgu.o:                                          LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.0.rcgu.o:                                   LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.1.rcgu.o:                                   LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.2.rcgu.o:                                   LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.3.rcgu.o:                                   LLVM IR bitcode
rustc_demangle-7f98f837d3579544.rustc_demangle.5563b4d3-cgu.0.rcgu.o:                       ELF 64-bit LSB relocatable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, with debug_info, not stripped
... snip ...
</code></pre></div></div>

<p>Rust standard library is compiled directly to object files, but our code is <code class="language-plaintext highlighter-rouge">LLVM IR bitcode</code>. <strong>This way we can get zero-cost bindings defined externally</strong>.</p>

<p>Of course, it’s not gonna work with Ruby or NodeJS, both of them have a giant <code class="language-plaintext highlighter-rouge">libruby.so</code> (or <code class="language-plaintext highlighter-rouge">libnode.so</code>) that defines all functions and constants that your extension relies on. The extension itself is compiled with <code class="language-plaintext highlighter-rouge">-Wl,-undefined,dynamic_lookup</code> and symbol lookup is performed at runtime. I feel like technically it’s possible, the entire Ruby/NodeJS runtime could be compiled to a static <code class="language-plaintext highlighter-rouge">libruby.a</code>/<code class="language-plaintext highlighter-rouge">libnode.a</code> that defines all VM objects as external (because that’s a singleton that we need to hook into), but all functions can provide their implementation (of course, in LLVM IR format), and so they can be inlined into our bindings implementation. I haven’t experimented with it yet, and honestly I’m not going to :) If you know anything about existing discussions around it, please, ping me on Twitter.</p>

<h2 id="the-whole-picture-again">The whole picture, again</h2>

<p>Demo repo is available <a href="https://github.com/iliabylich/writing-bindings-upside-down">here</a></p>

<p>To sum up:</p>

<ol>
  <li>Library maintainers can change their library to accept <strong>“pluggable” external primitives</strong>. If no external primitives provided native version is used.</li>
  <li>Library maintainers can <strong>provide headers</strong> that define what should be provided (i.e. a set of functions that take/return primitives). This is the definition of the contract.</li>
  <li>Authors of bindings <strong>define structure as they want</strong> (i.e. instead of vector they are free to use linked lists of hashmaps)</li>
  <li>Authors of bindings <strong>implement functions defined in headers</strong>. This is the implementation of the contract.</li>
  <li>To get full bindings the library is linked together with bindings. There might be a need to build a wrapper around functions defined in the library, but that’s trivial as these functions return objects that are “native” for bindings.</li>
</ol>

<p>Pros:</p>

<ul>
  <li>To implement bindings you don’t wrap every single function, instead you focus on implementing types and contract around them. Moreover, the contract is quite simple and many languages have a rich standard library, so implementing these library-defined functions can be very easy.</li>
  <li>Libraries can provide headers, so it’s hard to make a mistake.</li>
  <li>Libraries usually have a decent test suite, it can be used to verify bindings for correctness and memory leaks.</li>
</ul>

<p>Cons:</p>

<ul>
  <li>The library needs quite a lot of changes to support “external” primitives. That’s not an easy task.</li>
  <li>The library needs to ship with a “reference implementation”, to verify that existing external functions are enough to build everything.</li>
  <li>There are minor differences between standard types in languages, for example C++ has a small string optimization, and small strings are not “containers”. On the other side Rust strings are true containers, and library developers may expect “external” string to be a container, too, but on the bindings side <code class="language-plaintext highlighter-rouge">std::string</code> from C++ doesn’t fully match the contract (i.e. you can’t borrow a <code class="language-plaintext highlighter-rouge">char *</code> from <code class="language-plaintext highlighter-rouge">std::string</code> and expect it to live as long as the string lives). In some cases it can become really hard to track and fix.</li>
</ul>]]></content><author><name></name></author><category term="rust" /><category term="c" /><category term="c++" /><category term="ruby" /><category term="js" /><category term="node" /><category term="bindings" /><category term="llvm" /><category term="lto" /><summary type="html"><![CDATA[Quite a long time ago I started writing C/C++/Ruby/Node.JS/WASM bindings so I could call my Rust project from those languages. It is a Ruby language parser.]]></summary></entry><entry><title type="html">lib-ruby-parser</title><link href="https://iliabylich.github.io/2020/11/22/lib-ruby-parser.html" rel="alternate" type="text/html" title="lib-ruby-parser" /><published>2020-11-22T21:00:00+00:00</published><updated>2020-11-22T21:00:00+00:00</updated><id>https://iliabylich.github.io/2020/11/22/lib-ruby-parser</id><content type="html" xml:base="https://iliabylich.github.io/2020/11/22/lib-ruby-parser.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>So, I’m ready to announce that I’ve finished working on a new Ruby parser. It’s called <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code>.</p>

<p>Key features:</p>

<ol>
  <li>It’s fast. It’s written in Rust and it’s slightly faster than Ripper. The difference is about 1-2% on my machine.</li>
  <li>It has a beautiful interface. Every single node has its own type that is documented. For example, take a look at <a href="https://docs.rs/lib-ruby-parser/0.7.0/lib_ruby_parser/nodes/struct.CSend.html">CSend node</a> that represents “conditional send” like <code class="language-plaintext highlighter-rouge">foo&amp;.bar</code>. <a href="https://docs.rs/lib-ruby-parser/0.7.0/lib_ruby_parser/nodes/index.html">Here’s a list of all defined nodes</a>. Both Ripper and RubyVM::AST have no documentation of their AST format. <code class="language-plaintext highlighter-rouge">whitequark/parser</code> <a href="https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md">has a great documentation</a>, but its AST is not “static”.</li>
  <li>What’s “static AST”? By saying that I mean that if documentation says that “N is not-nullable” then it’s true no matter what. <code class="language-plaintext highlighter-rouge">whitequark/parser</code> does a great job, but the nature of dynamic language doesn’t allow it to provide such guarantees. I’ll show a few examples later.</li>
  <li>It’s precise. Unlike <code class="language-plaintext highlighter-rouge">whitequark/parser</code>, its lexer (or tokenizer if it sounds better for you) is based on MRI’s <code class="language-plaintext highlighter-rouge">parse.y</code>. What does it mean? It means that I wasn’t able to find any difference in lexing on 3 million lines of code that I’ve got by pulling sources of top 300 gems (by total downloads). I’ll mention how I track it soon.</li>
  <li>It doesn’t depend on Ruby. In fact, it has absolutely no “required” dependencies (only a few optional ones). So, it’s possible to write bindings for any other language, and I’ve made them for C/C++/Node.js. Of course, it’s possible to have bindings for Ruby (because there are bindings for C and it’s easy to reuse them)</li>
</ol>

<h2 id="implementation">Implementation</h2>

<p>Current performance (in release mode, with jemalloc) is ~200K LOC/s. I think it can even be used for syntax highlighting (and in the browser, too, haha).</p>

<p>I don’t want to dig too far, but some notes could be interesting.</p>

<p>Rust is a general purpose language that is based on LLVM (&lt;3) and can be compiled directly into machine code. It doesn’t need any VMs and it can be compiled to a ton of targets (or platforms). The code doesn’t use pointers, and there are no <code class="language-plaintext highlighter-rouge">unsafe</code> calls that you might hear about.</p>

<p>Rust does support ADT (algebraic data type) and it has generics, so you can build data structures like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Empty</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Beautiful, right?</p>

<p>I designed <code class="language-plaintext highlighter-rouge">Node</code> struct in a very similar way:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="nf">Variant1</span><span class="p">(</span><span class="n">Variant1</span><span class="p">),</span>
    <span class="nf">Variant2</span><span class="p">(</span><span class="n">Variant2</span><span class="p">),</span>
    <span class="nf">Variant3</span><span class="p">(</span><span class="n">Variant3</span><span class="p">),</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Variant1</span> <span class="p">{</span>
    <span class="c1">// fields</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Variant2</span> <span class="p">{</span>
    <span class="c1">// fields</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>If you are familiar with C/C++ it might look similar to tagged union, and was I know that’s exactly how they are implemented. Close equivalent in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">VARIANT1</span><span class="p">,</span>
    <span class="n">VARIANT2</span><span class="p">,</span>
  <span class="p">}</span> <span class="n">variant_no</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="c1">// variant1 data ...</span>
    <span class="p">}</span> <span class="n">variant1_data</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
      <span class="c1">// variant2 data ...</span>
    <span class="p">}</span> <span class="n">variant2_data</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">variant_value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>As I said, my lexer is based on MRI’s <code class="language-plaintext highlighter-rouge">parse.y</code>. It’s just a set of procedures that I turned into a few structs and interfaces.</p>

<p>But as some of you know, MRI’s parser is compiled using <code class="language-plaintext highlighter-rouge">bison</code> (or <code class="language-plaintext highlighter-rouge">yacc</code> if you care about licenses). Bison is an LALR(1) parser generator, short summary:</p>

<ol>
  <li>you write a <code class="language-plaintext highlighter-rouge">.y</code> file using bison’s DSL, with some interpolations in your programming language</li>
  <li>this file defines rules on how you want your language constructions to be reduced (or combined)</li>
  <li>then you convert it to <code class="language-plaintext highlighter-rouge">.{ext}</code> file where <code class="language-plaintext highlighter-rouge">ext</code> is what your language uses. done</li>
</ol>

<p>Unfortunately, bison supports only C/C++/Java/D.</p>

<p>First I looked at what’s available in the world of Rust. The most popular LALR parser generator is called <a href="https://github.com/lalrpop/lalrpop"><code class="language-plaintext highlighter-rouge">lalrpop</code></a> and I was very about it at the very beginning, I think has a very, very beautiful API:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pub Term: i32 = {
    &lt;n:Num&gt; =&gt; n,
    "(" &lt;t:Term&gt; ")" =&gt; t,
};

Num: i32 = &lt;s:r"[0-9]+"&gt; =&gt; i32::from_str(s).unwrap();
</code></pre></div></div>

<p>Plus, it’s written in Rust, so to compile a grammar that is based on it you don’t anything except Rust (that you need anyway to compile something written in Rust, right?).</p>

<p>Unfortunately, I’ve got a few reasons to abandon this idea:</p>

<ol>
  <li>
    <p>No mid-rules (that are used A LOT in MRI) like</p>

    <p><code class="language-plaintext highlighter-rouge">foo: bar { /* do something */ } baz { /* reduce */ }</code></p>

    <p>I guess it’s possible to emulate them by introducing rules like</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bar_with_mid_rule: bar { /* do something */ }
 foo: bar_with_mid_rule baz { /* reduce */ }
</code></pre></div>    </div>
    <p>but then I have no idea how such grammar can be maintained.</p>
  </li>
  <li>Compilation speed. I’ve got ~20% of Ruby grammar backported and noticed a huge performance degradation.</li>
  <li>No stack introspection (and IIRC no “debug” mode at all). By saying “stack” here I mean parser stack, that’s a feature of LR parsers. You can check how it looks like by running <code class="language-plaintext highlighter-rouge">ruby -ye '42'</code> locally</li>
  <li>The grammar written with <code class="language-plaintext highlighter-rouge">lalrpop</code> has a different format comparing to bison, and so maintaining it (like backporting new changed from MRI) seems to be a nightmare.</li>
</ol>

<p>But then I realized that Bison has a feature called “custom skeleton”. It’s like a custom Bison template that you can use to convert <code class="language-plaintext highlighter-rouge">.y</code> to your format, and it “takes” all the data (like token/transition tables) as an argument when called.</p>

<p>So I wrote my own skeleton for Rust and wrapped it into a <a href="https://github.com/iliabylich/rust-bison-skeleton">Rust library</a>. It uses m4 format that is a macro language. Here’s <a href="https://github.com/iliabylich/rust-bison-skeleton/blob/master/rust-bison-skeleton/bison/lalr1-rust.m4">the main file</a> and <a href="https://github.com/iliabylich/rust-bison-skeleton/blob/master/tests/src/calc.y">an example</a> of how it can be used.</p>

<p>And then it took me about a week to backport the entire parser. The stack of it is a wrapper around <code class="language-plaintext highlighter-rouge">Vec&lt;Value&gt;</code> where <code class="language-plaintext highlighter-rouge">Value</code> is an enum type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Value</span> <span class="p">{</span>
    <span class="n">Stolen</span><span class="p">,</span>
    <span class="n">Uninitialized</span><span class="p">,</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Token</span><span class="p">(</span><span class="n">Token</span><span class="p">),</span>
    <span class="nf">TokenList</span><span class="p">(</span><span class="n">TokenList</span><span class="p">),</span>
    <span class="nf">Node</span><span class="p">(</span><span class="n">Node</span><span class="p">),</span>
    <span class="nf">NodeList</span><span class="p">(</span><span class="n">NodeList</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
    <span class="nf">MaybeStrTerm</span><span class="p">(</span><span class="n">MaybeStrTerm</span><span class="p">),</span>
    <span class="nf">Num</span><span class="p">(</span><span class="nb">Num</span><span class="p">),</span>

    <span class="cm">/* For custom superclass rule */</span>
    <span class="nf">Superclass</span><span class="p">(</span><span class="n">Superclass</span><span class="p">),</span>

    <span class="c1">// ... variants for other custom rules, there are ~25 of them</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Initially result of each “reduce” action (that is stored in <code class="language-plaintext highlighter-rouge">yyval</code> variable) is set to <code class="language-plaintext highlighter-rouge">Value::Uninitialized</code>, reading <code class="language-plaintext highlighter-rouge">$&lt;Node&gt;5</code> in your action is compiled into something like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="n">yystack</span><span class="nf">.steal_value_at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
  <span class="nn">Value</span><span class="p">::</span><span class="nf">Node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">node</span><span class="p">,</span>
  <span class="n">other</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"not a node: {:?}"</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Doing <code class="language-plaintext highlighter-rouge">$$ = ...</code> is compiled into <code class="language-plaintext highlighter-rouge">yyval = ...</code>.</p>

<p>Why does reading “steal” the value from the stack? Because you can do <code class="language-plaintext highlighter-rouge">$$ = $&lt;Node&gt;1</code> and push an element of the vector to the same vector. At the same time you can do something like <code class="language-plaintext highlighter-rouge">$$ = combine($&lt;Node&gt;1, $&lt;Node&gt;1)</code> where you want both arguments to be mutable. You can’t do it in Rust.</p>

<p>This is why when you read any stack value you actually steal it by replacing what’s in the stack with <code class="language-plaintext highlighter-rouge">Value::Stolen</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Stack</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">fn</span> <span class="nf">steal_value_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.stack</span><span class="nf">.len</span><span class="p">();</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.stack</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="nn">Value</span><span class="p">::</span><span class="n">Stolen</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Value::Stolen</code> is just a placeholder value that indicates (when you see it) that your code previously has accessed the same stack entry. It’s necessary to have it (or in general some kind of a default value that is set by <code class="language-plaintext highlighter-rouge">std::mem::take/replace</code>) to “fix” ownership model.</p>

<p>So then it was done and I started profiling it. At the very beginning it was incredibly slow, but I knew it, I had way too many <code class="language-plaintext highlighter-rouge">.clone()</code> calls in my code (in Rust that’s a deep clone that is quite expensive in some cases). I added jemalloc and started profiling (<code class="language-plaintext highlighter-rouge">pprof-rs</code> &lt;3), I removed most clones and got ~160-170K LOC/s.</p>

<p>Great, but I wanted more. ~20% of time in my benchmark was spent on this <code class="language-plaintext highlighter-rouge">std::mem::replace</code> call that swaps non-overlapping bytes. Initially I thought that I can’t improve it (that’s the fastest way to take the value AND to put a placeholder instead of it). At some point when I was writing C++ bindings I noticed that <code class="language-plaintext highlighter-rouge">sizeof(Node)</code> is 120 bytes (<code class="language-plaintext highlighter-rouge">Node</code> here is a C++ <code class="language-plaintext highlighter-rouge">Node</code> class) and it literally opened my eyes.</p>

<p>I’ll write it in C, take a look at this structure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="cm">/* variants */</span> <span class="p">}</span> <span class="n">variant</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Args</span> <span class="n">args</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">Def</span> <span class="n">def</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">IfTernary</span> <span class="n">if_ternary</span><span class="p">,</span>
        <span class="c1">// .. all other variant values</span>
    <span class="p">}</span> <span class="n">variant_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">IfTernary</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">cond</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">if_true</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">if_false</span><span class="p">;</span>
    <span class="c1">// .. a few more Range field, snip</span>
<span class="p">};</span>
</code></pre></div></div>

<p>(Let’s pretend that it can be compiled without forward declarations). This C <code class="language-plaintext highlighter-rouge">Node</code> is very, very similar to its Rust analogue. What’s the size of this <code class="language-plaintext highlighter-rouge">Node</code>?</p>

<p>The size of <code class="language-plaintext highlighter-rouge">struct</code> is a sum of all of its nodes (let’s simplify it and forget about memory alignment), the size of <code class="language-plaintext highlighter-rouge">union</code> is a maximum values its variant sizes.</p>

<p>Some specific node structures have multiple fields inside that are pointers (8 bytes on x86-64), and so the size of the generic <code class="language-plaintext highlighter-rouge">Node</code> is huge too.</p>

<p>Let’s “swap” pointers and unions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="cm">/* variants */</span> <span class="p">}</span> <span class="n">variant</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">Def</span> <span class="o">*</span><span class="n">def</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">IfTernary</span> <span class="p">(</span><span class="n">if_ternary</span><span class="p">,</span>
        <span class="c1">// .. all other variant values</span>
    <span class="p">}</span> <span class="n">variant_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">IfTernary</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="n">cond</span><span class="p">;</span>
    <span class="n">Node</span> <span class="n">if_true</span><span class="p">;</span>
    <span class="n">Node</span> <span class="n">if_false</span><span class="p">;</span>
    <span class="c1">// .. a few more Range field, snip</span>
<span class="p">};</span>
</code></pre></div></div>

<p>See? Now the size of the <code class="language-plaintext highlighter-rouge">union</code> is always <code class="language-plaintext highlighter-rouge">sizeof(void*)</code> and so <code class="language-plaintext highlighter-rouge">Node</code> is much smaller.</p>

<p>Why does it matter? Because <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> in Rust is a wrapper for <code class="language-plaintext highlighter-rouge">*T</code> array. It’s a contiguous and “flat” region of memory where all elements are “inlined”:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|</span><span class="n">item1</span><span class="o">|</span><span class="n">item2</span><span class="o">|</span><span class="n">item3</span><span class="o">|</span><span class="n">item4</span><span class="o">|</span><span class="p">...</span>
</code></pre></div></div>

<p>and every item takes <code class="language-plaintext highlighter-rouge">sizeof(T)</code> memory. This is why doing <code class="language-plaintext highlighter-rouge">std::mem::replace(t1, t2)</code> can swap at most <code class="language-plaintext highlighter-rouge">sizeof(T)</code> bytes and this is why I want <code class="language-plaintext highlighter-rouge">T</code> to be as small as possible.</p>

<p>After turning my Rust model into</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="nf">Args</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">IfTernary</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">IfTernary</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="cd">/// ...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">IfTernary</span> <span class="p">{</span>
    <span class="n">cond</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">if_true</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">if_false</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// other variants</span>
</code></pre></div></div>

<p>I’ve got the same performance as Ripper.</p>

<h2 id="future-improvements">Future improvements</h2>

<p>I keep thinking about turning <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> into zero copy parser and I’m believe it’s very possible.</p>

<p>Currently all “values” that copy from source code (like numeric/string literals, token values) are copied into tokens and AST nodes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"42"

tokens:
    Token { name: "tINTEGER", value: "42", loc: 0...2 }

nodes:
    Int { value: "42", expression_l: 0..2 }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> constructs these <code class="language-plaintext highlighter-rouge">"42"</code> strings twice by copying a part of the input. Of course, for this particular case it’s possible to store only ranges like <code class="language-plaintext highlighter-rouge">start...end</code>, but there are exceptions where values of tokens and AST nodes are not equal to input substrings (like escape sequences, <code class="language-plaintext highlighter-rouge">"\n"</code> or <code class="language-plaintext highlighter-rouge">"\u1234"</code>).</p>

<p>Even this way it’s possible to introduce the following type system:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Value</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">SubstringOfInput</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]),</span>
    <span class="nf">ManuallyConstructed</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first variant is a reference, the latter is owned. Total value (of both token and AST node) could be just a vector of such enums, and if you parse a string <code class="language-plaintext highlighter-rouge">"foo\n"</code> you’ll get</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tokens:
    Token {
        name: "tSTRING_CONTENT",
        value: vec![
            Value::SubstringOfInput(&amp;input[1..3]),
            Value::ManuallyConstructed(vec![b'\n'])
        ],
        loc: 1..5
    }
</code></pre></div></div>

<p>However, then <code class="language-plaintext highlighter-rouge">input</code> must live as long as tokens and AST, and it sounds a bit problematic.</p>

<p>One option that I see is adding <code class="language-plaintext highlighter-rouge">Rc&lt;Input&gt;</code> to such values and store a range in <code class="language-plaintext highlighter-rouge">SubstringOfInput</code> enum variant. That’s basicaly a <code class="language-plaintext highlighter-rouge">shared_ptr</code> from C++ world that wraps a raw pointer (like <code class="language-plaintext highlighter-rouge">T*</code>) + (pointer to) a number of existing “clones” of this pointer. Every time you copy it the shared number is incremented, destructor decreases it and once it’s zero it also deletes <code class="language-plaintext highlighter-rouge">T</code>. It’s quite cheap in terms of performance (something like <code class="language-plaintext highlighter-rouge">*n += 1</code> in constructor, <code class="language-plaintext highlighter-rouge">*n -= 1; drop(ptr) if n == 0;</code> in destructor)</p>

<h2 id="c-bindings">C bindings</h2>

<p>GitHub repo - <a href="https://github.com/lib-ruby-parser/c-bindings">https://github.com/lib-ruby-parser/c-bindings</a></p>

<p>It took me a while to fix all segfaults, memory leaks and invalid memory access patterns (I’m not a C developer). <code class="language-plaintext highlighter-rouge">Valgrind</code> and <code class="language-plaintext highlighter-rouge">asan</code> are incredibly useful tools, I can’t even imagine how much time it would take to write bindings without these guys.</p>

<p>The API is very similar, there’s an additional layer between C and Rust that converts output of <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> into C structures.</p>

<p>It uses a combination of <code class="language-plaintext highlighter-rouge">enum</code> and <code class="language-plaintext highlighter-rouge">union</code> to represent a <code class="language-plaintext highlighter-rouge">Node</code>.</p>

<h2 id="cpp-bindings">Cpp bindings</h2>

<p><a href="https://github.com/lib-ruby-parser/cpp-bindings">https://github.com/lib-ruby-parser/cpp-bindings</a></p>

<p>I personally like C++ much more than C. Smart pointers, containers, generics, but still worse for me than Rust. Upcoming standards are going to introduce even more features like modules and concepts, but, no.</p>

<p>The same story again, <code class="language-plaintext highlighter-rouge">valgrind</code>/<code class="language-plaintext highlighter-rouge">asan</code>, an extra layer that converts <code class="language-plaintext highlighter-rouge">Rust</code> objects to <code class="language-plaintext highlighter-rouge">C++</code> classes.</p>

<p>Also, my <code class="language-plaintext highlighter-rouge">valgrind</code> on Mac couldn’t detect calling <code class="language-plaintext highlighter-rouge">free</code> on <code class="language-plaintext highlighter-rouge">C++</code> object (that’s invalid, should be <code class="language-plaintext highlighter-rouge">delete</code> from C++), and so I had to setup a docker container locally to find and fix it.</p>

<p>It uses modern <code class="language-plaintext highlighter-rouge">std::variant&lt;Nodes...&gt;</code> to represent a <code class="language-plaintext highlighter-rouge">Node</code>.</p>

<h2 id="node-bindings">Node bindings</h2>

<p>As a proof of concept I also created bindings for Node.js - <a href="https://github.com/lib-ruby-parser/node-bindings">https://github.com/lib-ruby-parser/node-bindings</a>.</p>

<p>I was actually impressed (in a good way) how elegant is the API of <code class="language-plaintext highlighter-rouge">node-addon-api</code>. I worked with V8 C++ API about a 10 months ago in Electron and back in the day it was quite verbose and painful. Also, I remember an interesting feature of <code class="language-plaintext highlighter-rouge">TryCatch</code> class:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TryCatch</span> <span class="n">trycatch</span><span class="p">;</span>
    <span class="c1">// do something that potentially does `throw err`</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">trycatch</span><span class="p">.</span><span class="n">HasCaught</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// process trycatch.Exception() value</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I personally think that this class abuses constructors/destructors in C++:</p>

<ul>
  <li>constructor of <code class="language-plaintext highlighter-rouge">TryCatch</code> registers <code class="language-plaintext highlighter-rouge">this</code> in some global context  (like <code class="language-plaintext highlighter-rouge">GetCurrentHandleScope().SetThrowHandler(this)</code></li>
  <li>any code that throws a JavaScript error sets it on this <code class="language-plaintext highlighter-rouge">TryCatch</code> handler</li>
  <li>it’s possible to access an exception object from any place</li>
  <li>destructor of <code class="language-plaintext highlighter-rouge">TryCatch</code> un-registers it</li>
</ul>

<p>I admit that it’s smart, but it sounds way too implicit to me. I’d like this interface to perform a register in a more explicit way (by calling <code class="language-plaintext highlighter-rouge">register/unregsiter</code> for example).</p>

<p>And I like that <code class="language-plaintext highlighter-rouge">node-addon-api</code> handles it <a href="https://github.com/nodejs/node-addon-api/blob/master/doc/error_handling.md#handling-a-n-api-c-exception">even better</a> by sticking to C++ exceptions.</p>

<p>Node.js bindings are based on C++ bindings from the previous section and they use a custom JavaScript class for each node type. Yes, there’s also an extra layer that converts C++ objects to JavaScript.</p>

<h2 id="wasm">WASM</h2>

<p>Rust can be compiled to WebAssembly, here’s a demo - <a href="https://lib-ruby-parser.github.io/wasm-bindings">https://lib-ruby-parser.github.io/wasm-bindings</a>.</p>

<p>It worked out of the box with one minor change. I had to mark <code class="language-plaintext highlighter-rouge">onigurama</code> dependency as optional and disable it for WASM build. Oh, I love how Rust can turn dependency into a feature that is optional and enabled/disabled by default as you configure it.</p>

<h2 id="final-thoughts">Final thoughts</h2>

<p>This is one of the biggest open-source projects that I’ve ever made. It can be used from Rust/C/C++/Node.js/browser. It’s fast (but remember, it can get even faster), it’s precise and it’s very strongly typed.</p>

<p>Also, if you need a custom setup (like custom C++ classes or maybe a completely different API) there’s a <a href="https://github.com/lib-ruby-parser/nodes">meta-repository</a> with all nodes information. You can use it to build your own bindings (or maybe new bindings for other languages), it has a <code class="language-plaintext highlighter-rouge">nodes</code> function that returns a <code class="language-plaintext highlighter-rouge">Vec&lt;Node&gt;</code> (<code class="language-plaintext highlighter-rouge">Node</code> here is just a “configuration” of a single <code class="language-plaintext highlighter-rouge">Node</code> variant from Rust - <a href="https://github.com/lib-ruby-parser/nodes/blob/master/src/node.rs#L6">source</a>)</p>

<p>Bindings still have a room for improvements (for example, there’s no way to pass custom <code class="language-plaintext highlighter-rouge">ParserOptions</code> to the parser), and current version of <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> is <code class="language-plaintext highlighter-rouge">0.7.0</code>.</p>

<p>However, I think it’s ready. It’s stable and I’m not going to introduce any major changes anymore. I’m going to cut <code class="language-plaintext highlighter-rouge">3.0.0</code> once Ruby 3 is released. Don’t hesitate to drop me a message if it works well for you.</p>]]></content><author><name></name></author><category term="ruby" /><category term="parser" /><category term="rust" /><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">Evaluating Ruby in Ruby</title><link href="https://iliabylich.github.io/2020/01/25/evaluating-ruby-in-ruby.html" rel="alternate" type="text/html" title="Evaluating Ruby in Ruby" /><published>2020-01-25T21:00:00+00:00</published><updated>2020-01-25T21:00:00+00:00</updated><id>https://iliabylich.github.io/2020/01/25/evaluating-ruby-in-ruby</id><content type="html" xml:base="https://iliabylich.github.io/2020/01/25/evaluating-ruby-in-ruby.html"><![CDATA[<h1 id="evaluating-ruby-in-ruby">Evaluating Ruby in Ruby</h1>

<h3 id="tldr">TLDR</h3>

<p>This article is about instruction sequences and evaluating them using pure Ruby.</p>

<p>The repo is available <a href="https://github.com/iliabylich/my.rb">here</a>.</p>

<blockquote>
  <p>Is it a Ruby implementation?</p>
</blockquote>

<p>No. It’s just a runner of instructions. It is similar to MRI’s virtual machine, but it lacks many features and it’s 100x slower.</p>

<blockquote>
  <p>Can I use it in my applications?</p>
</blockquote>

<p>Of course, no. Well, if you want.</p>

<blockquote>
  <p>Does it work at all?</p>
</blockquote>

<p>Yes, and it even passes most language specs from RubySpec test suite.</p>

<h3 id="how-ruby-evaluates-your-code">How Ruby evaluates your code.</h3>

<p>Well, I think I should start with explaining basics. There is a plenty of articles about it, so I’ll be short:</p>

<ol>
  <li>First, Ruby parses your code into AST (<code class="language-plaintext highlighter-rouge">parse.y</code>)</li>
  <li>Then, it compiles it into instruction sequence (<code class="language-plaintext highlighter-rouge">compile.c</code>)</li>
  <li>And every time when you let’s say call a method it evaluates these instructions. (<code class="language-plaintext highlighter-rouge">insn.def</code>, <code class="language-plaintext highlighter-rouge">vm_eval.c</code>, <code class="language-plaintext highlighter-rouge">vm_insnhelper.c</code>)</li>
</ol>

<p>Long time ago there was no YARV and Ruby used to evaluate AST.</p>

<p><code class="language-plaintext highlighter-rouge">1+2</code> is just a small syntax tree with a <code class="language-plaintext highlighter-rouge">send</code> node in the root and two children: <code class="language-plaintext highlighter-rouge">int(1)</code> and <code class="language-plaintext highlighter-rouge">int(2)</code>. To evaluate it you need to “traverse” it by walking down recursively. Primitive nodes are getting substituted with values (integers 1 and 2 respectively), <code class="language-plaintext highlighter-rouge">send</code> node calls <code class="language-plaintext highlighter-rouge">+</code> on pre-reduced children and returns <code class="language-plaintext highlighter-rouge">3</code>.</p>

<p>On the other side, YARV is a stack-based Virtual Machine (VM) that evaluates an assembly-like language that consist of more than 100 predefined instructions that store their input/output values on the VM’s stack.</p>

<p>These instructions have arguments, some of them are primitive values, some are inlined Ruby objects, some are flags.</p>

<p>You can view these instructions by running Ruby with <code class="language-plaintext highlighter-rouge">--dump=insns</code> flag:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="o">--</span><span class="n">dump</span><span class="o">=</span><span class="n">insns</span> <span class="o">-</span><span class="n">e</span> <span class="s1">'puts 2 + 3'</span>
<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
<span class="mo">0000</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0001</span> <span class="n">putobject</span>                    <span class="mi">2</span>
<span class="mo">0003</span> <span class="n">putobject</span>                    <span class="mi">3</span>
<span class="mo">0005</span> <span class="n">opt_plus</span>                     <span class="o">&lt;</span><span class="n">callinfo!mid</span><span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">callcache</span><span class="o">&gt;</span>
<span class="mo">000</span><span class="mi">8</span> <span class="n">opt_send_without_block</span>       <span class="o">&lt;</span><span class="n">callinfo!mid</span><span class="ss">:puts</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">callcache</span><span class="o">&gt;</span>
<span class="mo">0011</span> <span class="n">leave</span>
</code></pre></div></div>

<p>As you can see, there are 5 instructions:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">putself</code> - pushes <code class="language-plaintext highlighter-rouge">self</code> at the top of the stack</li>
  <li><code class="language-plaintext highlighter-rouge">putobject</code> - pushes given object (numbers 2 an 3)</li>
  <li><code class="language-plaintext highlighter-rouge">opt_plus</code> - optimized instruction for <code class="language-plaintext highlighter-rouge">+</code> method</li>
  <li><code class="language-plaintext highlighter-rouge">opt_send_without_block</code> - optimized instruction for a generic method call without block</li>
  <li><code class="language-plaintext highlighter-rouge">leave</code> - an equivalent of <code class="language-plaintext highlighter-rouge">return</code></li>
</ol>

<h3 id="the-structure-of-the-instruction-sequence-iseq">The structure of the instruction sequence (ISeq)</h3>

<p>Let’s start with the example above.</p>

<p>MRI has an API to compile an arbitrary code into instructions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"2+3"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">[</span><span class="s2">"YARVInstructionSequence/SimpleDataFormat"</span><span class="p">,</span>
 <span class="mi">2</span><span class="p">,</span>
 <span class="mi">6</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="p">{</span><span class="ss">:arg_size</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
  <span class="ss">:local_size</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
  <span class="ss">:stack_max</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span>
  <span class="ss">:node_id</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span>
  <span class="ss">:code_location</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="ss">:top</span><span class="p">,</span>
 <span class="p">[],</span>
 <span class="p">{},</span>
 <span class="p">[],</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:opt_plus</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">16</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]</span>
</code></pre></div></div>

<p>Our code gets compiled into an array where:</p>

<ul>
  <li>The first element returns the type of the instruction sequence</li>
  <li>Then comes <code class="language-plaintext highlighter-rouge">MAJOR</code>/<code class="language-plaintext highlighter-rouge">MINOR</code>/<code class="language-plaintext highlighter-rouge">PATCH</code> parts of the Ruby version that was used to compile it</li>
  <li>Then comes the hash with a meta information about this iseq</li>
  <li>Then comes relative/full/some other file name. It is possible to override them similar to passing <code class="language-plaintext highlighter-rouge">file/line</code> arguments to <code class="language-plaintext highlighter-rouge">{class,module}_eval</code> (<code class="language-plaintext highlighter-rouge">Object.module_eval("[__FILE__, __LINE__]", '(file)', 42)</code>)</li>
  <li>Then comes the line where the code begins (1 by default)</li>
  <li>Then comes the type of the iseq (<code class="language-plaintext highlighter-rouge">:top</code> here means the code was parsed and compiled as a top-level block of code)</li>
  <li>Then we have a few empty arrays and hashes (we will return to them later)</li>
  <li>And the last item is an array of instructions</li>
</ul>

<p>Each instruction is either:</p>

<ul>
  <li>a number</li>
  <li>a special symbol</li>
  <li>or an array</li>
</ul>

<p>Only arrays are “real” instructions, numbers and symbols are special debug entries that are used internally by the VM. In our case a number followed by the <code class="language-plaintext highlighter-rouge">:RUBY_EVENT_LINE</code> is a mark that MRI uses to know what is the number of the line that is currently being interpreted (for example, all backtrace entries include these numbers)</p>

<h3 id="building-a-poc">Building a PoC</h3>

<p>How can we evaluate instructions above? Well, we definitely need a stack:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$stack</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<p>Then, we need to iterate over instructions (the last item of the iseq) and evaluate them one by one. We could write a giant <code class="language-plaintext highlighter-rouge">case-when</code>, but I promise that it won’t fit on 10 screens. Let’s use some meta-programming and dynamic dispatching:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span>
  <span class="nb">name</span><span class="p">,</span> <span class="o">*</span><span class="n">payload</span> <span class="o">=</span> <span class="n">insn</span>
  <span class="nb">send</span><span class="p">(</span><span class="ss">:"execute_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="ss">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This way we need to write a method per instruction type, let’s start with <code class="language-plaintext highlighter-rouge">putobject</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_putobject</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="vg">$stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_opt_plus</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="vg">$stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="vg">$stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="vg">$stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_leave</span>
  <span class="c1"># nothing here so far</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This code is enough to get <code class="language-plaintext highlighter-rouge">5</code> in the stack once it’s executed. Here’s the runner:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iseq</span> <span class="o">=</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"2+3"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="n">insns</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">[</span><span class="mi">13</span><span class="p">].</span><span class="nf">grep</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span> <span class="c1"># ignore numbers and symbols for now</span>
<span class="n">insns</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">insn</span><span class="o">|</span> <span class="n">execute_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="p">}</span>
<span class="n">pp</span> <span class="vg">$stack</span>
</code></pre></div></div>

<p>You should see <code class="language-plaintext highlighter-rouge">[5]</code>.</p>

<p>All instructions above simply pull some values from the stack, do some computations and push the result back.</p>

<h3 id="self">Self</h3>

<p>Let’s think about <code class="language-plaintext highlighter-rouge">self</code> for a minute:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"self"</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span> <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span> <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">self</code> is stored somewhere internally, and even more, it’s dynamic:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="nb">self</span>
<span class="k">class</span> <span class="nc">X</span>
  <span class="nb">puts</span> <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The first <code class="language-plaintext highlighter-rouge">puts self</code> prints <code class="language-plaintext highlighter-rouge">main</code>, while the second one prints <code class="language-plaintext highlighter-rouge">X</code>.</p>

<p>Here comes the concept of frames.</p>

<h3 id="frames">Frames</h3>

<p>Frame is an object inside the virtual machine that represents a closure. Or a <code class="language-plaintext highlighter-rouge">binding</code>. It’s an isolated “world” with its own set of locals, its own <code class="language-plaintext highlighter-rouge">self</code>, its own <code class="language-plaintext highlighter-rouge">file</code>/<code class="language-plaintext highlighter-rouge">line</code> information, it’s own <code class="language-plaintext highlighter-rouge">rescue</code> and <code class="language-plaintext highlighter-rouge">ensure</code> handlers etc.</p>

<p>Frame also has a type:</p>

<ol>
  <li>it can be a <code class="language-plaintext highlighter-rouge">top</code> frame that wraps all the code in your file. All variables set in the global scope of your file belong to the top frame. Each parsed and evaluated file creates its own top frame.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">method</code> frame. All methods create it. One method frame per one method call.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">block</code> frame. All blocks and lambdas create it. One block frame per one block call.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">class</code> frame, however it doesn’t mean that instantiating a class creates it. The whole <code class="language-plaintext highlighter-rouge">class X; ... end</code> does it. Later when you do <code class="language-plaintext highlighter-rouge">X.new</code> Ruby doesn’t create any <code class="language-plaintext highlighter-rouge">class</code> frames. This frame represents a class definition.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">rescue</code> frame that represents a code inside <code class="language-plaintext highlighter-rouge">rescue =&gt; e; &lt;...&gt;; end</code> block</li>
  <li>it can be an <code class="language-plaintext highlighter-rouge">ensure</code> frame (well, I’m sure you get it)</li>
  <li>there are also <code class="language-plaintext highlighter-rouge">module</code> (for a module body), <code class="language-plaintext highlighter-rouge">sclass</code> (for a singleton class) and a very unique <code class="language-plaintext highlighter-rouge">eval</code> frame.</li>
</ol>

<p>And they are stored internally as a stack.</p>

<p>When you invoke <code class="language-plaintext highlighter-rouge">caller</code> method you see this stack (or some information based on it). Each entry in the error backtrace is based on the state of this stack when the error is thrown.</p>

<p>OK, let’s write some code to extend our VM:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrameClass</span>
  <span class="no">COMMON_FRAME_ATTRIBUTES</span> <span class="o">=</span> <span class="sx">%i[
    _self
    nesting
    locals
    file
    line
    name
  ]</span><span class="p">.</span><span class="nf">freeze</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="o">*</span><span class="no">COMMON_FRAME_ATTRIBUTES</span><span class="p">,</span>
      <span class="o">*</span><span class="n">arguments</span><span class="p">,</span>
      <span class="ss">keyword_init: </span><span class="kp">true</span>
    <span class="p">)</span> <span class="k">do</span>
      <span class="nb">class_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>

      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">:,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">allocate</span>

        <span class="n">instance</span><span class="p">.</span><span class="nf">file</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">file</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">line</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">line</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">name</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">locals</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:initialize</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

        <span class="n">instance</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I like builders and I don’t like inheritance (the fact that frames share some common attributes doesn’t mean that they should be inherited from an <code class="language-plaintext highlighter-rouge">AbstractFrame</code> class; also I don’t like abstract classes, they are dead by definition)</p>

<p>Here’s the first version of the <code class="language-plaintext highlighter-rouge">TopFrame</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">TopFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">**</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="no">TOPLEVEL_BINDING</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'self'</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="p">[</span><span class="no">Object</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty_name</span>
    <span class="s2">"TOP </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s walk through the code:</p>

<ol>
  <li>each frame has a common set of attributes:</li>
  <li><code class="language-plaintext highlighter-rouge">_self</code> - what <code class="language-plaintext highlighter-rouge">self</code> returns inside the frame</li>
  <li><code class="language-plaintext highlighter-rouge">nesting</code> - what <code class="language-plaintext highlighter-rouge">Module.nesting</code> returns (used for the relative constant lookup)</li>
  <li><code class="language-plaintext highlighter-rouge">locals</code> - a set of local variables</li>
  <li><code class="language-plaintext highlighter-rouge">file</code> and <code class="language-plaintext highlighter-rouge">line</code> - currently running <code class="language-plaintext highlighter-rouge">__FILE__:__LINE__</code></li>
  <li><code class="language-plaintext highlighter-rouge">name</code> - a human-readable name of the frame, we will use it mostly for debugging</li>
  <li><code class="language-plaintext highlighter-rouge">FrameClass</code> is a builder that is capable of building a custom <code class="language-plaintext highlighter-rouge">Frame</code> class (similar to <code class="language-plaintext highlighter-rouge">Struct</code> class)</li>
  <li><code class="language-plaintext highlighter-rouge">FrameClass.new</code> takes:</li>
  <li>a list of custom frame-class-specific attributes</li>
  <li>and a block that is evaluated in a context of the created frame class</li>
</ol>

<p>So, the <code class="language-plaintext highlighter-rouge">TopFrame</code> class is a <code class="language-plaintext highlighter-rouge">Struct</code>-like class that:</p>

<ol>
  <li>has a constructor that takes <strong>only</strong> common attributes (because we haven’t specified any in <code class="language-plaintext highlighter-rouge">FrameClass.new</code>)</li>
  <li>has a custom behavior in the constructor that sets <code class="language-plaintext highlighter-rouge">_self</code> and <code class="language-plaintext highlighter-rouge">nesting</code></li>
  <li>has a custom <code class="language-plaintext highlighter-rouge">pretty_name</code> instance method</li>
</ol>

<p>We will create as many classes as we need to cover all kinds of frames (I will return to it later, I promise)</p>

<h3 id="wrapping-the-iseq">Wrapping the ISeq</h3>

<p>I don’t like working with plain arrays, and as I mentioned above there’s a ton of useful information in the instruction sequence that we get from <code class="language-plaintext highlighter-rouge">RubyVM::InstructionSequence.compile("code").to_a</code>.</p>

<p>Let’s create a wrapper that knows the meaning of array items:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ISeq</span>
  <span class="nb">attr_reader</span> <span class="ss">:insns</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ruby_iseq</span><span class="p">)</span>
    <span class="vi">@ruby_iseq</span> <span class="o">=</span> <span class="n">ruby_iseq</span>
    <span class="vi">@insns</span> <span class="o">=</span> <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">13</span><span class="p">].</span><span class="nf">dup</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">file</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">line</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">kind</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">lvar_names</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">args_info</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Instance methods are self-descriptive, but just in case:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">file</code>/<code class="language-plaintext highlighter-rouge">line</code> return file/line where the iseq has been created</li>
  <li><code class="language-plaintext highlighter-rouge">kind</code> returns a Symbol that we will later use to distinguish frames (<code class="language-plaintext highlighter-rouge">:top</code> for a <code class="language-plaintext highlighter-rouge">TopFrame</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">insns</code> returns a list of instructions</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> is an internal name of the frame that is used in backtraces (for <code class="language-plaintext highlighter-rouge">class X; end</code> it returns <code class="language-plaintext highlighter-rouge">&lt;class:X&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">lvar_names</code> is an array of all local variable names that are used in the frame</li>
  <li><code class="language-plaintext highlighter-rouge">args_info</code> is a special Hash with a meta-information about arguments (empty for all frames except methods)</li>
</ol>

<h3 id="frame-stack">Frame stack</h3>

<p>Frames are organized as a stack internally, every time when we enter a frame Ruby pushes it on a stack. When the frame ends (i.e. when its list of instruction ends or there’s a special <code class="language-plaintext highlighter-rouge">[:leave]</code> instruction) it pops it.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrameStack</span>
  <span class="nb">attr_reader</span> <span class="ss">:stack</span>

  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@stack</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">frame</span><span class="o">|</span> <span class="k">yield</span> <span class="n">frame</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="vi">@stack</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span>
    <span class="n">frame</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">push_top</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
    <span class="n">push</span> <span class="no">TopFrame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pop</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">top</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">last</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">size</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">empty?</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">empty?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Each entry in the stack is a frame that we entered at some point, so we can quickly build a <code class="language-plaintext highlighter-rouge">caller</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BacktraceEntry</span> <span class="o">&lt;</span> <span class="no">String</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">super</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">frame</span><span class="p">.</span><span class="nf">file</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">frame</span><span class="p">.</span><span class="nf">line</span><span class="si">}</span><span class="s2">:in `</span><span class="si">#{</span><span class="n">frame</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">stack</span> <span class="o">=</span> <span class="no">FrameStack</span><span class="p">.</span><span class="nf">new</span>
<span class="n">code</span> <span class="o">=</span> <span class="s1">'2 + 3'</span>
<span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s1">'test.rb'</span><span class="p">,</span> <span class="s1">'/path/to/test.rb'</span><span class="p">,</span> <span class="mi">42</span><span class="p">).</span><span class="nf">to_a</span><span class="p">)</span>

<span class="n">stack</span><span class="p">.</span><span class="nf">push_top</span><span class="p">(</span><span class="ss">iseq: </span><span class="n">iseq</span><span class="p">)</span>
<span class="nb">caller</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">frame</span><span class="o">|</span> <span class="no">BacktraceEntry</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="p">}.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">puts</span> <span class="nb">caller</span>
<span class="c1"># =&gt; "/path/to/test.rb:42: in `&lt;compiled&gt;'"</span>
</code></pre></div></div>

<h3 id="writing-the-evaluator">Writing the evaluator</h3>

<p>Let’s write it in a “script style” (it is simplified for a good reason, real code is much more complicated):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile_file</span><span class="p">(</span><span class="s1">'path/to/file.rb'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">)</span>
<span class="n">frame_stack</span> <span class="o">=</span> <span class="no">FrameStack</span><span class="p">.</span><span class="nf">new</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">frame_stack</span><span class="p">.</span><span class="nf">push_top</span><span class="p">(</span><span class="ss">iseq: </span><span class="n">iseq</span><span class="p">)</span>

<span class="k">until</span> <span class="n">frame_stack</span><span class="p">.</span><span class="nf">empty?</span>
  <span class="n">current_frame</span> <span class="o">=</span> <span class="n">frame_stack</span><span class="p">.</span><span class="nf">top</span>
  <span class="k">if</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="k">break</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">insns</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="n">frame_stack</span><span class="p">.</span><span class="nf">pop_frame</span>
    <span class="k">next</span>
  <span class="k">end</span>

  <span class="n">current_insn</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">insns</span><span class="p">.</span><span class="nf">shift</span>
  <span class="n">execute_insn</span><span class="p">(</span><span class="n">current_insn</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Generally speaking, the code above is the core of the VM. Once it’s executed both <code class="language-plaintext highlighter-rouge">frame_stack</code> and <code class="language-plaintext highlighter-rouge">stack</code> must be empty. I added a bunch of consistency checks in my implementation, but for the sake of simplicity I’m going to omit them here.</p>

<h3 id="instructions">Instructions</h3>

<p>I’ll try to be short here, there are about 100 instructions in Ruby, and some of them look similar.</p>

<h5 id="putself-putobject-putnil-putstring-putiseq"><code class="language-plaintext highlighter-rouge">putself</code>, <code class="language-plaintext highlighter-rouge">putobject</code>, <code class="language-plaintext highlighter-rouge">putnil</code>, <code class="language-plaintext highlighter-rouge">putstring</code>, <code class="language-plaintext highlighter-rouge">putiseq</code></h5>

<p>All of these guys push a simple object at the top of the stack. <code class="language-plaintext highlighter-rouge">putnil</code> pushes a known global <code class="language-plaintext highlighter-rouge">nil</code> object, others have an argument that is used in <code class="language-plaintext highlighter-rouge">stack.push(argument)</code></p>

<h5 id="optimized-instructions-like-opt_plus">optimized instructions like <code class="language-plaintext highlighter-rouge">opt_plus</code></h5>

<p>Ruby has a mode (that is turned on by default) that optimizes some frequently used method calls, like <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">.size</code>. It is possible to turn them off by manipulating <code class="language-plaintext highlighter-rouge">RubyVM::InstructionSequence.compile_option</code> (if you set <code class="language-plaintext highlighter-rouge">:specialized_instruction</code> to <code class="language-plaintext highlighter-rouge">false</code> you’ll get a normal method call instead of the specialized instruction).</p>

<p>All of them do one specific thing, here’s an example of the <code class="language-plaintext highlighter-rouge">opt_size</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_opt_size</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">pop</span><span class="p">.</span><span class="nf">size</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Of course we do it this way because we cannot optimize it. MRI does a different thing:</p>

<ol>
  <li>if there’s a string/array/hash on top of the stack</li>
  <li>and <code class="language-plaintext highlighter-rouge">String#size</code> (or <code class="language-plaintext highlighter-rouge">Array#size</code> if it’s an array) is not redefined</li>
  <li>then it <strong>directly</strong> calls a C method <code class="language-plaintext highlighter-rouge">rb_str_length</code> (or <code class="language-plaintext highlighter-rouge">RARRAY_LEN</code> if it’s an array)</li>
  <li>otherwise (if it’s an object of some other type or a method has been redefined) it calls a method through the regular method dispatch mechanism (which is obviously slower)</li>
</ol>

<p>We could do the same sequence of steps, but we can’t invoke a C method, and so calling a check + <code class="language-plaintext highlighter-rouge">.size</code> afterwards is even slower. It’s better for us to fall to the slow branch from the beginning.</p>

<p>You can print all available specialized instructions by running</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">RubyVM</span><span class="o">::</span><span class="no">INSTRUCTION_NAMES</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="sr">/\Aopt_/</span><span class="p">)</span>
</code></pre></div></div>

<p>On Ruby 2.6.4 there are 34 of them.</p>

<h5 id="opt_send_without_block-or-send-if-specialized-instructions-are-disabled"><code class="language-plaintext highlighter-rouge">opt_send_without_block</code> (or <code class="language-plaintext highlighter-rouge">send</code> if specialized instructions are disabled)</h5>

<p>This is an instruction that is used to invoke methods. <code class="language-plaintext highlighter-rouge">puts 123</code> looks like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="ss">:opt_send_without_block</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:puts</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">]</span>
</code></pre></div></div>

<p>It has 2 arguments:</p>

<ol>
  <li>a hash with options</li>
  <li><code class="language-plaintext highlighter-rouge">mid</code> - a method ID (method name)</li>
  <li><code class="language-plaintext highlighter-rouge">flag</code> - a bitmask with a metadata about the invocation</li>
  <li><code class="language-plaintext highlighter-rouge">orig_argc</code> - a number of arguments passed to a method call</li>
  <li>a boolean flag that is called <code class="language-plaintext highlighter-rouge">CALL_DATA</code> in C. I have no idea what it does</li>
</ol>

<p>Here’s the rough implementation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_opt_send_without_block</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:mid</span><span class="p">]</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So here we</p>

<ol>
  <li>take a method from the <code class="language-plaintext highlighter-rouge">options</code> hash (<code class="language-plaintext highlighter-rouge">mid</code>)</li>
  <li>then we pop N arguments from the stack (<code class="language-plaintext highlighter-rouge">args</code>)</li>
  <li>then we pop the receiver of the method (<code class="language-plaintext highlighter-rouge">recv</code>)</li>
  <li>then call <code class="language-plaintext highlighter-rouge">recv.send(mid, *args)</code> (in our case it’s <code class="language-plaintext highlighter-rouge">self.send(:puts, *[123])</code></li>
  <li>and then we push the result back to the stack</li>
</ol>

<h5 id="method-definition">method definition</h5>

<p>I intentionally started with method calls because Ruby defines methods via method calls. Yes.</p>

<p>Ruby has a special singleton object called <code class="language-plaintext highlighter-rouge">Frozen Core</code>. When you define a method via <code class="language-plaintext highlighter-rouge">def m; end</code> Ruby invokes <code class="language-plaintext highlighter-rouge">frozen_core.send("core#define_method", method_iseq)</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="o">--</span><span class="n">dump</span><span class="o">=</span><span class="n">insns</span> <span class="o">-</span><span class="n">e</span> <span class="s1">'def m; end'</span>
<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
<span class="mo">0000</span> <span class="n">putspecialobject</span>             <span class="mi">1</span>                                   <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0002</span> <span class="n">putobject</span>                    <span class="ss">:m</span>
<span class="mo">0004</span> <span class="n">putiseq</span>                      <span class="n">m</span>
<span class="mo">0006</span> <span class="n">opt_send_without_block</span>       <span class="o">&lt;</span><span class="n">callinfo!mid</span><span class="ss">:core</span><span class="c1">#define_method, argc:2, ARGS_SIMPLE&gt;, &lt;callcache&gt;</span>
<span class="mo">000</span><span class="mi">9</span> <span class="n">leave</span>
</code></pre></div></div>

<p>The object itself is defined <a href="https://github.com/ruby/ruby/blob/beae6cbf0fd8b6619e5212552de98022d4c4d4d4/vm.c#L2983-L2996">here</a>.</p>

<p>Of course, we don’t have access to the Frozen Core. But we have an instruction that pushes it at the top of the stack. We can create our own <code class="language-plaintext highlighter-rouge">FrozenCore = Object.new.freeze</code> and check if <code class="language-plaintext highlighter-rouge">recv</code> is equal to this frozen core.</p>

<p>As you may notice there are also <code class="language-plaintext highlighter-rouge">putobject :m</code> and <code class="language-plaintext highlighter-rouge">putiseq</code> instructions. And argc of the method call is 2. Hmmm.</p>

<p><code class="language-plaintext highlighter-rouge">core#define_method</code> takes two arguments:</p>

<ol>
  <li>a method name that is pushed by a <code class="language-plaintext highlighter-rouge">putobject</code> instruction</li>
  <li>and an iseq that is … pushed by the <code class="language-plaintext highlighter-rouge">putiseq</code> instruction. Yes, instruction is an argument for another instruction.</li>
</ol>

<p>Here’s the code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">recv</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="no">FrozenCore</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mid</span> <span class="o">==</span> <span class="ss">:'core#define_method'</span>
  <span class="n">method_name</span><span class="p">,</span> <span class="n">body_iseq</span> <span class="o">=</span> <span class="o">*</span><span class="n">args</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">__define_method</span><span class="p">(</span><span class="ss">method_name: </span><span class="n">method_name</span><span class="p">,</span> <span class="ss">body_iseq: </span><span class="n">body_iseq</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here’s how <code class="language-plaintext highlighter-rouge">__define_method</code> looks:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">:,</span> <span class="n">body_iseq</span><span class="p">:)</span>
  <span class="n">parent_nesting</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">nesting</span>
  <span class="n">define_on</span> <span class="o">=</span> <span class="no">MethodDefinitionScope</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span>

  <span class="n">define_on</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
    <span class="n">execute</span><span class="p">(</span><span class="n">body_iseq</span><span class="p">,</span> <span class="ss">_self: </span><span class="nb">self</span><span class="p">,</span> <span class="ss">method_args: </span><span class="n">method_args</span><span class="p">,</span> <span class="ss">block: </span><span class="n">block</span><span class="p">,</span> <span class="ss">parent_nesting: </span><span class="n">parent_nesting</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">method_name</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When we enter a method in Ruby it inherits <code class="language-plaintext highlighter-rouge">Module.nesting</code> of a frame that defines it. This is why we also copy <code class="language-plaintext highlighter-rouge">current_frame.nesting</code> to a method frame.</p>

<p><code class="language-plaintext highlighter-rouge">define_on = MethodDefinitionScope.new(current_frame)</code> is also quite simple:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MethodDefinitionScope</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="k">when</span> <span class="no">Class</span><span class="p">,</span> <span class="no">Module</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="k">when</span> <span class="no">TOPLEVEL_BINDING</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'self'</span><span class="p">)</span>
      <span class="no">Object</span>
    <span class="k">else</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">singleton_class</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>If we define a method in a global scope it is defined on the <code class="language-plaintext highlighter-rouge">Object</code> class.</li>
  <li>If we define a method inside a class/module context - well, class/module is where the method will be defined.</li>
  <li>If we define a method inside some other context (inside <code class="language-plaintext highlighter-rouge">instance_eval</code> for example) - the method is defined on the singleton class of the object.</li>
</ul>

<p>These code constructions are equivalent:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span>
<span class="c1"># and</span>
<span class="no">Object</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">class</span> <span class="nc">X</span><span class="p">;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span> <span class="k">end</span>
<span class="c1"># and</span>
<span class="no">X</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">o</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="n">o</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="p">{</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span> <span class="p">}</span>
<span class="c1"># and</span>
<span class="n">o</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Then comes this part:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">define_on</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
  <span class="n">execute</span><span class="p">(</span><span class="n">body_iseq</span><span class="p">,</span> <span class="ss">_self: </span><span class="nb">self</span><span class="p">,</span> <span class="ss">method_args: </span><span class="n">method_args</span><span class="p">,</span> <span class="ss">block: </span><span class="n">block</span><span class="p">,</span> <span class="ss">parent_nesting: </span><span class="n">parent_nesting</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We define a method that takes any arguments (it breaks <code class="language-plaintext highlighter-rouge">Method#parameters</code>, but let’s ignore it) and an optional block and executes the ISeq of the method body in a context of <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>I admit that it’s a very hacky trick, but it allows us to dynamically assign <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>Plus, we pass all other things that can (and in most cases will) be used in a method body:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">method_args</code> - what was given to a particular invocation of our method</li>
  <li><code class="language-plaintext highlighter-rouge">block</code> - a block given to a method call</li>
  <li><code class="language-plaintext highlighter-rouge">parent_nesting</code> - <code class="language-plaintext highlighter-rouge">Module.nesting</code> in the outer scope. We have to store in the beginning of the method definition because it may change before the method gets called.</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">execute(iseq, **options)</code> is a tiny wrapper that pushes the frame into the <code class="language-plaintext highlighter-rouge">frame_stack</code> depending on the <code class="language-plaintext highlighter-rouge">kind</code> of the given iseq:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">)</span>
  <span class="n">push_frame</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">evaluate_last_frame</span>
  <span class="n">pop_frame</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">push_frame</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">kind</span>
  <span class="k">when</span> <span class="ss">:top</span>
    <span class="vi">@frame_stack</span><span class="p">.</span><span class="nf">push_top</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span>
    <span class="p">)</span>
  <span class="k">when</span> <span class="ss">:method</span>
    <span class="vi">@frame_stack</span><span class="p">.</span><span class="nf">push_method</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">parent_nesting: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:parent_nesting</span><span class="p">],</span>
      <span class="ss">_self: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:_self</span><span class="p">],</span>
      <span class="ss">arg_values: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:method_args</span><span class="p">],</span>
      <span class="ss">block: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:block</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"Unknown iseq kind </span><span class="si">#{</span><span class="n">iseq</span><span class="p">.</span><span class="nf">kind</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="local-variables">local variables</h5>

<p>there are 2 most-commonly used instructions to get/set locals:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getlocal</code></li>
  <li><code class="language-plaintext highlighter-rouge">setlocal</code></li>
</ul>

<p>Both take two arguments:</p>

<ul>
  <li>an offset of the frame where the variable is stored</li>
  <li>an ID of the variable</li>
</ul>

<p>Here’s an example</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a = 10; b = 20; a; b'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>We push <code class="language-plaintext highlighter-rouge">10</code> to the stack, then we pop it and assign to a variable with ID = 4 in the current frame (<code class="language-plaintext highlighter-rouge">setlocal_WC_0</code> here is a specialized instruction that is <code class="language-plaintext highlighter-rouge">setlocal 0, 4</code> when the optimization is turned off).</p>

<p>Here’s the code to maintain locals:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'set'</span>

<span class="c1"># A simple struct that represents a single local variable;</span>
<span class="c1"># has a name, an ID and a value (or no value)</span>
<span class="no">Local</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:id</span><span class="p">,</span> <span class="ss">:value</span><span class="p">,</span> <span class="ss">keyword_init: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">get</span>
    <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># A wrapper around "Set" that holds all locals for some frame;</span>
<span class="c1"># Absolutely each frame has its own instance of "Locals"</span>
<span class="k">class</span> <span class="nc">Locals</span>
  <span class="no">UNDEFINED</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">def</span> <span class="nc">UNDEFINED</span><span class="o">.</span><span class="nf">inspect</span><span class="p">;</span> <span class="s1">'UNDEFINED'</span><span class="p">;</span> <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">initial_names</span><span class="p">)</span>
    <span class="vi">@set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">.</span><span class="nf">new</span>

    <span class="n">initial_names</span><span class="p">.</span><span class="nf">reverse_each</span><span class="p">.</span><span class="nf">with_index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
      <span class="c1"># implicit args (like a virtual attribute that holds mlhs value) have numeric names</span>
      <span class="n">arg_name</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">arg_name</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
      <span class="n">declare</span><span class="p">(</span><span class="ss">name: </span><span class="n">arg_name</span><span class="p">,</span> <span class="ss">id: </span><span class="n">idx</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="no">Locals</span><span class="o">::</span><span class="no">UNDEFINED</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">declared?</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="o">!</span><span class="n">find_if_declared</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">id: </span><span class="nb">id</span><span class="p">).</span><span class="nf">nil?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">declare</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="n">local</span> <span class="o">=</span> <span class="no">Local</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">id: </span><span class="nb">id</span><span class="p">,</span> <span class="ss">value: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="vi">@set</span> <span class="o">&lt;&lt;</span> <span class="n">local</span>
    <span class="n">local</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">find_if_declared</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">name</span>
      <span class="vi">@set</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">var</span><span class="o">|</span> <span class="n">var</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="nb">name</span> <span class="p">}</span>
    <span class="k">elsif</span> <span class="nb">id</span>
      <span class="vi">@set</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">var</span><span class="o">|</span> <span class="n">var</span><span class="p">.</span><span class="nf">id</span> <span class="o">==</span> <span class="nb">id</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"At least one of name:/id: is required"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">find_if_declared</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">id: </span><span class="nb">id</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s2">"No local name=</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">/id=</span><span class="si">#{</span><span class="nb">id</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty</span>
    <span class="vi">@set</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">local</span><span class="o">|</span> <span class="p">[</span><span class="s2">"</span><span class="si">#{</span><span class="n">local</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="n">local</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">)"</span><span class="p">,</span> <span class="n">local</span><span class="p">.</span><span class="nf">value</span><span class="p">]</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">|</span> <span class="nb">name</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">to_h</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">locals</code> inside a frame is just a set. It is possible to declare a local, to check if it’s declared and to get it.</p>

<p>Here’s the implementation of <code class="language-plaintext highlighter-rouge">getlocal</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getlocal</span><span class="p">(</span><span class="n">local_var_id</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="nf">parent_frame</span> <span class="p">}</span>
  <span class="n">local</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">id: </span><span class="n">local_var_id</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">local</span><span class="p">.</span><span class="nf">get</span>
  <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="no">Locals</span><span class="o">::</span><span class="no">UNDEFINED</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
  <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We jump out <code class="language-plaintext highlighter-rouge">n</code> times to get the Nth frame, we find a local, we return <code class="language-plaintext highlighter-rouge">nil</code> if it’s <code class="language-plaintext highlighter-rouge">undefined</code> and we push the value back to the stack (so the result can be used by a subsequent instruction)</p>

<p>Here’s the implementation of <code class="language-plaintext highlighter-rouge">setlocal</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_setlocal</span><span class="p">(</span><span class="n">local_var_id</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="nf">parent_frame</span> <span class="p">}</span>
  <span class="n">local</span> <span class="o">=</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">existing_local</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">locals</span><span class="p">.</span><span class="nf">find_if_declared</span><span class="p">(</span><span class="ss">id: </span><span class="n">local_var_id</span><span class="p">))</span>
      <span class="n">existing_local</span>
    <span class="k">elsif</span> <span class="n">frame</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">locals</span><span class="p">.</span><span class="nf">declare</span><span class="p">(</span><span class="ss">id: </span><span class="n">local_var_id</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s1">'locals are malformed'</span>
    <span class="k">end</span>

  <span class="n">local</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This one is a bit more complicated:</p>

<ol>
  <li>first, we <code class="language-plaintext highlighter-rouge">pop</code> the value from the stack (it was pushed by a previous instruction <code class="language-plaintext highlighter-rouge">putobject 10</code>)</li>
  <li>then we find Nth frame</li>
  <li>then we get a local from this frame</li>
  <li>if it’s there we use it; if not - we declare it in the current frame</li>
  <li>and then we set the value</li>
</ol>

<h5 id="method-arguments">method arguments</h5>

<p>Every method has an arglist. Yes, sometimes it’s empty, but even in such case we do an arity check. In general arguments initialization is a part of every method call.</p>

<p>This part of Ruby is really complicated, because we have 12 argument types:</p>

<ul>
  <li>required positional argument - <code class="language-plaintext highlighter-rouge">def m(x)</code></li>
  <li>optional positional argument - <code class="language-plaintext highlighter-rouge">def m(x = 42)</code></li>
  <li>rest argument - <code class="language-plaintext highlighter-rouge">def m(*x)</code></li>
  <li>post argument - <code class="language-plaintext highlighter-rouge">def m(*, x = 1)</code></li>
  <li>mlhs argument (can be used as a post argument too) - <code class="language-plaintext highlighter-rouge">def m( (x, *y, z) )</code></li>
  <li>required keyword argument - <code class="language-plaintext highlighter-rouge">def m(x:)</code></li>
  <li>optional keyword argument - <code class="language-plaintext highlighter-rouge">def m(x: 42)</code></li>
  <li>rest keyword argument - <code class="language-plaintext highlighter-rouge">def m(**x)</code></li>
  <li>block argument - <code class="language-plaintext highlighter-rouge">def m(&amp;x)</code></li>
  <li>shadow argument - <code class="language-plaintext highlighter-rouge">proc { |;x| }</code> (I didn’t implement it because I never used it)</li>
  <li><code class="language-plaintext highlighter-rouge">nil</code> keyword argument (since 2.7) - <code class="language-plaintext highlighter-rouge">def m(**nil)</code></li>
  <li>arguments forwarding (also since 2.7) - <code class="language-plaintext highlighter-rouge">def m(...)</code></li>
</ul>

<p>First, let’s take a look at the iseq to see what we have:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'def m(a, b = 42, *c, d); end'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="s2">"YARVInstructionSequence/SimpleDataFormat"</span><span class="p">,</span>
 <span class="mi">2</span><span class="p">,</span>
 <span class="mi">6</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="p">{</span><span class="ss">:arg_size</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span>
  <span class="ss">:local_size</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span>
  <span class="ss">:stack_max</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:node_id</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span>
  <span class="ss">:code_location</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">]},</span>
 <span class="s2">"m"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="ss">:method</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="ss">:c</span><span class="p">,</span> <span class="ss">:d</span><span class="p">],</span>
 <span class="p">{</span><span class="ss">:opt</span><span class="o">=&gt;</span><span class="p">[</span><span class="ss">:label_0</span><span class="p">,</span> <span class="ss">:label_4</span><span class="p">],</span>
  <span class="ss">:lead_num</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:post_num</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:post_start</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">,</span>
  <span class="ss">:rest_start</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">},</span>
 <span class="p">[],</span>
 <span class="p">[</span><span class="ss">:label_0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
  <span class="ss">:label_4</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
  <span class="ss">:RUBY_EVENT_RETURN</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]</span>
</code></pre></div></div>

<p>There are two entries that we are interested in:</p>

<ol>
  <li>a list of argument names (well, it’s a list of all variables, but it works for our case)</li>
  <li>a hash with arguments information</li>
</ol>

<p>Let’s prepare and group it first, it’s hard to work with such format:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CategorizedArguments</span>
  <span class="nb">attr_reader</span> <span class="ss">:req</span><span class="p">,</span> <span class="ss">:opt</span><span class="p">,</span> <span class="ss">:rest</span><span class="p">,</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:kw</span><span class="p">,</span> <span class="ss">:kwrest</span><span class="p">,</span> <span class="ss">:block</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">arg_names</span><span class="p">,</span> <span class="n">args_info</span><span class="p">)</span>
    <span class="vi">@req</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="vi">@opt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="vi">@rest</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="vi">@post</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">parse!</span><span class="p">(</span><span class="n">arg_names</span><span class="p">.</span><span class="nf">dup</span><span class="p">,</span> <span class="n">args_info</span><span class="p">.</span><span class="nf">dup</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse!</span><span class="p">(</span><span class="n">arg_names</span><span class="p">,</span> <span class="n">args_info</span><span class="p">)</span>
    <span class="p">(</span><span class="n">args_info</span><span class="p">[</span><span class="ss">:lead_num</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">req</span> <span class="o">&lt;&lt;</span> <span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">opt_info</span> <span class="o">=</span> <span class="n">args_info</span><span class="p">[</span><span class="ss">:opt</span><span class="p">].</span><span class="nf">dup</span> <span class="o">||</span> <span class="p">[]</span>
    <span class="n">opt_info</span><span class="p">.</span><span class="nf">shift</span>
    <span class="n">opt_info</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">label</span><span class="o">|</span>
      <span class="n">opt</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">),</span> <span class="n">label</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">args_info</span><span class="p">[</span><span class="ss">:rest_start</span><span class="p">]</span>
      <span class="vi">@rest</span> <span class="o">=</span> <span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="p">(</span><span class="n">args_info</span><span class="p">[</span><span class="ss">:post_num</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">post</span> <span class="o">&lt;&lt;</span> <span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="n">arg_name_or_idx</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">.</span><span class="nf">shift</span>

    <span class="k">if</span> <span class="n">arg_name_or_idx</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
      <span class="n">arg_name_or_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>

    <span class="n">arg_name_or_idx</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I intentionally skip keyword arguments here, but they are not that much different from other types of arguments. The only noticeable difference is that optional keyword arguments have “inlined” default values if they are simple enough (like plain strings or numbers, but not expressions like <code class="language-plaintext highlighter-rouge">2+2</code>). If you are interested you can go to the repo and check this file.</p>

<p>Then, we should parse arguments and assign them into local variables <strong>when we push a method frame</strong> (so they are available once we start executing instructions of a method body):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MethodArguments</span>
  <span class="nb">attr_reader</span> <span class="ss">:args</span><span class="p">,</span> <span class="ss">:values</span><span class="p">,</span> <span class="ss">:locals</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">iseq</span><span class="p">:,</span> <span class="n">values</span><span class="p">:,</span> <span class="n">locals</span><span class="p">:)</span>
    <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">dup</span>
    <span class="vi">@locals</span> <span class="o">=</span> <span class="n">locals</span>
    <span class="vi">@iseq</span> <span class="o">=</span> <span class="n">iseq</span>

    <span class="vi">@args</span> <span class="o">=</span> <span class="no">CategorizedArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="n">iseq</span><span class="p">.</span><span class="nf">lvar_names</span><span class="p">,</span>
      <span class="n">iseq</span><span class="p">.</span><span class="nf">args_info</span>
    <span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="kp">false</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">req</span><span class="p">.</span><span class="nf">count</span> <span class="o">+</span> <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">count</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'wrong number of arguments (too few)'</span>
    <span class="k">end</span>

    <span class="c1"># Required positional args</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">req</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">empty?</span>
        <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'wrong number of arguments (too few)'</span>
      <span class="k">end</span>

      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">shift</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Optional positional args</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">opt</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span><span class="o">|</span>
      <span class="k">break</span> <span class="k">if</span> <span class="n">values</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">count</span>

      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">shift</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

      <span class="no">VM</span><span class="p">.</span><span class="nf">jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Rest positional argument</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">name</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="nf">rest</span><span class="p">)</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">first</span><span class="p">([</span><span class="n">values</span><span class="p">.</span><span class="nf">length</span> <span class="o">-</span> <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">max</span><span class="p">)</span>
      <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">last</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">length</span><span class="p">)</span>

      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Required post positional arguments</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">empty?</span>
        <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'Broken arguments, cannot extract required argument'</span>
      <span class="k">end</span>

      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">shift</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Make sure there are no arguments left</span>
    <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">any?</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'wrong number of arguments (too many)'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">values</code> is what we get in a method call in <code class="language-plaintext highlighter-rouge">*method_args</code>, <code class="language-plaintext highlighter-rouge">locals</code> is equal to <code class="language-plaintext highlighter-rouge">MethodFrame#locals</code> that is set to <code class="language-plaintext highlighter-rouge">Locals.new</code> by default.</p>

<p>Let’s write <code class="language-plaintext highlighter-rouge">MethodFrame</code> class!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MethodFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">attr_reader</span> <span class="ss">:arg_values</span>

  <span class="nb">attr_reader</span> <span class="ss">:block</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">parent_nesting</span><span class="p">:,</span> <span class="n">_self</span><span class="p">:,</span> <span class="n">arg_values</span><span class="p">:,</span> <span class="n">block</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_nesting</span>

    <span class="vi">@block</span> <span class="o">=</span> <span class="n">block</span>

    <span class="no">MethodArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">values: </span><span class="n">arg_values</span><span class="p">,</span>
      <span class="ss">locals: </span><span class="n">locals</span><span class="p">,</span>
      <span class="ss">block: </span><span class="n">iseq</span><span class="p">.</span><span class="nf">args_info</span><span class="p">[</span><span class="ss">:block_start</span><span class="p">]</span> <span class="p">?</span> <span class="n">block</span> <span class="p">:</span> <span class="kp">nil</span>
    <span class="p">).</span><span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty_name</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">_self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">#</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Method frame is just a regular frame that extracts arguments during its initialization.</p>

<h5 id="constants">constants</h5>

<p>A regular constant assignment (like <code class="language-plaintext highlighter-rouge">A = 1</code>) is based on a scope (<code class="language-plaintext highlighter-rouge">Module.nesting</code> for relative lookup) and two instructions:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">setconstant</code></li>
  <li><code class="language-plaintext highlighter-rouge">getconstant</code></li>
</ol>

<p>Both have a single argument - a constant name. But how does Ruby distinguish relative and absolute constant lookup? I mean, what’s the difference between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">::A</code>?</p>

<p>Ruby uses a special instruction to set a “constant scope” that:</p>

<ul>
  <li>for relative lookup
    <ul>
      <li>in the optimized mode does <code class="language-plaintext highlighter-rouge">opt_getinlinecache</code> before <code class="language-plaintext highlighter-rouge">get/setconstant</code></li>
      <li>in the non-optimized mode does <code class="language-plaintext highlighter-rouge">pushnil</code> (that works as a flag)</li>
    </ul>
  </li>
  <li>for absolute lookup Ruby computes it via a sequence of instructions</li>
</ul>

<p>Let’s take a look at the non-optimized mode (because we can’t optimize it anyway):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'A; ::B; Kernel::D'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:A</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:pop</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="no">Object</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:B</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:pop</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:Kernel</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:D</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">A</code> constant performs a relative lookup, so <code class="language-plaintext highlighter-rouge">putnil</code> is used.</p>

<p><code class="language-plaintext highlighter-rouge">::B</code> constant performs a global lookup on the <code class="language-plaintext highlighter-rouge">Object</code> that is a known object, and so it’s inlined in the <code class="language-plaintext highlighter-rouge">putobject</code> instruction.</p>

<p><code class="language-plaintext highlighter-rouge">Kernel::D</code> first searches for <code class="language-plaintext highlighter-rouge">Kernel</code> constant locally, then it uses it as a “scope” for a constant <code class="language-plaintext highlighter-rouge">D</code>.</p>

<p>Quite easy, right? Not so fast. Ruby uses <code class="language-plaintext highlighter-rouge">Module.nesting</code> to perform a bottom-top search. This is why it’s so important to maintain <code class="language-plaintext highlighter-rouge">nesting</code> value in frames. Thus, the lookup is performed on <code class="language-plaintext highlighter-rouge">current_scope.nesting</code> <strong>in reverse order</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getconstant</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">search_in</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="n">current_scope</span><span class="p">.</span><span class="nf">nesting</span><span class="p">.</span><span class="nf">reverse</span> <span class="p">:</span> <span class="p">[</span><span class="n">scope</span><span class="p">]</span>

  <span class="n">search_in</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">mod</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">.</span><span class="nf">const_defined?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">const</span> <span class="o">=</span> <span class="n">mod</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">push</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="no">NameError</span><span class="p">,</span> <span class="s2">"uninitialized constant </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If the scope is given (via <code class="language-plaintext highlighter-rouge">push</code> in a previous instruction) we use it. Otherwise we have a relative lookup and so we must use <code class="language-plaintext highlighter-rouge">current_scope.nesting.reverse</code>.</p>

<p><code class="language-plaintext highlighter-rouge">setconstant</code> is a bit simpler, because it always defines a constant on a scope set by a previous instruction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'A = 10; ::B = 20; Kernel::D = 30'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putspecialobject</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setconstant</span><span class="p">,</span> <span class="ss">:A</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="no">Object</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setconstant</span><span class="p">,</span> <span class="ss">:B</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:Kernel</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setconstant</span><span class="p">,</span> <span class="ss">:D</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">putspecialobject</code> is an instruction that is (when called with 3) pushes a “current” scope.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">putspecialobject</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">kind</span>
  <span class="k">when</span> <span class="mi">3</span>
    <span class="n">push</span><span class="p">(</span><span class="n">current_frame</span><span class="p">.</span><span class="nf">nesting</span><span class="p">.</span><span class="nf">last</span><span class="p">)</span> <span class="c1"># push "current" scope</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"Unknown special object </span><span class="si">#{</span><span class="n">kind</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">setconstant</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">scope</span><span class="p">.</span><span class="nf">const_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="instanceclass-variables">Instance/Class variables</h5>

<p>Instance variables are always picked from the <code class="language-plaintext highlighter-rouge">self</code> of the current frame (they literally look like a simplified version of local variables that are always stored in <code class="language-plaintext highlighter-rouge">self</code> of the current scope):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'@a = 42; @a'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setinstancevariable</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getinstancevariable</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>I guess you know how the code should look like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getinstancevariable</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_setinstancevariable</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Class variables are similar, but it is possible to get it in the instance method, so it uses <code class="language-plaintext highlighter-rouge">self</code> if our current frame is a <code class="language-plaintext highlighter-rouge">ClassFrame</code> or <code class="language-plaintext highlighter-rouge">self.class</code> otherwise:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'@@a = 42; @@a'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setclassvariable</span><span class="p">,</span> <span class="ss">:@@a</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getclassvariable</span><span class="p">,</span> <span class="ss">:@@a</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">execute_setclassvariable</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class</span> <span class="k">unless</span> <span class="n">klass</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">class_variable_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_getclassvariable</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class</span> <span class="k">unless</span> <span class="n">klass</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class_variable_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="literals">Literals</h5>

<p>But how can we construct arrays, hashes?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'[ [:foo,a,:bar], [4,5], 42 ]'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:foo</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newarray</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:duparray</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newarray</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>As you can see the strategy of building an array depends on its dynamicity:</p>

<ul>
  <li>for dynamic <code class="language-plaintext highlighter-rouge">[:foo, a, :bar]</code> MRI uses <code class="language-plaintext highlighter-rouge">newarray</code> (because <code class="language-plaintext highlighter-rouge">a</code> has to be computed in runtime)</li>
  <li>for primitive <code class="language-plaintext highlighter-rouge">[4, 5]</code> it uses <code class="language-plaintext highlighter-rouge">duparray</code> (because it’s faster)</li>
</ul>

<p>The whole array is also dynamic (because one of its elements is also dynamic). Let’s define them:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_duparray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="nf">dup</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_newarray</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">size</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">push</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Do hashes support inlining?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'{ primitive: { foo: :bar }, dynamic: { c: d } }'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:primitive</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:duphash</span><span class="p">,</span> <span class="p">{</span><span class="ss">:foo</span><span class="o">=&gt;</span><span class="ss">:bar</span><span class="p">}],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:dynamic</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:c</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:d</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newhash</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:newhash</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Yes! <code class="language-plaintext highlighter-rouge">duphash</code> contains an inlined hash that should be pushed to the stack as is. <code class="language-plaintext highlighter-rouge">newhash</code> has a numeric argument that represents the number of keys and values on the hash (i.e. <code class="language-plaintext highlighter-rouge">keys * 2</code> or <code class="language-plaintext highlighter-rouge">values * 2</code>, there’s no difference). And once again, if at least one element of the hash is dynamic, the whole has is also dynamic and so it uses <code class="language-plaintext highlighter-rouge">newhash</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_duphash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="nb">hash</span><span class="p">.</span><span class="nf">dup</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_newhash</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="nb">hash</span> <span class="o">=</span> <span class="n">size</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">to_h</span>
  <span class="n">push</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Why do we need <code class="language-plaintext highlighter-rouge">.dup</code> in <code class="language-plaintext highlighter-rouge">duphash</code> and <code class="language-plaintext highlighter-rouge">duparray</code>? The reason is simple: this instruction can be executed multiple times (if it’s a part of a method or block, for example), and so the same value will be pushed to the stack multiple times. One of the next instructions can modify it but literals have to stay static no matter what. Without using <code class="language-plaintext highlighter-rouge">.dup</code> the code like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">p</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">pop</span>
<span class="k">end</span>
</code></pre></div></div>

<p>would print <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">2</code>.</p>

<h5 id="splats">Splats</h5>

<p>Splat is one of the most beautiful features of Ruby. Splat is <code class="language-plaintext highlighter-rouge">foo, bar = *baz</code> (and also <code class="language-plaintext highlighter-rouge">[*foo, *bar]</code>):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a, b = *c, 42'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:c</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:splatarray</span><span class="p">,</span> <span class="kp">true</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newarray</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:concatarray</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:expandarray</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">splatarray</code> pops the object from the stack, converts it to <code class="language-plaintext highlighter-rouge">Array</code> by calling <code class="language-plaintext highlighter-rouge">to_a</code> (if it’s not an array; otherwise there’s no type casting), and pushes the result back to the stack.</p>

<p><code class="language-plaintext highlighter-rouge">concatarray</code> constructs an array from two top elements and pushes it back. So it changes the stack <code class="language-plaintext highlighter-rouge">[a, b]</code> to <code class="language-plaintext highlighter-rouge">[ [a,b] ]</code>. If items are arrays it expands and merges them.</p>

<p><code class="language-plaintext highlighter-rouge">expandarray</code> expands it by doing <code class="language-plaintext highlighter-rouge">pop</code> and pushing items back to the stack. It takes the number of elements that need to be returned, so if an array is bigger it drops some items, if it’s too small - it pushes as many <code class="language-plaintext highlighter-rouge">nil</code>s as needed.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_splatarray</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">to_a</span> <span class="k">unless</span> <span class="n">array</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_concatarray</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
  <span class="n">last</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">first</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">push</span><span class="p">([</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">])</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_expandarray</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">_flag</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="k">if</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">&lt;</span> <span class="n">size</span>
    <span class="n">array</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span> <span class="k">until</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="n">size</span>
  <span class="k">elsif</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">&gt;</span> <span class="n">size</span>
    <span class="n">array</span><span class="p">.</span><span class="nf">pop</span> <span class="k">until</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="n">size</span>
  <span class="k">else</span>
    <span class="c1"># they are equal</span>
  <span class="k">end</span>

  <span class="n">array</span><span class="p">.</span><span class="nf">reverse_each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="n">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In fact <code class="language-plaintext highlighter-rouge">expandarray</code> is much, much more complicated, you can go to the repo and check it if you want.</p>

<p>Keyword splats (like <code class="language-plaintext highlighter-rouge">{ **x, **y }</code>) are really similar to array splats, I’m not going to cover them here.</p>

<h5 id="conditions-ifunless">conditions (if/unless)</h5>

<p>To handle conditions Ruby uses local <code class="language-plaintext highlighter-rouge">goto</code> (just like in C). Target of the <code class="language-plaintext highlighter-rouge">goto</code>-like instruction is a label:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"a = b = c = 42; if a; b; else; c; end"</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:branchunless</span><span class="p">,</span> <span class="ss">:label_20</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:jump</span><span class="p">,</span> <span class="ss">:label_16</span><span class="p">],</span>

 <span class="ss">:label_16</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:jump</span><span class="p">,</span> <span class="ss">:label_22</span><span class="p">],</span>

 <span class="ss">:label_20</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>

 <span class="ss">:label_22</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Do you see these <code class="language-plaintext highlighter-rouge">:label_&lt;NN&gt;</code> symbols? They are used as markers. <code class="language-plaintext highlighter-rouge">branchunless</code> takes a single argument: a label that it to jump to if the value on the top of the stack is <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">nil</code>. If it’s <code class="language-plaintext highlighter-rouge">true</code>-like it does nothing.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_branchunless</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="n">cond</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="k">unless</span> <span class="n">cond</span>
    <span class="n">jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="n">insns</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">iseq</span><span class="p">.</span><span class="nf">insns</span>
  <span class="n">insns</span><span class="p">.</span><span class="nf">drop_while</span> <span class="p">{</span> <span class="o">|</span><span class="n">insn</span><span class="o">|</span> <span class="n">insn</span> <span class="o">!=</span> <span class="n">label</span> <span class="p">}</span>
  <span class="n">insns</span><span class="p">.</span><span class="nf">shift</span> <span class="c1"># to drop the label too</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here we do <code class="language-plaintext highlighter-rouge">pop</code>, check it and call <code class="language-plaintext highlighter-rouge">jump</code> if it’s <code class="language-plaintext highlighter-rouge">false</code>. <code class="language-plaintext highlighter-rouge">jump</code> skips instructions until it sees a given label.</p>

<p>MRI also has <code class="language-plaintext highlighter-rouge">branchif</code> and <code class="language-plaintext highlighter-rouge">branchnil</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">branchif</code> does <code class="language-plaintext highlighter-rouge">if cond</code>  as a main check</li>
  <li><code class="language-plaintext highlighter-rouge">branchnil</code> does <code class="language-plaintext highlighter-rouge">if cond.nil?</code></li>
</ul>

<h5 id="string-interpolationconcatenation">String interpolation/concatenation</h5>

<p>Ruby has a few compile-time optimizations that optimize code like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"a""b"</span>
<span class="s2">"</span><span class="si">#{</span><span class="s1">'a'</span><span class="si">}#{</span><span class="s1">'b'</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>into a string <code class="language-plaintext highlighter-rouge">"ab"</code>. However more complicated cases with dynamic interpolation involve a few new instructions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'"#{a}#{:sym}"'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="s2">""</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:checktype</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:branchif</span><span class="p">,</span> <span class="ss">:label_18</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:to_s</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:tostring</span><span class="p">],</span>
 <span class="ss">:label_18</span><span class="p">,</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:sym</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:checktype</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:branchif</span><span class="p">,</span> <span class="ss">:label_31</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:to_s</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:tostring</span><span class="p">],</span>
 <span class="ss">:label_31</span><span class="p">,</span>

 <span class="p">[</span><span class="ss">:concatstrings</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Parts above are split into sections.</p>

<ol>
  <li>There’s an “invisible” beginning of the string (<code class="language-plaintext highlighter-rouge">putobject ""</code>)</li>
  <li>Then we have an interpolated method call <code class="language-plaintext highlighter-rouge">a</code>:</li>
  <li>First we call <code class="language-plaintext highlighter-rouge">a</code> via <code class="language-plaintext highlighter-rouge">send</code></li>
  <li>then we run <code class="language-plaintext highlighter-rouge">checktype</code> instruction that checks for an argument <code class="language-plaintext highlighter-rouge">5</code> that what’s popped is a string. it pushes back a boolean value</li>
  <li>then we conditionally invoke <code class="language-plaintext highlighter-rouge">to_s</code> if the object is not a string</li>
  <li>then we have an interpolated symbol <code class="language-plaintext highlighter-rouge">:sym</code> that gets interpolated in the same way</li>
  <li>and finally we invoke <code class="language-plaintext highlighter-rouge">concatstrings 3</code> that does <code class="language-plaintext highlighter-rouge">pop</code> 3 times, concatenates 3 strings and pushes the result back to the stack</li>
</ol>

<p>First let’s take a look at the <code class="language-plaintext highlighter-rouge">checktype</code> instruction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">CHECK_TYPE</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">klass</span> <span class="o">===</span> <span class="n">obj</span>
<span class="p">}.</span><span class="nf">curry</span>

<span class="no">RB_OBJ_TYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mh">0x00</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_NONE</span>

  <span class="mh">0x01</span> <span class="o">=&gt;</span> <span class="no">CHECK_TYPE</span><span class="p">[</span><span class="no">Object</span><span class="p">],</span>                        <span class="c1"># RUBY_T_OBJECT</span>
  <span class="mh">0x02</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_CLASS</span>
  <span class="mh">0x03</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MODULE</span>
  <span class="mh">0x04</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FLOAT</span>
  <span class="mh">0x05</span> <span class="o">=&gt;</span> <span class="no">CHECK_TYPE</span><span class="p">[</span><span class="no">String</span><span class="p">],</span>                        <span class="c1"># RUBY_T_STRING</span>
  <span class="mh">0x06</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_REGEXP</span>
  <span class="mh">0x07</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_ARRAY</span>
  <span class="mh">0x08</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_HASH</span>
  <span class="mh">0x09</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_STRUCT</span>
  <span class="mh">0x0a</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_BIGNUM</span>
  <span class="mh">0x0b</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FILE</span>
  <span class="mh">0x0c</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_DATA</span>
  <span class="mh">0x0d</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MATCH</span>
  <span class="mh">0x0e</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_COMPLEX</span>
  <span class="mh">0x0f</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_RATIONAL</span>

  <span class="mh">0x11</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_NIL</span>
  <span class="mh">0x12</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_TRUE</span>
  <span class="mh">0x13</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FALSE</span>
  <span class="mh">0x14</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_SYMBOL</span>
  <span class="mh">0x15</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FIXNUM</span>
  <span class="mh">0x16</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_UNDEF</span>

  <span class="mh">0x1a</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_IMEMO</span>
  <span class="mh">0x1b</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_NODE</span>
  <span class="mh">0x1c</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_ICLASS</span>
  <span class="mh">0x1d</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_ZOMBIE</span>
  <span class="mh">0x1e</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MOVED</span>

  <span class="mh">0x1f</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MASK</span>
<span class="p">}.</span><span class="nf">freeze</span>

<span class="k">def</span> <span class="nf">execute_checktype</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
  <span class="n">item_to_check</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">check</span> <span class="o">=</span> <span class="no">RB_OBJ_TYPES</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s2">"checktype - unknown type </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">check</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">item_to_check</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I blindly took it from MRI and yes, this instruction supports maaany types. I implemented only two of them, but the rest looks simple (except <code class="language-plaintext highlighter-rouge">imemo</code> and friends). Honestly I have no idea why, but about 95% of specs from the RubySpec (only language group, I didn’t check the whole test suite) are passing with these missing parts. I have no idea how to trigger MRI to use them. Maybe it uses them internally?</p>

<p><code class="language-plaintext highlighter-rouge">concatstrings</code> looks just like <code class="language-plaintext highlighter-rouge">newarray</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_concatstrings</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
  <span class="n">strings</span> <span class="o">=</span> <span class="n">count</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">push</span><span class="p">(</span><span class="n">strings</span><span class="p">.</span><span class="nf">join</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="blocks">Blocks</h5>

<p>Blocks are passed to method calls as a third argument:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'m { |a| a + 42 }'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span>
  <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:m</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span>
  <span class="kp">false</span><span class="p">,</span>
  <span class="p">[</span><span class="s2">"YARVInstructionSequence/SimpleDataFormat"</span><span class="p">,</span>
   <span class="mi">2</span><span class="p">,</span>
   <span class="mi">6</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
   <span class="p">{</span><span class="ss">:arg_size</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">:local_size</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">:stack_max</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span>
    <span class="ss">:node_id</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span>
    <span class="ss">:code_location</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">]},</span>
   <span class="s2">"block in &lt;compiled&gt;"</span><span class="p">,</span>
   <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
   <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
   <span class="ss">:block</span><span class="p">,</span>
   <span class="p">[</span><span class="ss">:a</span><span class="p">],</span>
   <span class="p">{</span><span class="ss">:lead_num</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:ambiguous_param0</span><span class="o">=&gt;</span><span class="kp">true</span><span class="p">},</span>
   <span class="p">[[</span><span class="ss">:redo</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:label_1</span><span class="p">,</span> <span class="ss">:label_9</span><span class="p">,</span> <span class="ss">:label_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:next</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:label_1</span><span class="p">,</span> <span class="ss">:label_9</span><span class="p">,</span> <span class="ss">:label_9</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
   <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">:RUBY_EVENT_B_CALL</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:nop</span><span class="p">],</span>
    <span class="ss">:label_1</span><span class="p">,</span>
    <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">16</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
    <span class="ss">:label_9</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:nop</span><span class="p">],</span>
    <span class="ss">:RUBY_EVENT_B_RETURN</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]]]</span>
</code></pre></div></div>

<p>Block definitely needs a frame that looks pretty much like a <code class="language-plaintext highlighter-rouge">MethodFrame</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">BlockFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:arg_values</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">arg_values</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">nesting</span>

    <span class="no">MethodArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">values: </span><span class="n">arg_values</span><span class="p">,</span>
      <span class="ss">locals: </span><span class="n">locals</span><span class="p">,</span>
      <span class="ss">block: </span><span class="kp">nil</span>
    <span class="p">).</span><span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="kp">false</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty_name</span>
    <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>(For simplicity let’s ignore that blocks can also take blocks; also let’s ignore lambdas, we will return to them later)</p>

<p>The code above looks <strong>almost</strong> like a method frame. The only difference is the <code class="language-plaintext highlighter-rouge">arity_check</code> value that we pass to the <code class="language-plaintext highlighter-rouge">MethodArguments</code> class.</p>

<p>But when should we create this frame? And how can we get a proc from it?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VM_CALL_ARGS_BLOCKARG</span>   <span class="o">=</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">execute_send</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">block_iseq</span><span class="p">)</span>
  <span class="n">_self</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:mid</span><span class="p">]</span>

  <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">block</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">block_iseq</span>
      <span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
        <span class="n">execute</span><span class="p">(</span><span class="n">block_iseq</span><span class="p">,</span> <span class="ss">self: </span><span class="n">_self</span><span class="p">,</span> <span class="ss">arg_values: </span><span class="n">args</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">elsif</span> <span class="n">flag</span> <span class="o">&amp;</span> <span class="no">VM_CALL_ARGS_BLOCKARG</span>
      <span class="n">pop</span>
    <span class="k">else</span>
      <span class="kp">nil</span>
    <span class="k">end</span>

  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>

  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It looks like a more generalized version of <code class="language-plaintext highlighter-rouge">opt_send_without_block</code>, because <code class="language-plaintext highlighter-rouge">opt_send_without_block</code> is a specialized implementation of <code class="language-plaintext highlighter-rouge">send</code>.</p>

<p>This instruction also pops a receiver and arguments, but what’s important, it also computes the block.</p>

<ol>
  <li>If <code class="language-plaintext highlighter-rouge">block_iseq</code> is given we create a proc that (once called) executes a block instruction (i.e. a block body) with given arguments. This block uses <code class="language-plaintext highlighter-rouge">self</code> of the place where it was created. (i.e. <code class="language-plaintext highlighter-rouge">self == proc { self }.call</code> always returns true)</li>
  <li>If there’s no <code class="language-plaintext highlighter-rouge">block_iseq</code> the block can be given via a <code class="language-plaintext highlighter-rouge">&amp;block</code> argument. MRI marks method call as <code class="language-plaintext highlighter-rouge">VM_CALL_ARGS_BLOCKARG</code> (this flag is just a bitmask)</li>
  <li>and then we simply call a method with a generated proc object.</li>
</ol>

<p>Implicit block like <code class="language-plaintext highlighter-rouge">b = proc {}; m(&amp;b)</code> doesn’t need any additional implementation. Method <code class="language-plaintext highlighter-rouge">proc</code> here takes a block (handled by the first <code class="language-plaintext highlighter-rouge">if</code> branch), it gets stored in a local variable and we pass it to the method as a block argument (<code class="language-plaintext highlighter-rouge">elseif</code> branch).</p>

<h5 id="lambdas">Lambdas</h5>

<p>It’s complicated and I don’t have a complete solution that covers all cases (I guess because MRI doesn’t expose enough APIs to do it. Or I’m just not smart enough).</p>

<p>Arrow lambda (<code class="language-plaintext highlighter-rouge">-&gt;(){}</code>) is just a method call <code class="language-plaintext highlighter-rouge">FrozenCore#lambda</code>, and so we can easily determine that it’s a lambda and not a proc. But what about <code class="language-plaintext highlighter-rouge">lambda {}</code>? It can be overwritten.</p>

<p>An incomplete (and somewhat unreliable) solution is to check that our receiver does not override <code class="language-plaintext highlighter-rouge">lambda</code> method inherited from a <code class="language-plaintext highlighter-rouge">Kernel</code> module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">creating_a_lambda</span> <span class="o">=</span> <span class="kp">false</span>

<span class="k">if</span> <span class="n">mid</span> <span class="o">==</span> <span class="ss">:lambda</span>
  <span class="k">if</span> <span class="n">recv</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="no">FrozenCore</span><span class="p">)</span>
    <span class="c1"># -&gt;{} syntax</span>
    <span class="n">creating_a_lambda</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">recv</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="ss">:lambda</span><span class="p">).</span><span class="nf">owner</span> <span class="o">==</span> <span class="no">Kernel</span>
    <span class="k">if</span> <span class="no">Kernel</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="ss">:lambda</span><span class="p">)</span> <span class="o">==</span> <span class="no">RubyRb</span><span class="o">::</span><span class="no">REAL_KERNEL_LAMBDA</span>
      <span class="c1"># an original "lambda" method from a Kernel module</span>
      <span class="n">creating_a_lambda</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then we can set it on our block frame as an attribute.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in the branch that creates a proc from the `block_iseq`</span>
<span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
  <span class="n">execute</span><span class="p">(</span><span class="n">block_iseq</span><span class="p">,</span> <span class="ss">self: </span><span class="n">_self</span><span class="p">,</span> <span class="ss">arg_values: </span><span class="n">args</span><span class="p">,</span> <span class="ss">is_lambda: </span><span class="n">creating_a_lambda</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">BlockFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:arg_values</span><span class="p">,</span> <span class="ss">:is_lambda</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">arg_values</span><span class="p">:,</span> <span class="n">is_lambda</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">is_lambda</span> <span class="o">=</span> <span class="n">is_lambda</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">nesting</span>

    <span class="no">MethodArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">values: </span><span class="n">arg_values</span><span class="p">,</span>
      <span class="ss">locals: </span><span class="n">locals</span><span class="p">,</span>
      <span class="ss">block: </span><span class="kp">nil</span>
    <span class="p">).</span><span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="n">is_lambda</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Arity check is enabled only if our proc is a lambda.</p>

<h5 id="calling-a-block">Calling a block</h5>

<p>If you remember when we define a method we tell it to save given block in a method frame:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">define_on</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
  <span class="n">execute</span><span class="p">(</span><span class="n">body_iseq</span><span class="p">,</span> <span class="ss">_self: </span><span class="nb">self</span><span class="p">,</span> <span class="ss">method_args: </span><span class="n">method_args</span><span class="p">,</span> <span class="ss">block: </span><span class="n">block</span><span class="p">,</span> <span class="ss">parent_nesting: </span><span class="n">parent_nesting</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And the frame itself saves it in the <code class="language-plaintext highlighter-rouge">attr_reader</code>.</p>

<p>So both explicit and implicit blocks are available in a method body via <code class="language-plaintext highlighter-rouge">current_frame.block</code>. It’s possible to invoke it by calling <code class="language-plaintext highlighter-rouge">block.call(arguments)</code> (if it’s available as an explicit block argument) or to call <code class="language-plaintext highlighter-rouge">yield(arguments)</code> (in such case it doesn’t even have to be declared in a method signature).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'def m; yield; end'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:invokeblock</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="kp">nil</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">16</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">}],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Honestly even before I started working on this article I expected MRI to do something like this. <code class="language-plaintext highlighter-rouge">yield</code> is equivalent to <code class="language-plaintext highlighter-rouge">&lt;current block&gt;.call(args)</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_invokeblock</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>

  <span class="n">frame</span> <span class="o">=</span> <span class="n">current_frame</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">parent_frame</span> <span class="k">until</span> <span class="n">frame</span><span class="p">.</span><span class="nf">can_yield?</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Do you see <code class="language-plaintext highlighter-rouge">frame = frame.parent_frame until frame.can_yield?</code>? The reason for this line is that you may have a code like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="k">yield</span> <span class="n">item</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>^ <code class="language-plaintext highlighter-rouge">yield</code> here belongs to the method <code class="language-plaintext highlighter-rouge">m</code>, not to the <code class="language-plaintext highlighter-rouge">BlockFrame</code> of the <code class="language-plaintext highlighter-rouge">.each</code> method. There can be more nested blocks, so we have to go up until we see something that supports <code class="language-plaintext highlighter-rouge">yield</code>. Well, we know that only one frame can do <code class="language-plaintext highlighter-rouge">yield</code>: it’s a <code class="language-plaintext highlighter-rouge">MethodFrame</code>.</p>

<p>Our frame class factory need to be extended to generate this method by default and return false from it. <code class="language-plaintext highlighter-rouge">MethodFrame</code> has to override it and return <code class="language-plaintext highlighter-rouge">true</code>. Polymorphism!</p>

<h5 id="super">Super</h5>

<p>Calling <code class="language-plaintext highlighter-rouge">super</code> is very similar to calling <code class="language-plaintext highlighter-rouge">yield</code>: it can be replaced with <code class="language-plaintext highlighter-rouge">method(__method__).super_method.call(args)</code>.</p>

<p><code class="language-plaintext highlighter-rouge">__method__</code> can be retrieved from <code class="language-plaintext highlighter-rouge">current_frame.name</code>, <code class="language-plaintext highlighter-rouge">args</code> are processed using <code class="language-plaintext highlighter-rouge">options[:orig_argc]</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_invokesuper</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">super_method</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="n">mid</span><span class="p">).</span><span class="nf">super_method</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">super_method</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This implementation is incorrect, it can’t handle a sequence of <code class="language-plaintext highlighter-rouge">super</code> calls (<code class="language-plaintext highlighter-rouge">class A &lt; B &lt; C</code>, each has a method that calls <code class="language-plaintext highlighter-rouge">super</code>). I guess it’s possible to implement it by recording the class where the method was defined (i.e. by storing <code class="language-plaintext highlighter-rouge">current_frame._self</code> before calling <code class="language-plaintext highlighter-rouge">define_method</code> and passing it to the <code class="language-plaintext highlighter-rouge">MethodFrame</code> constructor as a <code class="language-plaintext highlighter-rouge">defined_in</code> attribute). This way we could do something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_invokesuper</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">name</span>

  <span class="n">dispatchers</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span>
  <span class="n">current_dispatcher_idx</span> <span class="o">=</span> <span class="n">dispatchers</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">current_frame</span><span class="p">.</span><span class="nf">defined_in</span><span class="p">)</span>
  <span class="n">next_dispatcher</span> <span class="o">=</span> <span class="n">dispatchers</span><span class="p">[</span><span class="n">current_dispatcher_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

  <span class="n">super_method</span> <span class="o">=</span> <span class="n">next_dispatcher</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="n">mid</span><span class="p">).</span><span class="nf">bind</span><span class="p">(</span><span class="n">recv</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">super_method</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I didn’t implement it because MSpec doesn’t rely on it and I usually try to avoid sequences of <code class="language-plaintext highlighter-rouge">super</code> calls.</p>

<h5 id="global-variables">Global variables</h5>

<p>Similar to locals and instance variables, there are <code class="language-plaintext highlighter-rouge">getglobal</code>/<code class="language-plaintext highlighter-rouge">setglobal</code> instructions. They also take a variable name as an argument.</p>

<p>Unfortunately, Ruby has no API to dynamically get/set global variables. But we have <code class="language-plaintext highlighter-rouge">eval</code>!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getglobal</span><span class="p">((</span><span class="nb">name</span><span class="p">))</span>
  <span class="n">push</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_setglobal</span><span class="p">((</span><span class="nb">name</span><span class="p">))</span>
  <span class="c1"># there's no way to set a gvar by name/value</span>
  <span class="c1"># but eval can reference locals</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="nb">eval</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> = value"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="defined-keyword"><code class="language-plaintext highlighter-rouge">defined?</code> keyword</h5>

<p>As you may know this keyword can handle pretty much anything:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'defined?(42)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="s2">"expression"</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>

<span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a = 42; defined?(a)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="s2">"local-variable"</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>In some simple cases it doesn’t do any computations. It’s obvious that <code class="language-plaintext highlighter-rouge">42</code> is an expression and <code class="language-plaintext highlighter-rouge">a</code> is a local variable (and there’s no way to remove it by any code between assignment and <code class="language-plaintext highlighter-rouge">defined?</code> check)</p>

<p>More advanced checks use a <code class="language-plaintext highlighter-rouge">defined</code> instruction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'@a = 42; defined?(@a)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setinstancevariable</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:defined</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="kp">true</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>The first argument is a special enum flag that specifies what are we trying to check here:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DefinedType</span>
  <span class="no">DEFINED_NOT_DEFINED</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="no">DEFINED_NIL</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="no">DEFINED_IVAR</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="no">DEFINED_LVAR</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="no">DEFINED_GVAR</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="no">DEFINED_CVAR</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="no">DEFINED_CONST</span> <span class="o">=</span> <span class="mi">6</span>
  <span class="no">DEFINED_METHOD</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="no">DEFINED_YIELD</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="no">DEFINED_ZSUPER</span> <span class="o">=</span> <span class="mi">9</span>
  <span class="no">DEFINED_SELF</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="no">DEFINED_TRUE</span> <span class="o">=</span> <span class="mi">11</span>
  <span class="no">DEFINED_FALSE</span> <span class="o">=</span> <span class="mi">12</span>
  <span class="no">DEFINED_ASGN</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="no">DEFINED_EXPR</span> <span class="o">=</span> <span class="mi">14</span>
  <span class="no">DEFINED_IVAR2</span> <span class="o">=</span> <span class="mi">15</span>
  <span class="no">DEFINED_REF</span> <span class="o">=</span> <span class="mi">16</span>
  <span class="no">DEFINED_FUNC</span> <span class="o">=</span> <span class="mi">17</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I’ll show you the branch that handles instance variables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_defined</span><span class="p">(</span><span class="n">defined_type</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">needstr</span><span class="p">)</span>
  <span class="c1"># used only in DEFINED_FUNC/DEFINED_METHOD branches</span>
  <span class="c1"># but we still have to do `pop` here (even if it's unused)</span>
  <span class="n">context</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">verdict</span> <span class="o">=</span>
    <span class="k">case</span> <span class="n">defined_type</span>
    <span class="k">when</span> <span class="no">DefinedType</span><span class="o">::</span><span class="no">DEFINED_IVAR</span>
      <span class="n">ivar_name</span> <span class="o">=</span> <span class="n">obj</span>
      <span class="k">if</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">instance_variable_defined?</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
        <span class="s1">'instance-variable'</span>
      <span class="k">end</span>
    <span class="c1"># ... other branches</span>
    <span class="k">end</span>

  <span class="n">push</span><span class="p">(</span><span class="n">verdict</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>All other branches are similar, they do some check and push a constant string or <code class="language-plaintext highlighter-rouge">nil</code> back to the stack.</p>

<h5 id="range-literals">Range literals</h5>

<p>For static ranges (like <code class="language-plaintext highlighter-rouge">(1..2)</code>) Ruby uses inlining and a well-known <code class="language-plaintext highlighter-rouge">putobject</code> instruction. But what if it’s dynamic? Like <code class="language-plaintext highlighter-rouge">(a..b)</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a = 3; b = 4; p (a..b); p (a...b)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newrange</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:pop</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newrange</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>There’s a special <code class="language-plaintext highlighter-rouge">newrange</code> instruction that takes a flag as an argument to specify inclusion of the right side (i.e. to distinguish <code class="language-plaintext highlighter-rouge">..</code> vs <code class="language-plaintext highlighter-rouge">...</code>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_newrange</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
  <span class="n">high</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">low</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">push</span><span class="p">(</span><span class="no">Range</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="long-jumps">Long jumps</h5>

<p>This is probably the most complicated part. What if you have a method that has a loop inside a loop that does <code class="language-plaintext highlighter-rouge">return</code>? You want to stop executing both loops and simply exit the method, right?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span>
  <span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">m</span>
</code></pre></div></div>

<p>Of course you can just find the closest frame that supports <code class="language-plaintext highlighter-rouge">return</code>-ing (i.e. a <code class="language-plaintext highlighter-rouge">MethodFrame</code>), but you also need to stop execution of two running methods and blocks. In our case it’s even more complicated because we don’t control them (they are written in C).</p>

<p>The only way I was able to find is to throw an exception. An exception destroys all frames (including YARV’s C frames) until it finds someone who can catch and handle it. If there’s no such frame the programs exits with an error.</p>

<p>Let’s create a special exception class called <code class="language-plaintext highlighter-rouge">VM::LongJumpError</code>. Each frame class has to know what it can handle (for example, you can do <code class="language-plaintext highlighter-rouge">break</code> in a block, but not in a method; <code class="language-plaintext highlighter-rouge">return</code> is normally supported only by methods and lambdas, etc):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LongJumpError</span>  <span class="o">&lt;</span> <span class="no">InternalError</span>
  <span class="nb">attr_reader</span> <span class="ss">:value</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">do_jump!</span>
    <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s1">'Not implemented'</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">message</span>
    <span class="s2">"</span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="vi">@value</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ReturnError</span> <span class="o">&lt;</span> <span class="no">LongJumpError</span>
  <span class="k">def</span> <span class="nf">do_jump!</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">current_frame</span>

    <span class="k">if</span> <span class="n">frame</span><span class="p">.</span><span class="nf">can_return?</span>
      <span class="c1"># swallow and consume</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">returning</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">value</span>
    <span class="k">else</span>
      <span class="n">pop_frame</span><span class="p">(</span><span class="ss">reason: </span><span class="s2">"longjmp (return) </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
      <span class="k">raise</span> <span class="nb">self</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Each longjmp exception wraps the value that it “returns” with (or “breaks” with, for <code class="language-plaintext highlighter-rouge">break</code> we need a separate class, but I’m going to skip it here. <code class="language-plaintext highlighter-rouge">break</code>/<code class="language-plaintext highlighter-rouge">next</code> and other friends are really similar to <code class="language-plaintext highlighter-rouge">return</code>).</p>

<p>But we need to catch them, right? Without a <code class="language-plaintext highlighter-rouge">rescue</code> handler we will have something conceptually similar to segfault:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">)</span>
  <span class="n">push_frame</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="c1"># here comes the difference:</span>
  <span class="c1"># we wrap executing instructions into a rescue handler</span>
  <span class="k">begin</span>
    <span class="n">evaluate_last_frame</span>
  <span class="k">rescue</span> <span class="no">LongJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="n">e</span><span class="p">.</span><span class="nf">do_jump!</span>
  <span class="k">end</span>
  <span class="n">pop_frame</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The only missing thing is the implementation of <code class="language-plaintext highlighter-rouge">can_return?</code> method in our frames. All frames except <code class="language-plaintext highlighter-rouge">MethodFrame</code> (and <code class="language-plaintext highlighter-rouge">BlockFrame</code> it it’s marked as <code class="language-plaintext highlighter-rouge">lambda</code>) must return <code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">MethodFrame</code> must return <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>MRI uses a special instruction called <code class="language-plaintext highlighter-rouge">throw</code> that has a single argument that is a <code class="language-plaintext highlighter-rouge">throw_type</code> (an enum, for <code class="language-plaintext highlighter-rouge">return</code> it’s 1, <code class="language-plaintext highlighter-rouge">break</code> is 3, <code class="language-plaintext highlighter-rouge">next</code> is 4, there are also <code class="language-plaintext highlighter-rouge">retry</code>/<code class="language-plaintext highlighter-rouge">redo</code> and a few more). The value that must be attached to the thrown exception comes from the stack (so this instruction does a single <code class="language-plaintext highlighter-rouge">pop</code>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VM_THROW_STATE_MASK</span> <span class="o">=</span> <span class="mh">0xff</span>

<span class="no">RUBY_TAG_NONE</span> <span class="o">=</span> <span class="mh">0x0</span>
<span class="no">RUBY_TAG_RETURN</span> <span class="o">=</span> <span class="mh">0x1</span>
<span class="no">RUBY_TAG_BREAK</span> <span class="o">=</span> <span class="mh">0x2</span>
<span class="no">RUBY_TAG_NEXT</span> <span class="o">=</span> <span class="mh">0x3</span>
<span class="no">RUBY_TAG_RETRY</span> <span class="o">=</span> <span class="mh">0x4</span>
<span class="no">RUBY_TAG_REDO</span> <span class="o">=</span> <span class="mh">0x5</span>
<span class="no">RUBY_TAG_RAISE</span> <span class="o">=</span> <span class="mh">0x6</span>
<span class="no">RUBY_TAG_THROW</span> <span class="o">=</span> <span class="mh">0x7</span>
<span class="no">RUBY_TAG_FATAL</span> <span class="o">=</span> <span class="mh">0x8</span>
<span class="no">RUBY_TAG_MASK</span> <span class="o">=</span> <span class="mh">0xf</span>

<span class="k">def</span> <span class="nf">execute_throw</span><span class="p">(</span><span class="n">throw_type</span><span class="p">)</span>
  <span class="n">throw_type</span> <span class="o">=</span> <span class="n">throw_type</span> <span class="o">&amp;</span> <span class="no">VM_THROW_STATE_MASK</span>
  <span class="n">throw_obj</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="k">case</span> <span class="n">throw_type</span>
  <span class="k">when</span> <span class="no">RUBY_TAG_RETURN</span>
    <span class="k">raise</span> <span class="no">VM</span><span class="o">::</span><span class="no">ReturnError</span><span class="p">,</span> <span class="n">throw_obj</span>
  <span class="k">when</span> <span class="no">RUBY_TAG_BREAK</span>
    <span class="k">raise</span> <span class="no">VM</span><span class="o">::</span><span class="no">BreakError</span><span class="p">,</span> <span class="n">throw_obj</span>
  <span class="k">when</span> <span class="no">RUBY_TAG_NEXT</span>
    <span class="k">raise</span> <span class="no">VM</span><span class="o">::</span><span class="no">NextError</span><span class="p">,</span> <span class="n">throw_obj</span>
  <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="longjmp-in-mri">longjmp in MRI</h5>

<p>But does it work in the same way in MRI? C doesn’t have exceptions. And at the same time there is a bunch of places where MRI does something like</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ARY_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eArgError</span><span class="p">,</span> <span class="s">"array size too big"</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// handle validated data</span>
</code></pre></div></div>

<p>This <code class="language-plaintext highlighter-rouge">rb_raise</code> somehow exits a C function. Well, here’s the trick: non-local <code class="language-plaintext highlighter-rouge">goto</code>.</p>

<p>There are syscalls that perform a goto to any place (that was previously marked of course, similar to labels for a local goto):</p>

<ul>
  <li><a href="https://linux.die.net/man/3/sigsetjmp"><code class="language-plaintext highlighter-rouge">setjmp</code></a></li>
  <li><a href="https://linux.die.net/man/3/longjmp"><code class="language-plaintext highlighter-rouge">longjmp</code></a></li>
</ul>

<blockquote>
  <p>setjmp() saves the stack context/environment in env for later use by <code class="language-plaintext highlighter-rouge">longjmp</code></p>
</blockquote>

<p>… also known as “context switch”. And it’s relatively expensive.</p>

<p>Even if you don’t <code class="language-plaintext highlighter-rouge">raise</code> an exception and only do <code class="language-plaintext highlighter-rouge">begin; ...; rescue; end</code> in your code you still have to save the context (to jump to it once you <code class="language-plaintext highlighter-rouge">raise</code> an error). MRI doesn’t know at compile time which methods can throw an error (and do you throw them at all), so each <code class="language-plaintext highlighter-rouge">rescue</code> produces a <code class="language-plaintext highlighter-rouge">setjmp</code> syscall (and each <code class="language-plaintext highlighter-rouge">raise</code> triggers a <code class="language-plaintext highlighter-rouge">longjmp</code> and passes <code class="language-plaintext highlighter-rouge">closest rescue</code> -&gt; <code class="language-plaintext highlighter-rouge">saved env</code> as an argument)</p>

<h5 id="rescueensure"><code class="language-plaintext highlighter-rouge">rescue</code>/<code class="language-plaintext highlighter-rouge">ensure</code></h5>

<p>So now we know that raise/rescue works via long jumps under the hood. Let’s implement our own exceptions.</p>

<p>By sticking to MRI exceptions we can unwrap both internal and our stacks at the same time. I’m not going to override <code class="language-plaintext highlighter-rouge">raise</code>, it should do what it originally does, but we still need to support our own <code class="language-plaintext highlighter-rouge">rescue</code> blocks. Let’s see what MRI gives us:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'begin; p "x"; rescue A; p "y"; end'</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">[</span> <span class="c1"># ...snip</span>
 <span class="p">[[</span><span class="ss">:rescue</span><span class="p">,</span>
   <span class="p">[</span> <span class="c1"># ...snip</span>
    <span class="s2">"rescue in &lt;compiled&gt;"</span><span class="p">,</span>
    <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
    <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="ss">:rescue</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:"</span><span class="se">\#</span><span class="ss">$!"</span><span class="p">],</span>
    <span class="p">{},</span>
    <span class="p">[],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:A</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:checkmatch</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:branchif</span><span class="p">,</span> <span class="ss">:label_11</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:jump</span><span class="p">,</span> <span class="ss">:label_19</span><span class="p">],</span>
     <span class="ss">:label_11</span><span class="p">,</span>
     <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:putstring</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:leave</span><span class="p">],</span>
     <span class="ss">:label_19</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:throw</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span>
   <span class="ss">:label_0</span><span class="p">,</span>
   <span class="ss">:label_7</span><span class="p">,</span>
   <span class="ss">:label_8</span><span class="p">,</span>
   <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:retry</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:label_7</span><span class="p">,</span> <span class="ss">:label_8</span><span class="p">,</span> <span class="ss">:label_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
 <span class="p">[</span><span class="ss">:label_0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span>
  <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:putstring</span><span class="p">,</span> <span class="s2">"x"</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
  <span class="ss">:label_7</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:nop</span><span class="p">],</span>
  <span class="ss">:label_8</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]</span>
</code></pre></div></div>

<p>An instruction sequence that has some <code class="language-plaintext highlighter-rouge">rescue</code> blocks inside includes all information about them (in the element #12, right above an instructions list). Each rescue handler is a frame with its own list of variables and instructions. Its <code class="language-plaintext highlighter-rouge">kind</code> is <code class="language-plaintext highlighter-rouge">:rescue</code> and is has at least one local variable: <code class="language-plaintext highlighter-rouge">$!</code>. It starts with a dollar sign, but it’s a local variable. According to its semantics it has to be a local variable, but unfortunately it can’t look like a local variable (because it’d would potentially conflict with method calls). I mean, that’s how I explain it to myself, I don’t know for sure what was the initial reason to design it this way.</p>

<p>It also has a few labels at the bottom - <code class="language-plaintext highlighter-rouge">:label_7, :label_8, :label_0</code>:</p>

<ul>
  <li>the first label is a “begin” label. It marks where the (potentially) critical section of your code begins</li>
  <li>the second label is an “end” label</li>
  <li>the third label is an “exit” label. It marks where we should jump to if the error has been caught and handled.</li>
</ul>

<p>A top-level instruction also contains these labels, and the meaning of them is:</p>

<ul>
  <li>if we evaluate instructions and we see a label that is a “begin” label of some rescue handler we <strong>enable</strong> the handler</li>
  <li>if we see a label that is an “end” of some rescue handler we <strong>disable</strong> it</li>
  <li>if we execute a single instruction and catch an exception we:
    <ul>
      <li>iterate over all <strong>enabled</strong> rescue handlers</li>
      <li>and for each of them we push a <code class="language-plaintext highlighter-rouge">RescueFrame</code> with a rescue iseq</li>
      <li>and we set a <code class="language-plaintext highlighter-rouge">$!</code> variable in this frame to the error that we have just caught</li>
      <li>the rescue frame decides where to go next:
        <ul>
          <li>back to the original frame via <code class="language-plaintext highlighter-rouge">jump</code> to the “exit” label after doing <code class="language-plaintext highlighter-rouge">pop_frame</code></li>
          <li>or somewhere else via re-raise (if the iseq contains it)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Let’s code it!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ISeq</span>
  <span class="nb">attr_reader</span> <span class="ss">:rescue_handlers</span>
  <span class="nb">attr_reader</span> <span class="ss">:ensure_handlers</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ruby_iseq</span><span class="p">)</span>
    <span class="vi">@ruby_iseq</span> <span class="o">=</span> <span class="n">ruby_iseq</span>
    <span class="n">reset!</span>
    <span class="n">setup_rescue_handlers!</span>
    <span class="n">setup_ensure_handlers!</span>
  <span class="k">end</span>

  <span class="c1"># ... other existing methods on ISeq class</span>

  <span class="k">def</span> <span class="nf">setup_rescue_handlers!</span>
    <span class="vi">@rescue_handler</span> <span class="o">=</span> <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:rescue</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span><span class="o">|</span> <span class="no">Handler</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">setup_ensure_handlers!</span>
    <span class="vi">@ensure_handler</span> <span class="o">=</span> <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:ensure</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span><span class="o">|</span> <span class="no">Handler</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Handler</span>
    <span class="nb">attr_reader</span> <span class="ss">:iseq</span>
    <span class="nb">attr_reader</span> <span class="ss">:begin_label</span><span class="p">,</span> <span class="ss">:end_label</span><span class="p">,</span> <span class="ss">:exit_label</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span>
      <span class="vi">@iseq</span> <span class="o">=</span> <span class="n">iseq</span>
      <span class="vi">@begin_label</span><span class="p">,</span> <span class="vi">@end_label</span><span class="p">,</span> <span class="vi">@exit_label</span> <span class="o">=</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So now each <code class="language-plaintext highlighter-rouge">iseq</code> object has two getters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">rescue_handlers</code></li>
  <li><code class="language-plaintext highlighter-rouge">ensure_handlers</code></li>
</ul>

<p>Frames must know which handlers are active (but not instruction sequences, because methods can recursively call themselves and so the same iseq will be reused; it’s a per-frame property):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrameClass</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span>
    <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
      <span class="c1"># Both must be set to `Set.new` in the constructor</span>
      <span class="nb">attr_accessor</span> <span class="ss">:enabled_rescue_handlers</span>
      <span class="nb">attr_accessor</span> <span class="ss">:enabled_ensure_handlers</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So this way all frames have it too. Every time when we see a label in our execution loop we need to check if it matches any <code class="language-plaintext highlighter-rouge">begin_label</code> or <code class="language-plaintext highlighter-rouge">end_label</code> of our <code class="language-plaintext highlighter-rouge">current_frame.iseq.rescue_handlers</code> (or <code class="language-plaintext highlighter-rouge">ensure_handlers</code>):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">on_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">current_iseq</span><span class="p">.</span><span class="nf">rescue_handlers</span> <span class="o">=&gt;</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">enabled_rescue_handlers</span><span class="p">,</span>
    <span class="n">current_iseq</span><span class="p">.</span><span class="nf">ensure_handlers</span> <span class="o">=&gt;</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">enabled_ensure_handlers</span><span class="p">,</span>
  <span class="p">}.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">all_handlers</span><span class="p">,</span> <span class="n">enabled_handlers</span><span class="o">|</span>
    <span class="n">all_handlers</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">.</span><span class="nf">begin_label</span> <span class="o">==</span> <span class="n">label</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">enabled_handlers</span> <span class="o">&lt;&lt;</span> <span class="n">handler</span> <span class="p">}</span>

    <span class="n">all_handlers</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">.</span><span class="nf">end_label</span> <span class="o">==</span> <span class="n">label</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">enabled_handlers</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>side note: when we do a local <code class="language-plaintext highlighter-rouge">jump</code> we should also walk through skipped instructions and enable/disable our handlers; this is important</p>

<p>OK, now the only missing part is the reworked execution loop:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># a generic runner that is used inside the loop</span>
<span class="k">def</span> <span class="nf">execute_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">insn</span>
  <span class="k">when</span> <span class="p">[</span><span class="ss">:leave</span><span class="p">]</span>
    <span class="n">current_frame</span><span class="p">.</span><span class="nf">returning</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">when</span> <span class="no">Array</span>
    <span class="nb">name</span><span class="p">,</span> <span class="o">*</span><span class="n">payload</span> <span class="o">=</span> <span class="n">insn</span>

    <span class="n">with_error_handling</span> <span class="k">do</span>
      <span class="nb">send</span><span class="p">(</span><span class="ss">:"execute_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="ss">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="c1"># -- new branch for labels --</span>
  <span class="k">when</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"label_</span><span class="se">\\</span><span class="s2">d+"</span><span class="p">)</span>
    <span class="n">on_label</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="c1"># ignore</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># a wrapper that catches and handles error</span>
<span class="k">def</span> <span class="nf">with_error_handling</span>
  <span class="k">yield</span>
<span class="k">rescue</span> <span class="no">VM</span><span class="o">::</span><span class="no">InternalError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># internal errors like LongJumpError should be invisible for users</span>
  <span class="k">raise</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">handle_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rescue_handler</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">enabled_rescue_handler</span><span class="p">.</span><span class="nf">first</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">rescue_handler</span><span class="p">.</span><span class="nf">iseq</span><span class="p">,</span> <span class="ss">caught: </span><span class="n">error</span><span class="p">,</span> <span class="ss">exit_to: </span><span class="n">rescue_handler</span><span class="p">.</span><span class="nf">exit_label</span><span class="p">)</span>
    <span class="n">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="n">error</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># This guy also needs customization to support `jump(exit_label)`</span>
<span class="k">def</span> <span class="nf">pop_frame</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="vi">@frame_stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">if</span> <span class="n">frame</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">RescueFrame</span><span class="p">)</span>
    <span class="n">jump</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="nf">exit_to</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">frame</span><span class="p">.</span><span class="nf">returning</span>
<span class="k">end</span>

<span class="c1"># And here's the rescue frame implementation</span>
<span class="no">RescueFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">attr_reader</span> <span class="ss">:parent_frame</span><span class="p">,</span> <span class="ss">:caught</span><span class="p">,</span> <span class="ss">:exit_to</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">parent_frame</span><span class="p">:,</span> <span class="n">caught</span><span class="p">:,</span> <span class="n">exit_to</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">nesting</span>

    <span class="vi">@parent_frame</span> <span class="o">=</span> <span class="n">parent_frame</span>
    <span class="vi">@caught</span> <span class="o">=</span> <span class="n">caught</span>
    <span class="vi">@exit_to</span> <span class="o">=</span> <span class="n">exit_to</span>

    <span class="c1"># $! always has an ID = 3</span>
    <span class="n">locals</span><span class="p">.</span><span class="nf">declare</span><span class="p">(</span><span class="ss">id: </span><span class="mi">3</span><span class="p">,</span> <span class="ss">name: :"</span><span class="se">\#</span><span class="ss">$!"</span><span class="p">)</span>
    <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">id: </span><span class="mi">3</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">caught</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>But why do we handle only the first handler? Can there be multiple handlers? The answer is no, because:</p>

<ul>
  <li>MRI merges multiple consecutive <code class="language-plaintext highlighter-rouge">rescue</code> handlers (by using <code class="language-plaintext highlighter-rouge">case error</code> branching in a rescue body)</li>
  <li><code class="language-plaintext highlighter-rouge">rescue</code> itself is frame, and so nested <code class="language-plaintext highlighter-rouge">rescue</code> is a rescue handler of the rescue handler</li>
</ul>

<h5 id="throwcatch-methods"><code class="language-plaintext highlighter-rouge">throw</code>/<code class="language-plaintext highlighter-rouge">catch</code> methods</h5>

<p>As a side (and I personally think a very interesting) note, while I was working on this project I’ve realized that specs for <code class="language-plaintext highlighter-rouge">Kernel#throw</code> are not working for me at all. They were literally completely broken (even after I finished working on a very basic implementation of exceptions):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">catch</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">begin</span>
    <span class="kp">throw</span> <span class="ss">:x</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="nb">puts</span> <span class="n">e</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This code doesn’t print anything. However, if you do just <code class="language-plaintext highlighter-rouge">throw :x</code> you get an exception:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kp">throw</span> <span class="ss">:x</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">14</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">14</span><span class="ss">:in</span> <span class="sb">`throw'
UncaughtThrowError (uncaught throw :x)
</span></code></pre></div></div>

<p>Huh, what’s going on? Let’s take a look at the implementation of <code class="language-plaintext highlighter-rouge">Kernel#throw</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">rb_throw_obj</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">tag</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">rb_execution_context_t</span> <span class="o">*</span><span class="n">ec</span> <span class="o">=</span> <span class="n">GET_EC</span><span class="p">();</span>
    <span class="k">struct</span> <span class="n">rb_vm_tag</span> <span class="o">*</span><span class="n">tt</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">tt</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">tt</span> <span class="o">=</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tt</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">VALUE</span> <span class="n">desc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
      <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
      <span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
      <span class="n">desc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rb_str_new_cstr</span><span class="p">(</span><span class="s">"uncaught throw %p"</span><span class="p">);</span>
      <span class="n">rb_exc_raise</span><span class="p">(</span><span class="n">rb_class_new_instance</span><span class="p">(</span><span class="n">numberof</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="n">desc</span><span class="p">,</span> <span class="n">rb_eUncaughtThrow</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">ec</span><span class="o">-&gt;</span><span class="n">errinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span><span class="p">)</span><span class="n">THROW_DATA_NEW</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TAG_THROW</span><span class="p">);</span>
    <span class="n">EC_JUMP_TAG</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">TAG_THROW</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code raises an instance of <code class="language-plaintext highlighter-rouge">rb_eUncaughtThrow</code> only in one case: if there’s no frame above that may “catch” it (like in the case when we did just <code class="language-plaintext highlighter-rouge">throw :x</code>).</p>

<p>However if there’s a frame somewhere above that has the same tag MRI performs a manual <code class="language-plaintext highlighter-rouge">longjmp</code>. This is why we can’t catch this exception. There’s simply no exception if there’s a <code class="language-plaintext highlighter-rouge">catch(:x)</code> above (but there would be an exception if we would do <code class="language-plaintext highlighter-rouge">catch(:y) { throw :x }</code>).</p>

<p>Is it faster? Let’s see</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'benchmark/ips'</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">config</span><span class="p">(</span><span class="ss">:time</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span>

  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'raise'</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">'x'</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'throw'</span><span class="p">)</span> <span class="k">do</span>
    <span class="kp">catch</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="k">do</span>
      <span class="kp">throw</span> <span class="ss">:x</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">x</span><span class="p">.</span><span class="nf">compare!</span>
<span class="k">end</span>

<span class="err">$</span> <span class="n">ruby</span> <span class="n">benchmark</span><span class="p">.</span><span class="nf">rb</span>
<span class="no">Warming</span> <span class="n">up</span> <span class="o">--------------------------------------</span>
               <span class="k">raise</span>   <span class="mf">101.832</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
               <span class="kp">throw</span>   <span class="mf">256.893</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
<span class="no">Calculating</span> <span class="o">-------------------------------------</span>
               <span class="k">raise</span>      <span class="mf">1.310</span><span class="no">M</span> <span class="p">(</span><span class="err">±</span> <span class="mf">4.2</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>      <span class="mf">3.971</span><span class="no">M</span> <span class="k">in</span>   <span class="mf">3.037942</span><span class="n">s</span>
               <span class="kp">throw</span>      <span class="mf">4.853</span><span class="no">M</span> <span class="p">(</span><span class="err">±</span> <span class="mf">3.0</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>     <span class="mf">14.643</span><span class="no">M</span> <span class="k">in</span>   <span class="mf">3.020227</span><span class="n">s</span>

<span class="no">Comparison</span><span class="p">:</span>
               <span class="ss">throw:  </span><span class="mf">4852821.4</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span>
               <span class="ss">raise:  </span><span class="mf">1309915.6</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span> <span class="mf">3.70</span><span class="n">x</span>  <span class="n">slower</span>
</code></pre></div></div>

<p>As expected, it’s faster. But what’s more important, let’s see what if there are more frames between <code class="language-plaintext highlighter-rouge">raise/rescue</code> and <code class="language-plaintext highlighter-rouge">throw/catch</code>. First, let’s create a small method that wraps given code into N frames:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">in_n_frames</span><span class="p">(</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">blk</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">n</span>
    <span class="n">blk</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">else</span>
    <span class="n">in_n_frames</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">blk</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">begin</span>
  <span class="n">in_n_frames</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="nb">proc</span> <span class="p">{</span> <span class="k">raise</span> <span class="s1">'err'</span> <span class="p">})</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">p</span> <span class="n">e</span><span class="p">.</span><span class="nf">backtrace</span><span class="p">.</span><span class="nf">length</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It prints <code class="language-plaintext highlighter-rouge">1003</code>, because there’s also a <code class="language-plaintext highlighter-rouge">TopFrame</code> and a <code class="language-plaintext highlighter-rouge">BlockFrame</code> (and a small bug that does +1), but that’s absolutely ok for us.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="n">benchmark</span><span class="p">.</span><span class="nf">rb</span>
<span class="no">Warming</span> <span class="n">up</span> <span class="o">--------------------------------------</span>
               <span class="k">raise</span>     <span class="mf">1.061</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
               <span class="kp">throw</span>     <span class="mf">1.115</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
<span class="no">Calculating</span> <span class="o">-------------------------------------</span>
               <span class="k">raise</span>     <span class="mf">10.628</span><span class="n">k</span> <span class="p">(</span><span class="err">±</span> <span class="mf">1.3</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>     <span class="mf">32.891</span><span class="n">k</span> <span class="k">in</span>   <span class="mf">3.095347</span><span class="n">s</span>
               <span class="kp">throw</span>     <span class="mf">11.183</span><span class="n">k</span> <span class="p">(</span><span class="err">±</span> <span class="mf">1.5</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>     <span class="mf">34.565</span><span class="n">k</span> <span class="k">in</span>   <span class="mf">3.091514</span><span class="n">s</span>

<span class="no">Comparison</span><span class="p">:</span>
               <span class="ss">throw:    </span><span class="mf">11183.1</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span>
               <span class="ss">raise:    </span><span class="mf">10627.8</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span> <span class="mf">1.05</span><span class="n">x</span>  <span class="n">slower</span>
</code></pre></div></div>

<p>There’s almost no difference! The reason is simple: the only thing that is different is creation of the exception object. <code class="language-plaintext highlighter-rouge">throw</code> doesn’t do it.</p>

<h5 id="utility-instructions">Utility instructions</h5>

<p>There are also a few interesting instructions that MRI uses to evaluate your complex code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">adjuststack(n)</code> - does <code class="language-plaintext highlighter-rouge">n.times { pop }</code></li>
  <li><code class="language-plaintext highlighter-rouge">nop</code> - literally does nothing</li>
  <li><code class="language-plaintext highlighter-rouge">dupn(n)</code> - does <code class="language-plaintext highlighter-rouge">pop</code> N times and then pushes them twice (or basically duplicates N last items)</li>
  <li><code class="language-plaintext highlighter-rouge">setn(n)</code> - does <code class="language-plaintext highlighter-rouge">stack[-n-1] = stack.top</code></li>
  <li><code class="language-plaintext highlighter-rouge">topn(n)</code> - does <code class="language-plaintext highlighter-rouge">push(stack[-n-1])</code></li>
  <li><code class="language-plaintext highlighter-rouge">swap</code> - swaps top two stack elements</li>
  <li><code class="language-plaintext highlighter-rouge">dup</code> - like <code class="language-plaintext highlighter-rouge">dupn(1)</code></li>
  <li><code class="language-plaintext highlighter-rouge">reverse(n)</code> - reverses N stack elements (i.e. does <code class="language-plaintext highlighter-rouge">n.times.map { pop }.each { |value| push(value) }</code>)</li>
</ul>

<h3 id="final-words">Final words</h3>

<p>First of all, I’d like to say thank you to everyone who made YARV. I wasn’t able to find a single place where MRI behaves inefficiently (and I spent many hours looking into instructions).</p>

<p>Once again, the code is available <a href="https://github.com/iliabylich/my.rb">here</a>, feel free to create issues/message me in Twitter. And please, don’t use it in the real world.</p>]]></content><author><name></name></author><category term="ruby" /><category term="vm" /><summary type="html"><![CDATA[Evaluating Ruby in Ruby]]></summary></entry><entry><title type="html">My favorite parts of Ruby</title><link href="https://iliabylich.github.io/2018/07/18/my-favorite-parts-of-ruby.html" rel="alternate" type="text/html" title="My favorite parts of Ruby" /><published>2018-07-18T21:00:00+00:00</published><updated>2018-07-18T21:00:00+00:00</updated><id>https://iliabylich.github.io/2018/07/18/my-favorite-parts-of-ruby</id><content type="html" xml:base="https://iliabylich.github.io/2018/07/18/my-favorite-parts-of-ruby.html"><![CDATA[<p><strong>Disclaimer #1</strong> first of all I’d like to say that I really like Ruby. I write a ton of Ruby code every single day and I prefer it over other languages. Please, do not take it seriously, Ruby is nice, and this post is mostly a joke.</p>

<p><strong>Disclaimer #2</strong> I’m not going to cover popular things like flip-flops (thanks God they are deprecated in 2.6.0).</p>

<p>I was thinking for a while which item should go first, but finally I had to give up. I think all items are funny.</p>

<h3 id="regexp-o-flag">Regexp ‘o’ flag</h3>

<p>I don’t even know if there’s anyone in the world using it. <code class="language-plaintext highlighter-rouge">o</code> flag is a very, very magical thing that “freezes” a regexp after parsing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="mi">1</span><span class="p">.</span><span class="nf">upto</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="sr">/</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="sr">/o</span><span class="p">.</span><span class="nf">source</span> <span class="p">}</span>
<span class="mi">1</span>
<span class="mi">1</span>
<span class="mi">1</span>
<span class="mi">1</span>
<span class="mi">1</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="mi">3</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="sr">/</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="sr">/o</span><span class="p">.</span><span class="nf">object_id</span> <span class="p">}</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="mi">70135960411140</span><span class="p">,</span> <span class="mi">70135960411140</span><span class="p">,</span> <span class="mi">70135960411140</span><span class="p">]</span>
</code></pre></div></div>

<p>That’s a hacky way to define an inline regexp as a constant. It is a constant because its value is constant (<code class="language-plaintext highlighter-rouge">object_id</code> returns the same value). I think the main purpose of such flag is to reduce objects allocation, and I believe it wasn’t initially designed for such cases. If you are too lazy to extract a static regexp to a constant, simply add an <code class="language-plaintext highlighter-rouge">o</code> flag.</p>

<h3 id="invalid-encodings">Invalid encodings</h3>

<p>Well, I have to confess, sometimes I hate Ruby for various reasons, this feature is one of them.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># encoding: utf-8</span>

<span class="n">s</span> <span class="o">=</span> <span class="s2">"</span><span class="se">\xff</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="n">s</span><span class="p">.</span><span class="nf">encoding</span>
<span class="nb">puts</span> <span class="n">s</span><span class="p">.</span><span class="nf">valid_encoding?</span>
<span class="nb">puts</span> <span class="n">s</span><span class="p">.</span><span class="nf">bytes</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby test.rb
ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17]
UTF-8
false
255
</code></pre></div></div>

<p>In this case string is not a “real” string. This bytes sequence is simply invalid for UTF-8 (in UTF-8 any codepoint &gt; 127 works as a flag that indicates that the char is multibyte and the next char (or chars) defines a real value), but Ruby allows it. It’s not even a String, it’s just a container of bytes. And for some reason Ruby allows you to pack an arbitrary sequence of bytes into a string, and if you want to ask “Is it valid?” you have a (I think) conceptually wrong <code class="language-plaintext highlighter-rouge">String#valid_encoding?</code> method. Maybe the right way to solve it would be to:</p>

<ol>
  <li>reject such strings during parsing (and throw SyntaxError)</li>
  <li>raise an error when someone tries to put wrong bytes sequence to the string</li>
  <li>remove <code class="language-plaintext highlighter-rouge">String#valid_encoding?</code> method</li>
</ol>

<h3 id="nested-heredocs">Nested heredocs</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="o">&lt;&lt;</span><span class="s2">"A</span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">C"</span>
<span class="c1">#{</span>
  <span class="o">&lt;&lt;</span><span class="s2">"A</span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">C"</span>
<span class="no">A</span><span class="c1">#{b}C</span>
<span class="p">}</span>
<span class="n">str</span>
<span class="no">A</span><span class="c1">#{b}C</span>
</code></pre></div></div>

<p>Nuff said, I’m quite sure that there are no syntax highlighters that can handle this code. GitHub can’t and Svbtle can’t as well. Try evaluating this code in IRB.</p>

<h3 id="setters-and-return-values">Setters and return values</h3>

<p>As you most probably know in Ruby setters can’t have return values. They always return their arguments:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">42</span>
<span class="k">end</span>

<span class="nb">self</span><span class="p">.</span><span class="nf">m</span> <span class="o">=</span> <span class="s1">'return me'</span>
<span class="c1"># =&gt; "return me"</span>
</code></pre></div></div>

<p>Yes, you can make a return by calling a setter method using <code class="language-plaintext highlighter-rouge">Kernel#send</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="nb">send</span><span class="p">(</span><span class="ss">:m</span><span class="o">=</span><span class="p">,</span> <span class="s1">'return me'</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">42</span>
</code></pre></div></div>

<p>So, the general rule is like “if you call a setter method without :send you can’t make a return”. Wrong!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="mi">42</span><span class="p">;</span> <span class="k">end</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">[</span><span class="p">]</span><span class="o">=</span> <span class="s1">'return me'</span>
<span class="o">=&gt;</span> <span class="mi">42</span>
</code></pre></div></div>

<p>I can’t imagine any reason to use such syntax, most probably it should be deprecated.</p>

<h3 id="passing-blocks-to-the--method-aref">Passing blocks to the [] method (aref)</h3>

<p>Imagine the following piece of code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

<span class="nb">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">}</span>
</code></pre></div></div>

<p>Looks valid, right? We pass a positional argument <code class="language-plaintext highlighter-rouge">1</code> and a block that returns <code class="language-plaintext highlighter-rouge">2</code> to the method called <code class="language-plaintext highlighter-rouge">[]</code>. The method should print <code class="language-plaintext highlighter-rouge">3</code>. Let’s run it with Ruby 2.5:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby -v test.rb
2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17]
3
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">1 + 2 == 3</code>, everything is ok. Let’s try 2.4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby -v test.rb
ruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-darwin17]
test.rb:5: syntax error, unexpected { arg, expecting end-of-input
self[1] { 2 }
         ^
</code></pre></div></div>

<p>Yes, this syntax was introduced in Ruby 2.5. Did you hear any announcements about it?</p>

<p><strong>Spoiler: there are no tests for this syntax in ruby/ruby repo. Guess why?</strong></p>

<h3 id="global-variables">Global variables</h3>

<p>Let’s take a simple code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">join</span>
<span class="o">=&gt;</span> <span class="s2">"123"</span>
</code></pre></div></div>

<p>Do you know anything about “pure” functions (or pure methods in this case)? Ideally methods should only use <code class="language-plaintext highlighter-rouge">self</code> and provided arguments. Relying on any global state is bad because you are not the only one who can mutate it.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="vg">$,</span> <span class="o">=</span> <span class="s1">'Ruby'</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">join</span>
<span class="o">=&gt;</span> <span class="s2">"1Ruby2Ruby3"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">String#join</code> uses a global variable as a default value for the separator. Literally <code class="language-plaintext highlighter-rouge">def join(sep = $,)</code>.</p>

<p>By the way, maybe I should put the following code to my current project before leaving it. How much time is needed to find it?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">rand</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
  <span class="vg">$,</span> <span class="o">=</span> <span class="p">[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">101</span><span class="p">].</span><span class="nf">pack</span><span class="p">(</span><span class="s1">'c*'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>After doing <code class="language-plaintext highlighter-rouge">require 'english'</code> you get two aliases for this global variable: <code class="language-plaintext highlighter-rouge">$OUTPUT_FIELD_SEPARATOR</code> and <code class="language-plaintext highlighter-rouge">$OFS</code>, that’s the real name of this global variable.</p>

<h3 id="instance-variables-without--prefix">Instance variables without @ prefix</h3>

<p>Spoiler: you may think that it’s impossible because the parser rejects such code. But in fact, Ruby allows it and there are even some specs for this - <a href="https://github.com/ruby/spec/blob/master/optional/capi/object_spec.rb#L803">RubySpec</a>. I don’t know much about Ruby internals, but at least one class uses ivars without <code class="language-plaintext highlighter-rouge">@</code>, it’s called <code class="language-plaintext highlighter-rouge">Range</code>. <code class="language-plaintext highlighter-rouge">(0..3)</code> has 3 instance variables:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">excl</code> = false</li>
  <li><code class="language-plaintext highlighter-rouge">begin</code> = 0</li>
  <li><code class="language-plaintext highlighter-rouge">end</code> = 3</li>
</ul>

<p>“Any proves?” - let’s marshal it:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\x04\b</span><span class="s2">o:</span><span class="se">\n</span><span class="s2">Range</span><span class="se">\b</span><span class="s2">:</span><span class="se">\t</span><span class="s2">exclF:</span><span class="se">\n</span><span class="s2">begini</span><span class="se">\x00</span><span class="s2">:</span><span class="se">\b</span><span class="s2">endi</span><span class="se">\b</span><span class="s2">"</span>
</code></pre></div></div>

<p>This string contains a version (4.8), an indicator of the object (<code class="language-plaintext highlighter-rouge">o</code>), a symbol <code class="language-plaintext highlighter-rouge">:Range</code>, a hash of instance variables <code class="language-plaintext highlighter-rouge">{ excl: false, begin: 0, end: 3 }</code>.</p>

<p>Let’s change a class name a bit (but keep the same length to not break anything):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Hello</span><span class="p">;</span> <span class="k">end</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s2">"</span><span class="se">\x04\b</span><span class="s2">o:</span><span class="se">\n</span><span class="s2">Hello</span><span class="se">\b</span><span class="s2">:</span><span class="se">\t</span><span class="s2">exclF:</span><span class="se">\n</span><span class="s2">begini</span><span class="se">\x00</span><span class="s2">:</span><span class="se">\b</span><span class="s2">endi</span><span class="se">\b</span><span class="s2">"</span><span class="p">)</span>
                             <span class="o">^^^^^</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Hello:0x00007fece707a9c8&gt;</span>
</code></pre></div></div>

<p>Now we can change, for example, <code class="language-plaintext highlighter-rouge">excl</code> to <code class="language-plaintext highlighter-rouge">@one</code> (again, to keep the length the same):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s2">"</span><span class="se">\x04\b</span><span class="s2">o:</span><span class="se">\n</span><span class="s2">Hello</span><span class="se">\b</span><span class="s2">:</span><span class="se">\t</span><span class="s2">@oneF:</span><span class="se">\n</span><span class="s2">begini</span><span class="se">\x00</span><span class="s2">:</span><span class="se">\b</span><span class="s2">endi</span><span class="se">\b</span><span class="s2">"</span><span class="p">)</span>
                                       <span class="o">^^^^</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Hello:0x00007fece70533a0 @one=false&gt;</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">.</span><span class="nf">instance_variables</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:@one</span><span class="p">]</span>
</code></pre></div></div>

<p>The conclusion is simple: <code class="language-plaintext highlighter-rouge">excl</code> is an instance variable, but <code class="language-plaintext highlighter-rouge">Kernel#instance_variables</code> hides it.</p>

<p><code class="language-plaintext highlighter-rouge">Kernel#instance_variable_get / set</code> and Ruby Lexer are the places that validate instance variable names. Low-level C calls don’t do it and in general when you write a C extension you may easily get an ivar without <code class="language-plaintext highlighter-rouge">@</code> char.</p>

<p>You can read my article about marshalling to get a full overview of its internals.</p>

<h3 id="implicit-coercing">Implicit coercing</h3>

<p>As you may know there are two types of coercing in Ruby: explicit and implicit.</p>

<p>Explicit is when you call methods like <code class="language-plaintext highlighter-rouge">to_a</code>, <code class="language-plaintext highlighter-rouge">to_h</code>, <code class="language-plaintext highlighter-rouge">to_s</code>. When the object is not an Array/Hash/String, but can become it.</p>

<p>Implicit is when Ruby calls methods like <code class="language-plaintext highlighter-rouge">to_ary</code>, <code class="language-plaintext highlighter-rouge">to_hash</code>, <code class="language-plaintext highlighter-rouge">to_str</code> for you. When the object <strong>acts</strong> as an Array/Hash/String and converting it to the corresponding class must happen automatically.</p>

<p>There are a lot of methods in the corelib that are documented as “taking a String as an argument” but in fact they accept any objects that can be implicitly converted to a String.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="n">o</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nc">o</span><span class="o">.</span><span class="nf">to_str</span><span class="p">;</span> <span class="s2">"hello"</span><span class="p">;</span> <span class="k">end</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"string"</span> <span class="o">+</span> <span class="n">o</span>
<span class="o">=&gt;</span> <span class="s2">"stringhello"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"hello"</span><span class="p">.</span><span class="nf">casecmp</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">0</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"testhello"</span><span class="p">.</span><span class="nf">chomp</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"test"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"hellostr"</span><span class="p">.</span><span class="nf">delete_prefix</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"str"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"hello world"</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div>

<p>There are more methods like this, and not only for String.</p>

<p>Also, there’s a way to implicitly convert an abstract Object to</p>

<ul>
  <li>Array (using <code class="language-plaintext highlighter-rouge">*</code>)</li>
  <li>Hash (using <code class="language-plaintext highlighter-rouge">**</code>)</li>
  <li>Proc (using <code class="language-plaintext highlighter-rouge">&amp;</code>)</li>
</ul>

<p>Sometimes it can be ridiculous:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span>
  <span class="k">def</span> <span class="nf">to_ary</span><span class="p">;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">to_hash</span><span class="p">;</span> <span class="p">{</span> <span class="ss">a: </span><span class="mi">1</span> <span class="p">};</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">to_proc</span><span class="p">;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">};</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">rest</span><span class="p">.</span><span class="nf">length</span> <span class="o">+</span> <span class="n">kwargs</span><span class="p">.</span><span class="nf">length</span> <span class="o">+</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

<span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span>
<span class="n">m</span><span class="p">(</span><span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="o">**</span><span class="n">user</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="p">)</span>
<span class="c1"># =&gt; 44</span>
</code></pre></div></div>

<p>I’m not sure that this feature is required. But remember, that’s only my opinion.</p>

<p>Explicit coercing is explicit and forces you to call <code class="language-plaintext highlighter-rouge">to_a/to_h/to_s</code> manually. Probably it would be better to restrict <code class="language-plaintext highlighter-rouge">*/**/&amp;</code> operators to accept only <code class="language-plaintext highlighter-rouge">Array/Hash/Proc</code> objects (and to be as strict as possible).</p>

<h3 id="implicit-to_a">Implicit <code class="language-plaintext highlighter-rouge">to_a</code></h3>

<p>Previous section says that Ruby never invokes methods for explicit coercing on its own. There’s one exception: <code class="language-plaintext highlighter-rouge">to_a</code> method.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">o</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="k">def</span> <span class="nc">o</span><span class="o">.</span><span class="nf">to_a</span><span class="p">;</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="k">end</span>
<span class="k">def</span> <span class="nc">o</span><span class="o">.</span><span class="nf">to_ary</span><span class="p">;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span> <span class="k">end</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">o</span>
<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
<span class="c1"># [4, 5, 6]</span>
<span class="c1"># so, it calls to_ary, that's an implicit coercing</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">o</span>
<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
<span class="c1"># [1, 2, 3]</span>
<span class="c1"># it calls to_a !! an explicit coercing gets called by Ruby</span>
</code></pre></div></div>

<p>For some reason the concept of implicit/explicit coercing doesn’t work for this case.</p>

<h3 id="heredoc-identifiers-and-newlines">HEREdoc identifiers and newlines</h3>

<p>The section about nested heredocs shows a heredoc identifier that has an interpolation inside. Also, it’s possible to use <code class="language-plaintext highlighter-rouge">"\n"</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="o">&lt;&lt;</span><span class="s2">"HERE
"</span>
<span class="n">content</span>
<span class="no">HERE</span>
</code></pre></div></div>

<p>it prints <code class="language-plaintext highlighter-rouge">"content\n"</code>. For some reason newline is not allowed in the middle of the heredoc identifier (and don’t get me wrong, I think that newlines should be rejected, no matter in the middle or in the end).</p>

<h3 id="1if-true"><code class="language-plaintext highlighter-rouge">1if true</code></h3>

<p>Yes, that’s a valid syntax. Ruby has very special rules for whitespaces and newlines. <code class="language-plaintext highlighter-rouge">1i</code> is a special syntax for complex numbers, but <code class="language-plaintext highlighter-rouge">1if true</code> is <code class="language-plaintext highlighter-rouge">1 if true</code>. There’s also a <code class="language-plaintext highlighter-rouge">1r</code> syntax for rational numbers, and yes, <code class="language-plaintext highlighter-rouge">1rescue nil</code> is <code class="language-plaintext highlighter-rouge">1 rescue nil</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="mi">1</span><span class="k">if</span> <span class="kp">true</span>
<span class="mi">1</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="mi">1</span><span class="k">rescue</span> <span class="kp">nil</span>
<span class="mi">1</span>
</code></pre></div></div>

<p>But what about <code class="language-plaintext highlighter-rouge">1ri</code>?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="mi">1</span><span class="n">rif</span> <span class="kp">true</span>
<span class="no">SyntaxError</span><span class="p">:</span> <span class="p">(</span><span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">unexpected</span> <span class="n">tIDENTIFIER</span><span class="p">,</span> <span class="n">expecting</span> <span class="k">end</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">input</span><span class="p">)</span>
<span class="mi">1</span><span class="n">rif</span> <span class="kp">true</span>
 <span class="o">^~~</span>
</code></pre></div></div>

<p>Sweet. Bonus:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="mi">1</span><span class="k">return</span><span class="p">;</span> <span class="k">end</span>
<span class="no">SyntaxError</span> <span class="p">:</span> <span class="p">(</span><span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">unexpected</span> <span class="n">keyword_return</span><span class="p">,</span> <span class="n">expecting</span> <span class="n">keyword_end</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="mi">1</span><span class="k">return</span><span class="p">;</span> <span class="k">end</span>
        <span class="o">^~~~~~</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="mi">1</span><span class="k">retry</span><span class="p">;</span> <span class="k">end</span>
<span class="no">SyntaxError</span><span class="p">:</span> <span class="p">(</span><span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">unexpected</span> <span class="n">keyword_retry</span><span class="p">,</span> <span class="n">expecting</span> <span class="n">keyword_end</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="mi">1</span><span class="k">retry</span><span class="p">;</span> <span class="k">end</span>
        <span class="o">^~~~~</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span><span class="k">redo</span><span class="p">;</span> <span class="k">end</span>
<span class="no">SyntaxError</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">unexpected</span> <span class="n">keyword_redo</span><span class="p">,</span> <span class="n">expecting</span> <span class="n">keyword_end</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="mi">1</span><span class="k">redo</span><span class="p">;</span> <span class="k">end</span>
        <span class="o">^~~~</span>
</code></pre></div></div>

<p>Looks like there are special rules for keyword modifiers.</p>

<h3 id="defined"><code class="language-plaintext highlighter-rouge">defined?</code></h3>

<p>I think this is the most controversial keyword in Ruby. It takes literally everything as an argument.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"self"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"nil"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"true"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"false"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"assignment"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="n">a</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">defined?</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"local-variable"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="k">begin</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="k">end</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"expression"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">m</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span> <span class="k">defined?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">m</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"method"</span>

<span class="n">pry</span><span class="o">&gt;</span> <span class="k">module</span> <span class="nn">M</span><span class="p">;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span> <span class="k">end</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="kp">include</span> <span class="no">M</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">defined?</span><span class="p">(</span><span class="k">super</span><span class="p">);</span> <span class="k">end</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="n">m</span>
 <span class="o">=&gt;</span> <span class="s2">"super"</span>
</code></pre></div></div>

<p>It also can return <code class="language-plaintext highlighter-rouge">yield</code>, <code class="language-plaintext highlighter-rouge">constant</code>, <code class="language-plaintext highlighter-rouge">class variable</code>, <code class="language-plaintext highlighter-rouge">instance-variable</code> and <code class="language-plaintext highlighter-rouge">global-variable</code>. By the way, where’s the dash in the <code class="language-plaintext highlighter-rouge">class variable</code>?</p>

<p>That’s a strong violation of a single responsibility principle. This keyword can handle EVERYTHING!</p>

<p>Moreover, it handles all kinds of exceptions inside:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">defined?</span><span class="p">(</span>
  <span class="n">a</span><span class="p">.</span><span class="nf">b</span><span class="p">.</span><span class="nf">c</span><span class="p">.</span><span class="nf">d</span> <span class="o">+</span>
  <span class="no">MissingConstant</span> <span class="o">+</span>
  <span class="k">yield</span> <span class="o">+</span>
  <span class="k">super</span> <span class="o">+</span>
  <span class="kp">nil</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span>
  <span class="nb">eval</span><span class="p">(</span><span class="s2">"!@#$%^"</span><span class="p">)</span> <span class="o">+</span>
  <span class="nb">require</span><span class="p">(</span><span class="s1">'missing_file'</span><span class="p">)</span>
<span class="p">)</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>That’s too much for a single keyword.</p>

<h3 id="return-in-the-classmodule-body"><code class="language-plaintext highlighter-rouge">return</code> in the class/module body</h3>

<p>You can’t call <code class="language-plaintext highlighter-rouge">return</code> from a module/class body:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">A</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="k">end</span>
<span class="no">SyntaxError</span> <span class="p">(</span><span class="no">Invalid</span> <span class="k">return</span> <span class="k">in</span> <span class="k">class</span><span class="o">/</span><span class="k">module</span> <span class="nn">body</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="k">end</span>
         <span class="o">^~~~~~</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="k">module</span> <span class="nn">A</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="k">end</span>
<span class="no">SyntaxError</span> <span class="p">(</span><span class="no">Invalid</span> <span class="k">return</span> <span class="k">in</span> <span class="k">class</span><span class="o">/</span><span class="k">module</span> <span class="nn">body</span><span class="p">)</span>
<span class="k">module</span> <span class="nn">A</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="k">end</span>
          <span class="o">^~~~~~</span>
</code></pre></div></div>

<p>It throws a <code class="language-plaintext highlighter-rouge">SyntaxError</code>, i.e. even if the code is unreachable, you still can’t write it, it’s simply invalid.</p>

<p>But you can use <code class="language-plaintext highlighter-rouge">return</code> in a singleton class body:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">return</span><span class="p">;</span> <span class="k">end</span>
<span class="no">LocalJumpError</span><span class="p">:</span> <span class="n">unexpected</span> <span class="k">return</span>
</code></pre></div></div>

<p>Now that’s a <code class="language-plaintext highlighter-rouge">LocalJumpError</code>, so this code can be interpreted if nobody touches it:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">return</span><span class="p">;</span> <span class="k">end</span> <span class="k">if</span> <span class="kp">false</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<h3 id="meta-characters">Meta-characters</h3>

<p>Again, this is something that probably could be removed from Ruby, I don’t know anyone using it.</p>

<p>Metacharacter is a special sequence of characters that gets interpreted as a single character. Most probably you know one of them - <code class="language-plaintext highlighter-rouge">\uDDDD</code>. But there are more:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\u</span><span class="s2">1234"</span>
 <span class="o">=&gt;</span> <span class="s2">"ሴ"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\377</span><span class="s2">"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\xFF</span><span class="s2">"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\xFF</span><span class="s2">"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\xFF</span><span class="s2">"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\C</span><span class="s2">-</span><span class="se">\a</span><span class="s2">"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\c</span><span class="s2">a"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\u</span><span class="s2">0001"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\M</span><span class="s2">-a"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\xE1</span><span class="s2">"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\C</span><span class="s2">-</span><span class="se">\M</span><span class="s2">-f"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\x86</span><span class="s2">"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\M</span><span class="s2">-</span><span class="se">\c</span><span class="s2">f"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\x86</span><span class="s2">"</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\c\M</span><span class="s2">-f"</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\x86</span><span class="s2">"</span>
</code></pre></div></div>

<p>That’s absolutely insane! Moreover, Ruby starting from 2.6 ignores spaces (and tabs) around codepoints in the <code class="language-plaintext highlighter-rouge">\u{}</code> syntax:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="s2">"</span><span class="se">\u</span><span class="s2">{    123   456   }"</span>
 <span class="o">=&gt;</span> <span class="s2">"ģі"</span>
</code></pre></div></div>

<h3 id="invisible-rest-argument">Invisible rest argument</h3>

<p>MRI has a special rule for <code class="language-plaintext highlighter-rouge">Proc</code> class: it expands a single array argument:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="p">}.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>… but only if it the proc takes more than one argument. And if the arity is 1 it works as you’d expect:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">=&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</code></pre></div></div>

<p>And here’s an edge case: it’s possible to put a trailing comma after arguments list:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="o">|</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>… and MRI still expands an array. So how many arguments does this proc have?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="nb">proc</span><span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="o">|</span><span class="p">}.</span><span class="nf">arity</span>
<span class="o">=&gt;</span> <span class="mi">1</span>
</code></pre></div></div>

<p>What’s going on?</p>

<p>The answer is simple: there’s an invisible rest argument after trailing comma. The real interface of this proc is:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="o">*|</span> <span class="p">}</span>
</code></pre></div></div>

<p>MRI generates it for you and then hides it.</p>

<p>If you are interested in implementation details take a look at <a href="https://github.com/ruby/ruby/blob/trunk/parse.y#L3007-L3015">parse.y</a> - there’s a special field <code class="language-plaintext highlighter-rouge">excessed_comma</code> that works as a flag.</p>

<p>Also, you can clearly see in the Ripper’s output:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'ripper'</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="no">Ripper</span><span class="p">.</span><span class="nf">sexp</span><span class="p">(</span><span class="s1">'proc{|a|}'</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:params</span><span class="p">,</span> <span class="p">[[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]],</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">]</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="no">Ripper</span><span class="p">.</span><span class="nf">sexp</span><span class="p">(</span><span class="s1">'proc{|a,|}'</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:params</span><span class="p">,</span> <span class="p">[[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]],</span> <span class="kp">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">]</span>
</code></pre></div></div>

<p>Do you see the difference?</p>

<h3 id="dynamicity-of-optarg-defauls">Dynamicity of optarg defauls</h3>

<p>In Ruby optional arguments are very, very powerful. You can pass pretty much anything as a default value of the argument in the method signature:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">puts</span> <span class="s1">'no a'</span><span class="p">));</span> <span class="n">a</span><span class="p">;</span> <span class="k">end</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">1</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="n">m</span>
<span class="n">no</span> <span class="n">a</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>I don’t like it in general. I would say it’s too powerful, you can abuse this feature and do some really crazy stuff. For example like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="kp">nil</span><span class="p">))</span>
  <span class="k">return</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre></div></div>

<p>What does this method return when you call it without any arguments? Yep, it returns <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>The reason why it works this way is that MRI inlines optional arguments initialization to the method body, so in VM this code actually looks like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">||=</span> <span class="p">(</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You can even go further and redefine a method in its arguments:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span>
  <span class="n">n</span><span class="p">,</span>
  <span class="n">redefinition</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">RUBY</span><span class="p">,</span><span class="sh">
    define_method(__method__) do |
      _ = (return 1 if n == 1; nil),
      _ = eval(redefinition),
      _ = (return n * (n -= 1; send(__method__)); nil)
    |

    end
</span><span class="no">  RUBY</span>
  <span class="n">_</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">redefinition</span><span class="p">),</span>
  <span class="n">_</span> <span class="o">=</span> <span class="p">(</span><span class="k">return</span> <span class="nb">send</span><span class="p">(</span><span class="n">__method__</span><span class="p">);</span> <span class="kp">nil</span><span class="p">)</span>
<span class="p">)</span>
  <span class="c1"># &lt;&lt;EMPTY BODY&gt;&gt;</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="shadow-arguments">Shadow arguments</h3>

<p>I think only people that work with parsing/unparsing tools are aware of this feature. That’s a special kind of argument that “shadows” outer variable. The syntax is <code class="language-plaintext highlighter-rouge">|;shadowarg|</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="n">n</span> <span class="p">}.</span><span class="nf">call</span>
 <span class="o">=&gt;</span> <span class="mi">1</span>
<span class="n">pry</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="p">;</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span> <span class="p">}.</span><span class="nf">call</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>Basically, it’s nice to have an ability to use own isolated set of local variables in your block and be sure that you don’t change an outer scope. But again, does anyone use it? And also it reminds me a <code class="language-plaintext highlighter-rouge">var</code> keyword from the JavaScript.</p>

<h3 id="dynamicity-of-rescue">Dynamicity of rescue</h3>

<p>Take a look at the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
  <span class="k">raise</span> <span class="s1">'error message'</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="no">RuntimeError</span>
  <span class="nb">puts</span> <span class="s1">'caught an error'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Looks correct from the first glance, right? And it even prints <code class="language-plaintext highlighter-rouge">caught an error</code>, but in fact it has an invalid code construction. It is valid from the parser perspective, but I think you don’t want to write such code, it redefines a constant <code class="language-plaintext highlighter-rouge">RuntimeError</code>.</p>

<p>Ruby has a very tricky mechanism of converting getters to setters. It can convert</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">local variable get</code> to <code class="language-plaintext highlighter-rouge">local variable set</code> (most popular usage of <code class="language-plaintext highlighter-rouge">rescue</code> handler)</li>
  <li><code class="language-plaintext highlighter-rouge">instance variable get</code> to <code class="language-plaintext highlighter-rouge">instance variable set</code></li>
  <li><code class="language-plaintext highlighter-rouge">const get</code> to <code class="language-plaintext highlighter-rouge">const set</code></li>
  <li><code class="language-plaintext highlighter-rouge">getter method</code> to <code class="language-plaintext highlighter-rouge">setter method</code></li>
  <li>and many more like global/class variables</li>
</ul>

<p>So if you have <code class="language-plaintext highlighter-rouge">object = OpenStruct.new</code> and you catch an error using <code class="language-plaintext highlighter-rouge">rescue =&gt; object.field</code> you’ll get <code class="language-plaintext highlighter-rouge">object.field = &lt;thrown error&gt;</code> called under the hood.</p>

<p>That’s definitely very, very flexible but does anyone need it? I’d better reject all cases above except local variables.</p>

<p>I’ve seen the first snippet in the real codebase and it was quite difficult to understand why the spec that asserts something like <code class="language-plaintext highlighter-rouge">expect { code construction }.to raise_error(RuntimeError)</code> doesn’t work.</p>

<h3 id="positionalkeyword-arguments">Positional/keyword arguments</h3>

<p>I used to think that positional and keyword arguments act like two completely separate groups of arguments. If the last argument is a Hash and you pass it to the method call it</p>

<ul>
  <li>populates all kwargs</li>
  <li>raises an error if some kwargs are missing</li>
  <li>sets default values to missing optional kwargs</li>
</ul>

<p>But I was wrong. One argument value can populate positional <strong>and</strong> keyword argument:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">b: </span><span class="mi">1</span><span class="p">)</span>
  <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="n">m</span><span class="p">(</span><span class="ss">b: </span><span class="mi">2</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># =&gt; [{"b"=&gt;3}, 2]</span>
</code></pre></div></div>

<p>I feel like it’s a bug:</p>

<ol>
  <li>There’s only one argument provided</li>
  <li>And some of its keys are not symbols</li>
  <li>So MRI should not use it for kwargs initialization</li>
  <li>And <code class="language-plaintext highlighter-rouge">a</code> must be <code class="language-plaintext highlighter-rouge">{ b: 2, 'b' =&gt; 3 }</code></li>
  <li>And so <code class="language-plaintext highlighter-rouge">b</code> must be just <code class="language-plaintext highlighter-rouge">1</code> (default value)</li>
</ol>

<h3 id="final-words">Final words</h3>

<p>This story is not about bad parts of Ruby or anything like that. Don’t feel bad because of this - I’m really sorry. I was trying to cover some rarely used features and explain as much as I can.</p>]]></content><author><name></name></author><category term="ruby" /><category term="language" /><category term="tricks" /><summary type="html"><![CDATA[Disclaimer #1 first of all I’d like to say that I really like Ruby. I write a ton of Ruby code every single day and I prefer it over other languages. Please, do not take it seriously, Ruby is nice, and this post is mostly a joke.]]></summary></entry><entry><title type="html">Ruby Marshalling from A to Z</title><link href="https://iliabylich.github.io/2016/01/25/ruby-marshalling-from-a-to-z.html" rel="alternate" type="text/html" title="Ruby Marshalling from A to Z" /><published>2016-01-25T21:00:00+00:00</published><updated>2016-01-25T21:00:00+00:00</updated><id>https://iliabylich.github.io/2016/01/25/ruby-marshalling-from-a-to-z</id><content type="html" xml:base="https://iliabylich.github.io/2016/01/25/ruby-marshalling-from-a-to-z.html"><![CDATA[<p>Marshalling is a serialization process when you convert an object to a binary string.
Ruby has a standard class <code class="language-plaintext highlighter-rouge">Marshal</code> that does all the job for serialization and deserialization.
To serialize an object, use <code class="language-plaintext highlighter-rouge">Marshal.dump</code>, to deserialize - <code class="language-plaintext highlighter-rouge">Marshal.load</code> or <code class="language-plaintext highlighter-rouge">Marshal.restore</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">marshalled</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'string'</span><span class="p">,</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">])</span>
<span class="c1"># =&gt; "\x04\b[\ti\x06i\aI\"\vstring\x06:\x06ETo:\vObject\x00"</span>

<span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">marshalled</span><span class="p">)</span>
<span class="c1"># =&gt; [1, 2, "string", #&lt;Object:0x00000002643000&gt;]</span>
</code></pre></div></div>

<p>This article explains the format of marshalling and shows how to write a pure Ruby marshalling library
compatible with the standard Ruby implementation.</p>

<h1 id="the-gem">The gem</h1>

<p>Let’s try to make a pure Ruby gem that is compatible with standard <code class="language-plaintext highlighter-rouge">Marshal</code> class.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle gem pure_ruby_marshal
<span class="nv">$ </span>tree pure_ruby_marshal
pure_ruby_marshal
├── bin
│ ├── console
│ └── setup
├── CODE_OF_CONDUCT.md
├── Gemfile
├── lib
│ ├── pure_ruby_marshal
│ │ └── version.rb
│ └── pure_ruby_marshal.rb
├── LICENSE.txt
├── pure_ruby_marshal.gemspec
├── Rakefile
└── README.md
</code></pre></div></div>

<p>Our main module <code class="language-plaintext highlighter-rouge">PureRubyMarshal</code> has the following interface:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">PureRubyMarshal</span>
  <span class="kp">extend</span> <span class="nb">self</span>

  <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Also I’d like to extract all logic related into reading/writing encoded data
to separate classes - <code class="language-plaintext highlighter-rouge">ReadBuffer</code> for reading, <code class="language-plaintext highlighter-rouge">WriteBuffer</code> for writing.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">PureRubyMarshal</span>
  <span class="kp">extend</span> <span class="nb">self</span>

  <span class="nb">autoload</span> <span class="ss">:ReadBuffer</span><span class="p">,</span>  <span class="s1">'pure_ruby_marshal/read_buffer'</span>
  <span class="nb">autoload</span> <span class="ss">:WriteBuffer</span><span class="p">,</span> <span class="s1">'pure_ruby_marshal/write_buffer'</span>

  <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
    <span class="no">WriteBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">object</span><span class="p">).</span><span class="nf">write</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="nf">read</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<h1 id="reading">Reading</h1>

<p>As we decided before, <code class="language-plaintext highlighter-rouge">ReadBuffer</code> is our class responsible for reading an object from marshalled data.
Here is how it should look:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PureRubyMarshal::ReadBuffer</span>
  <span class="nb">attr_reader</span> <span class="ss">:data</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="vi">@data</span> <span class="o">=</span> <span class="n">data</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<h2 id="decompressing">Decompressing</h2>

<p>First let’s take a look at <code class="language-plaintext highlighter-rouge">Marshal.dump</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">marshalled</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'string'</span><span class="p">,</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">])</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">marshalled</span><span class="p">.</span><span class="nf">chars</span>
<span class="c1"># =&gt; [a long array of characters]</span>
</code></pre></div></div>

<p>The first two characters represent a version of library that was used for marshalling:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">ord</span>
<span class="c1"># =&gt; 4</span>
<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">ord</span>
<span class="c1"># =&gt; 8</span>
</code></pre></div></div>

<p>Which represents a current version of Marshal library - <code class="language-plaintext highlighter-rouge">4.8</code>
(<a href="https://github.com/ruby/ruby/blob/trunk/marshal.c#L54-L55">link to the source</a>).
This values are constants for any marshalled data and they are stored in <code class="language-plaintext highlighter-rouge">Marshal::MAJOR_VERSION</code> and <code class="language-plaintext highlighter-rouge">Marshal::MINOR_VERSION</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="no">Marshal</span><span class="o">::</span><span class="no">MAJOR_VERSION</span>
 <span class="o">=&gt;</span> <span class="mi">4</span>
 <span class="p">:</span><span class="mo">002</span> <span class="o">&gt;</span> <span class="no">Marshal</span><span class="o">::</span><span class="no">MINOR_VERSION</span>
 <span class="o">=&gt;</span> <span class="mi">8</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">PureRubyMarshal</code> should have same constants:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">PureRubyMarshal</span>
  <span class="no">MAJOR_VERSION</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="no">MINOR_VERSION</span> <span class="o">=</span> <span class="mi">8</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The rest of the array is actually a marshalled object.
So, for now marshalled data looks like <code class="language-plaintext highlighter-rouge">['4.8', some unknown characters]</code></p>

<p>To read the version of <code class="language-plaintext highlighter-rouge">Marshal</code> library we can modify <code class="language-plaintext highlighter-rouge">ReadBuffer#initialize</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">attr_reader</span> <span class="ss">:minor_version</span><span class="p">,</span> <span class="ss">:major_version</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="vi">@data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">chars</span>
  <span class="vi">@major_version</span> <span class="o">=</span> <span class="n">read_byte</span>
  <span class="vi">@minor_version</span> <span class="o">=</span> <span class="n">read_byte</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">read_char</span>
  <span class="n">data</span><span class="p">.</span><span class="nf">shift</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">read_byte</span>
  <span class="n">read_char</span><span class="p">.</span><span class="nf">ord</span>
<span class="k">end</span>

<span class="c1"># In irb:</span>
<span class="n">marshalled</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">read_buffer</span> <span class="o">=</span> <span class="no">PureRubyMarshal</span><span class="o">::</span><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">marshalled</span><span class="p">)</span>
<span class="n">read_buffer</span><span class="p">.</span><span class="nf">major_version</span>
 <span class="o">=&gt;</span> <span class="mi">4</span>
<span class="n">read_buffer</span><span class="p">.</span><span class="nf">minor_version</span>
 <span class="o">=&gt;</span> <span class="mi">8</span>
</code></pre></div></div>

<h2 id="getting-objects-from-the-raw-data">Getting objects from the raw data</h2>

<p>When <code class="language-plaintext highlighter-rouge">Marshal</code> converts your object to a string, it uses very simple rules:</p>
<ul>
  <li>All primitives like <code class="language-plaintext highlighter-rouge">Fixnum</code>, <code class="language-plaintext highlighter-rouge">Hash</code> or <code class="language-plaintext highlighter-rouge">Array</code> always use the same format of serialization,
prepended by a special character (each character for each unique type)</li>
  <li>If an object has instance variables, these ivars are always dumped in the same way (<code class="language-plaintext highlighter-rouge">Iobject{hash:of,instance:variables}</code>)</li>
  <li>You can’t dump multiple objects in a single operation,
so there’s always a root object in marshalled string (which is actually placed in the beginning of the string)</li>
  <li>This object is followed by all other data, like ivars, string encodings etc.</li>
</ul>

<h2 id="nilclass-trueclass-falseclass">NilClass, TrueClass, FalseClass</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="kp">nil</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"0"</span><span class="p">]</span>
</code></pre></div></div>

<p>Character <code class="language-plaintext highlighter-rouge">0</code> means that encoded object is <code class="language-plaintext highlighter-rouge">nil</code>. To handle it, we can write something like:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PureRubyMarshal::ReadBuffer</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">read</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">read_char</span>
    <span class="k">case</span> <span class="n">char</span>
    <span class="k">when</span> <span class="s1">'0'</span> <span class="k">then</span> <span class="kp">nil</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"Unknown object type </span><span class="si">#{</span><span class="n">char</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

 <span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="kp">nil</span><span class="p">)).</span><span class="nf">read</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="kp">true</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"T"</span><span class="p">]</span>
 <span class="p">:</span><span class="mo">002</span> <span class="o">&gt;</span> <span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="kp">false</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"F"</span><span class="p">]</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">true</code> converts to <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">false</code> converts to <code class="language-plaintext highlighter-rouge">F</code>, nothing complex for now.</p>

<p>Let’s extend our <code class="language-plaintext highlighter-rouge">case</code> statement:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">when</span> <span class="s1">'T'</span> <span class="k">then</span> <span class="kp">true</span>
<span class="k">when</span> <span class="s1">'F'</span> <span class="k">then</span> <span class="kp">false</span>
</code></pre></div></div>

<h2 id="tests">Tests</h2>

<p>Of course, we can’t develop without tests,</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># fixtures.rb</span>

<span class="no">FIXTURES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'nil'</span> <span class="o">=&gt;</span> <span class="kp">nil</span><span class="p">,</span>
  <span class="s1">'true'</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
  <span class="s1">'false'</span> <span class="o">=&gt;</span> <span class="kp">false</span>
<span class="p">}</span>

<span class="c1"># pure_ruby_marshal_spec.rb</span>

<span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">PureRubyMarshal</span> <span class="k">do</span>
  <span class="n">describe</span> <span class="s1">'.load'</span> <span class="k">do</span>
    <span class="no">FIXTURES</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">fixture_name</span><span class="p">,</span> <span class="n">fixture_value</span><span class="o">|</span>
      <span class="n">it</span> <span class="s2">"loads marshalled </span><span class="si">#{</span><span class="n">fixture_name</span><span class="si">}</span><span class="s2">"</span> <span class="k">do</span>
        <span class="n">result</span> <span class="o">=</span> <span class="no">PureRubyMarshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">fixture_value</span><span class="p">))</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="n">fixture_value</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># rspec --format documentation</span>

<span class="no">PureRubyMarshal</span>
  <span class="p">.</span><span class="nf">load</span>
    <span class="n">loads</span> <span class="n">marshalled</span> <span class="kp">nil</span>
    <span class="n">loads</span> <span class="n">marshalled</span> <span class="kp">true</span>
    <span class="n">loads</span> <span class="n">marshalled</span> <span class="kp">false</span>

<span class="mi">3</span> <span class="n">examples</span><span class="p">,</span> <span class="mi">0</span> <span class="n">failures</span>
</code></pre></div></div>

<h2 id="integer">Integer</h2>

<p>All encoded integers are prepended with an <code class="language-plaintext highlighter-rouge">"i"</code> symbol. Added one more <code class="language-plaintext highlighter-rouge">when</code> to our <code class="language-plaintext highlighter-rouge">case</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">when</span> <span class="s1">'i'</span> <span class="k">then</span> <span class="n">read_integer</span>
</code></pre></div></div>

<p>The next byte defines a strategy of decoding the rest of the data. Then comes a bytes sequence representing a number.</p>

<p>Let’s say that <code class="language-plaintext highlighter-rouge">byte = (first_char_code_after_i ^ 128) - 128</code> (it ranges from <code class="language-plaintext highlighter-rouge">-128 .. 128</code>).</p>

<p>There are 5 different cases depending on the byte value:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">byte is 0</code></li>
  <li><code class="language-plaintext highlighter-rouge">byte in [4..128]</code></li>
  <li><code class="language-plaintext highlighter-rouge">byte in [1..4]</code></li>
  <li><code class="language-plaintext highlighter-rouge">byte in [-128..-4]</code></li>
  <li><code class="language-plaintext highlighter-rouge">byte in [-5..-1]</code></li>
</ul>

<p>Let’s write a utility lambda to simplify examples:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_sequence</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
  <span class="n">buffer</span> <span class="o">=</span> <span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="n">buffer</span><span class="p">.</span><span class="nf">read_char</span>
  <span class="n">buffer</span><span class="p">.</span><span class="nf">data</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:ord</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It:</p>
<ul>
  <li>marshalls passed number with native <code class="language-plaintext highlighter-rouge">Marshal</code></li>
  <li>loads it through our pure ruby <code class="language-plaintext highlighter-rouge">ReadBuffer</code></li>
  <li>reads one char (<code class="language-plaintext highlighter-rouge">"i"</code>)</li>
  <li>takes the rest of the data</li>
  <li>and converts characters to their codes</li>
</ul>

<p><strong>The first case</strong> is the simplest one:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>
<p>Zero is actually encoded as zero.</p>

<p><strong>The second case</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_sequence</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="p">]</span>
<span class="n">get_sequence</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="n">get_sequence</span><span class="p">[</span><span class="mi">120</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">125</span><span class="p">]</span>
</code></pre></div></div>
<p>In this case <code class="language-plaintext highlighter-rouge">result = byte - 5</code> and it covers small positive numbers.</p>

<p><strong>The third case</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_sequence</span><span class="p">[</span><span class="mi">99999</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span> <span class="mi">134</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>3 means three numbers representing a single number, they should be merged with binary <code class="language-plaintext highlighter-rouge">OR</code> and byte shifting:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">159</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="mi">0</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">134</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
 <span class="o">=&gt;</span> <span class="mi">99999</span>
</code></pre></div></div>

<p><strong>The fourth and the fifth examples</strong> are just like 2nd and 3rd, but for negative numbers.</p>

<p>Let’s implement our <code class="language-plaintext highlighter-rouge">read_integer</code> method!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_integer</span>
    <span class="c1"># c is our first byte</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_byte</span> <span class="o">^</span> <span class="mi">128</span><span class="p">)</span> <span class="o">-</span> <span class="mi">128</span>

    <span class="k">case</span> <span class="n">c</span>
    <span class="k">when</span> <span class="mi">0</span>
      <span class="c1"># 0 means 0</span>
      <span class="mi">0</span>
    <span class="k">when</span> <span class="p">(</span><span class="mi">4</span><span class="o">..</span><span class="mi">127</span><span class="p">)</span>
      <span class="c1"># case for small positive numbers</span>
      <span class="n">c</span> <span class="o">-</span> <span class="mi">5</span>
    <span class="k">when</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span>
      <span class="c1"># c next bytes is our big positive number</span>
      <span class="n">c</span><span class="p">.</span>
        <span class="nf">times</span><span class="p">.</span>
        <span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">read_byte</span><span class="p">]</span> <span class="p">}.</span>
        <span class="nf">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">byte</span><span class="p">)</span><span class="o">|</span> <span class="n">result</span> <span class="o">|</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>  <span class="p">}</span>
    <span class="k">when</span> <span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="o">..-</span><span class="mi">6</span><span class="p">)</span>
      <span class="c1"># case for small negative numbers</span>
      <span class="n">c</span> <span class="o">+</span> <span class="mi">5</span>
    <span class="k">when</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="o">..-</span><span class="mi">1</span><span class="p">)</span>
      <span class="c1"># (-c) next bytes is our number</span>
      <span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="p">).</span>
        <span class="nf">times</span><span class="p">.</span>
        <span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">read_byte</span><span class="p">]</span> <span class="p">}.</span>
        <span class="nf">inject</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">byte</span><span class="p">)</span><span class="o">|</span>
          <span class="n">a</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
          <span class="n">b</span> <span class="o">=</span> <span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
          <span class="p">(</span><span class="n">result</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span>
        <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>To add tests for integers, we can just add more key-value pairs to our
<code class="language-plaintext highlighter-rouge">FIXTURES</code> constant.</p>

<p>Complex data types like</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Array</code></li>
  <li><code class="language-plaintext highlighter-rouge">String</code></li>
  <li><code class="language-plaintext highlighter-rouge">Hash</code></li>
  <li><code class="language-plaintext highlighter-rouge">Regexp</code></li>
</ul>

<p>and others include numbers into their encoded structure to represent their length.</p>

<h2 id="symbol">Symbol</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="ss">:a_symbol</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\r</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">,</span> <span class="s2">"s"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"m"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"o"</span><span class="p">,</span> <span class="s2">"l"</span><span class="p">]</span>
</code></pre></div></div>

<p>Symbols are encoded using:</p>
<ul>
  <li>a special <code class="language-plaintext highlighter-rouge">":"</code> character</li>
  <li>Symbol length (<code class="language-plaintext highlighter-rouge">"\r".ord - 5 = 8</code>) as Integer (we can fetch it using <code class="language-plaintext highlighter-rouge">read_integer</code> method)</li>
  <li>The Symbol itself, character by character</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># one more "when" statement</span>
<span class="k">when</span> <span class="s1">':'</span> <span class="k">then</span> <span class="n">read_symbol</span>

<span class="c1"># and implementation</span>
<span class="k">def</span> <span class="nf">read_symbol</span>
  <span class="n">read_integer</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">read_char</span> <span class="p">}.</span><span class="nf">join</span><span class="p">.</span><span class="nf">to_sym</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="string">String</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="s2">"a string"</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"</span><span class="se">\"</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\r</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">" "</span><span class="p">,</span> <span class="s2">"s"</span><span class="p">,</span> <span class="s2">"t"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"n"</span><span class="p">,</span> <span class="s2">"g"</span><span class="p">]</span>
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"\""</code> is actually a <code class="language-plaintext highlighter-rouge">"</code> symbol which shows the beginning of the encoded string</li>
  <li>the next encoded number <code class="language-plaintext highlighter-rouge">n = 8</code> is a length of the string</li>
  <li><code class="language-plaintext highlighter-rouge">n</code> following symbols are the string itself.</li>
</ul>

<p>To support loading marshalled string, we can use the following code:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'"'</span> <span class="k">then</span> <span class="n">read_string</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_string</span>
  <span class="n">read_integer</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">read_char</span> <span class="p">}.</span><span class="nf">join</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="array">Array</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"["</span><span class="p">,</span> <span class="s2">"</span><span class="se">\b</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x06</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\b</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"["</code> means that converted object is an <code class="language-plaintext highlighter-rouge">Array</code></li>
  <li>the next encoded number <code class="language-plaintext highlighter-rouge">n = 3</code> is a length of our array</li>
  <li><code class="language-plaintext highlighter-rouge">"i", "1"</code> is an <code class="language-plaintext highlighter-rouge">Integer 1</code></li>
  <li><code class="language-plaintext highlighter-rouge">"i", "2"</code> is an <code class="language-plaintext highlighter-rouge">Integer 2</code></li>
  <li><code class="language-plaintext highlighter-rouge">"i", "3"</code> is an <code class="language-plaintext highlighter-rouge">Integer 3</code></li>
</ul>

<p>Array items are encoded as separate objects, every item is prepended by its own service character:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'['</span> <span class="k">then</span> <span class="n">read_array</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_array</span>
  <span class="n">read_integer</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">read</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="hash">Hash</h2>

<p><code class="language-plaintext highlighter-rouge">Hash</code> is encoded as an array of key-value pairs:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">({</span> <span class="mi">15</span> <span class="o">=&gt;</span> <span class="mi">5</span> <span class="p">})).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x06</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x14</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"{"</code> is the beginning of hash</li>
  <li><code class="language-plaintext highlighter-rouge">1</code> is a number of <code class="language-plaintext highlighter-rouge">key =&gt; value</code> pairs</li>
  <li><code class="language-plaintext highlighter-rouge">"i" 15</code> is an <code class="language-plaintext highlighter-rouge">Integer 15</code></li>
  <li><code class="language-plaintext highlighter-rouge">"i" 5</code> is an <code class="language-plaintext highlighter-rouge">Integer 5</code></li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'{'</span> <span class="k">then</span> <span class="n">read_hash</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_hash</span>
  <span class="n">pairs</span> <span class="o">=</span> <span class="n">read_integer</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="p">[</span><span class="n">read</span><span class="p">,</span> <span class="n">read</span><span class="p">]</span> <span class="p">}</span>
  <span class="no">Hash</span><span class="p">[</span><span class="n">pairs</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="float">Float</h2>

<p><code class="language-plaintext highlighter-rouge">Float</code> is encoded as its string representation</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"f"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\b</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">"."</span><span class="p">,</span> <span class="s2">"5"</span><span class="p">]</span>
</code></pre></div></div>

<p>Floats are encoded using <code class="language-plaintext highlighter-rouge">#to_s</code> method:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"f"</code> is the beginning of <code class="language-plaintext highlighter-rouge">Float</code></li>
  <li><code class="language-plaintext highlighter-rouge">3</code> is the length</li>
  <li><code class="language-plaintext highlighter-rouge">"1", ".", "5"</code> is its string representation</li>
</ul>

<p>To get it back, we can use <code class="language-plaintext highlighter-rouge">String#to_f</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'f'</span> <span class="k">then</span> <span class="n">read_float</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_float</span>
  <span class="n">read_string</span><span class="p">.</span><span class="nf">to_f</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="class">Class</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">Array</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"c"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">]</span>
</code></pre></div></div>

<p>Classes are represented by their names:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"c"</code> means a <code class="language-plaintext highlighter-rouge">Class</code></li>
  <li><code class="language-plaintext highlighter-rouge">5</code> is the length of its name</li>
  <li>next 5 characters are the name itself</li>
</ul>

<p>After reading the name we can do <code class="language-plaintext highlighter-rouge">Object.const_get(const_name)</code> to retrieve the actual class.
The only remark here is that when the class doesn’t exist anymore,
<code class="language-plaintext highlighter-rouge">Marshal</code> re-raises <code class="language-plaintext highlighter-rouge">ArgumentError, "undefined class/module #{const_name}"</code> instead of a <code class="language-plaintext highlighter-rouge">NameError</code>.
Moreover, if the constant returned by <code class="language-plaintext highlighter-rouge">Object.const_get</code> is not a class,
<code class="language-plaintext highlighter-rouge">Marshal</code> raises <code class="language-plaintext highlighter-rouge">ArgumentError, "#{const_name} does not refer to a Class"</code>.
So, the constant <strong>must</strong> exist and it <strong>must</strong> be a <code class="language-plaintext highlighter-rouge">Class</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'c'</span> <span class="k">then</span> <span class="n">read_class</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">marshal_const_get</span><span class="p">(</span><span class="n">const_name</span><span class="p">)</span>
  <span class="no">Object</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">const_name</span><span class="p">)</span>
<span class="k">rescue</span> <span class="no">NameError</span>
  <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"undefined class/module </span><span class="si">#{</span><span class="n">const_name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">read_class</span>
  <span class="n">const_name</span> <span class="o">=</span> <span class="n">read_string</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">marshal_const_get</span><span class="p">(</span><span class="n">const_name</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">klass</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">const_name</span><span class="si">}</span><span class="s2"> does not refer to a Class"</span>
  <span class="k">end</span>
  <span class="n">klass</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I’ve extracted <code class="language-plaintext highlighter-rouge">marshal_const_get</code> to a separate method to use it later for
reading a <code class="language-plaintext highlighter-rouge">Module</code> from the marshalled data.</p>

<h2 id="module">Module</h2>

<p>Modules are similar to Classes, but the “magical” character is <code class="language-plaintext highlighter-rouge">"m"</code> instead of <code class="language-plaintext highlighter-rouge">"c"</code>
(and, of course, messages of exceptions are about modules).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'m'</span> <span class="k">then</span> <span class="n">read_module</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_module</span>
  <span class="n">const_name</span> <span class="o">=</span> <span class="n">read_string</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">marshal_const_get</span><span class="p">(</span><span class="n">const_name</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">klass</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="no">Module</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">const_name</span><span class="si">}</span><span class="s2"> does not refer to a Module"</span>
  <span class="k">end</span>
  <span class="n">klass</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="struct">Struct</h2>

<p>Struct are encoded by their class names + their data:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Point</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"S"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"P"</span><span class="p">,</span> <span class="s2">"o"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"n"</span><span class="p">,</span> <span class="s2">"t"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x06</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"x"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\b</span><span class="s2">"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x06</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\f</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<p>This output can be split to:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"S"</code> means a beginning of encoded <code class="language-plaintext highlighter-rouge">Struct</code></li>
  <li><code class="language-plaintext highlighter-rouge">":", 5, "P", "o", "i", "n", "t"</code> is a Symbol <code class="language-plaintext highlighter-rouge">:Point</code></li>
  <li><code class="language-plaintext highlighter-rouge">2, ":", 1, "x", "i", 2, ":", 1, "y", "i", 3</code> is a visually unmarked Hash (i.e. no <code class="language-plaintext highlighter-rouge">{</code> symbol) with 2 pairs:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">":", 1, "x"</code> is a Symbol <code class="language-plaintext highlighter-rouge">:x</code></li>
      <li><code class="language-plaintext highlighter-rouge">"i", 2</code> is an Integer <code class="language-plaintext highlighter-rouge">2</code></li>
      <li><code class="language-plaintext highlighter-rouge">":", 1, "y"</code> is a Symbol <code class="language-plaintext highlighter-rouge">:y</code></li>
      <li><code class="language-plaintext highlighter-rouge">"i", 3</code> is an Integer <code class="language-plaintext highlighter-rouge">3</code></li>
    </ul>
  </li>
</ul>

<p>So, we have a Struct defined with its class name and the Hash containing object’s data</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'S'</span> <span class="k">then</span> <span class="n">read_struct</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_struct</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">marshal_const_get</span><span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="c1"># Point</span>
  <span class="n">attributes</span> <span class="o">=</span> <span class="n">read_hash</span> <span class="c1"># { x: 3, y: 7 }</span>
  <span class="n">values</span> <span class="o">=</span> <span class="n">attributes</span><span class="p">.</span><span class="nf">values_at</span><span class="p">(</span><span class="o">*</span><span class="n">klass</span><span class="p">.</span><span class="nf">members</span><span class="p">)</span> <span class="c1"># [3, 7]</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Why is class name encoded as a <code class="language-plaintext highlighter-rouge">Symbol</code>, not a <code class="language-plaintext highlighter-rouge">String</code>? See section ‘Symbol link’</p>

<h2 id="regexp">Regexp</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="sr">/a_regexp/</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"/"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\r</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="s2">"e"</span><span class="p">,</span> <span class="s2">"g"</span><span class="p">,</span> <span class="s2">"e"</span><span class="p">,</span> <span class="s2">"x"</span><span class="p">,</span> <span class="s2">"p"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<p>Alright, there are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"/"</code> - a beginning of a regexp</li>
  <li><code class="language-plaintext highlighter-rouge">8</code> - length of its string representation</li>
  <li><code class="language-plaintext highlighter-rouge">"a_regexp"</code> - string representation</li>
  <li>0 - a <a href="http://ruby-doc.org/core-2.1.1/Regexp.html#method-c-new">kcode</a> that was passed to a constructor</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'/'</span> <span class="k">then</span> <span class="n">read_regexp</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_regexp</span>
  <span class="n">string</span> <span class="o">=</span> <span class="n">read_string</span>
  <span class="n">kcode</span> <span class="o">=</span> <span class="n">read_byte</span>
  <span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">kcode</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="abstract-object">Abstract object</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Point2</span>
  <span class="nb">attr_reader</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Point2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="n">other</span><span class="p">.</span><span class="nf">x</span> <span class="o">==</span> <span class="nb">self</span><span class="p">.</span><span class="nf">x</span> <span class="o">&amp;&amp;</span>
      <span class="n">other</span><span class="p">.</span><span class="nf">y</span> <span class="o">==</span> <span class="nb">self</span><span class="p">.</span><span class="nf">y</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">point</span> <span class="o">=</span> <span class="no">Point2</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">point</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"o"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\v</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"P"</span><span class="p">,</span> <span class="s2">"o"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"n"</span><span class="p">,</span> <span class="s2">"t"</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"@"</span><span class="p">,</span> <span class="s2">"x"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"@"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x0F</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"o"</code> means the beginning of any non-standard object</li>
  <li><code class="language-plaintext highlighter-rouge">":", 6, "P", "o", "i", "n", "t", "2"</code> is a Symbol <code class="language-plaintext highlighter-rouge">:Point2</code></li>
  <li><code class="language-plaintext highlighter-rouge">2, ":", 2, "@", "x", "i", 5, ":", 2, "@", "y", "i", 10</code> is a Hash with 2 key-value pairs:
    <ul>
      <li>key <code class="language-plaintext highlighter-rouge">":", 2, "@", "x"</code> is a Symbol <code class="language-plaintext highlighter-rouge">@x</code></li>
      <li>value <code class="language-plaintext highlighter-rouge">"i", 5</code> is an Integer <code class="language-plaintext highlighter-rouge">4</code></li>
      <li>key <code class="language-plaintext highlighter-rouge">":", 2, "@", "y"</code> is a Symbol <code class="language-plaintext highlighter-rouge">@y</code></li>
      <li>value <code class="language-plaintext highlighter-rouge">"i", 10</code> is an Integer <code class="language-plaintext highlighter-rouge">5</code></li>
    </ul>
  </li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'o'</span> <span class="k">then</span> <span class="n">read_object</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_object</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">marshal_const_get</span><span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="c1"># Point2</span>
  <span class="n">ivars_data</span> <span class="o">=</span> <span class="n">read_hash</span> <span class="c1"># { :@x =&gt; 5, :@y = 10 }</span>
  <span class="n">object</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">allocate</span> <span class="c1"># #&lt;Point &gt;</span>
  <span class="n">ivars_data</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">ivar_name</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
    <span class="n">object</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">object</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="user-class">User class</h2>

<p>User classes are classes inherited from default classes:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyArray</span> <span class="o">&lt;</span> <span class="no">Array</span>
<span class="k">end</span>
<span class="n">my_array</span> <span class="o">=</span> <span class="no">MyArray</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">my_array</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"C"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\f</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"M"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"["</span><span class="p">,</span> <span class="s2">"</span><span class="se">\b</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x06</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"i"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\b</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<p>Objects of these classes are encoded in the following way:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"C"</code> - a beginning of a user class</li>
  <li><code class="language-plaintext highlighter-rouge">":", 7, "M", "y", "A", "r", "r", "a", "y"</code> - a symbol <code class="language-plaintext highlighter-rouge">:MyArray</code> - the name of the user class</li>
  <li>the rest of the data that should be passed to constructor (array <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> for this example)</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'C'</span> <span class="k">then</span> <span class="n">read_userclass</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_userclass</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">marshal_const_get</span><span class="p">(</span><span class="n">read</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">read</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="extended-object">Extended object</h2>

<p>Sometimes your object is very, very complex. Like an object extended with some modules:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MyModule</span> <span class="o">=</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">MyModule</span><span class="p">)</span>
</code></pre></div></div>

<p>In this case <code class="language-plaintext highlighter-rouge">Marshal</code> prepends you object structure with the list of extended modules:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"e"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\r</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"M"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"M"</span><span class="p">,</span> <span class="s2">"o"</span><span class="p">,</span> <span class="s2">"d"</span><span class="p">,</span> <span class="s2">"u"</span><span class="p">,</span> <span class="s2">"l"</span><span class="p">,</span> <span class="s2">"e"</span><span class="p">,</span> <span class="s2">"["</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"e"</code> means that marshalled data has the following scheme:
    <ul>
      <li>a <code class="language-plaintext highlighter-rouge">Symbol</code> that represents a name of a Ruby module (<code class="language-plaintext highlighter-rouge">:MyModule</code>)</li>
      <li>an abstract dumped object that was extended with this module and should be retrieved</li>
    </ul>
  </li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...</span>
<span class="k">when</span> <span class="s1">'e'</span> <span class="k">then</span> <span class="n">read_extended_object</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">read_extended_object</span>
  <span class="n">mod</span> <span class="o">=</span> <span class="n">marshal_const_get</span><span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="c1"># MyModule</span>
  <span class="n">object</span> <span class="o">=</span> <span class="n">read</span> <span class="c1"># []</span>
  <span class="n">object</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="symbol-links">Symbol links</h2>

<p>I guess this idea was originally created for compressing marshalled output.
Consider the following situation: you have a collection of objects of the same class
(the simplest example is a result of calling <code class="language-plaintext highlighter-rouge">YourActiveRecordModel.all</code>).
When you pass this collection to <code class="language-plaintext highlighter-rouge">Marshal.dump</code>, it converts objects one by one, writing them to an output stream.
But an abstract object is represented by its class name and a hash of instance variables.
Symbol links save you from writing the same <code class="language-plaintext highlighter-rouge">class.name</code> again and again to the output.
Instead, it remembers all symbols that have been written, and when the symbol appears twice in the sequence,
it writes its sequence number.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a1</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:symbol1</span><span class="p">,</span> <span class="ss">:symbol2</span><span class="p">]</span>
<span class="n">a2</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:symbol1</span><span class="p">,</span> <span class="ss">:symbol1</span><span class="p">]</span>

<span class="n">dumped1</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\x04\b</span><span class="s2">[</span><span class="se">\a</span><span class="s2">:</span><span class="se">\f</span><span class="s2">symbol1:</span><span class="se">\f</span><span class="s2">symbol2"</span>
<span class="n">dumped1</span><span class="p">.</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">22</span>

<span class="n">dumped2</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">"</span><span class="se">\x04\b</span><span class="s2">[</span><span class="se">\a</span><span class="s2">:</span><span class="se">\f</span><span class="s2">symbol1;</span><span class="se">\x00</span><span class="s2">"</span>
<span class="n">dumped2</span><span class="p">.</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">15</span>
</code></pre></div></div>

<p>For this example it saves us 31% of the initial size. Let’s see how it works:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ReadBuffer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a2</span><span class="p">)).</span><span class="nf">data</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"["</span><span class="p">,</span> <span class="s2">"</span><span class="se">\a</span><span class="s2">"</span><span class="p">,</span> <span class="s2">":"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\f</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"s"</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">,</span> <span class="s2">"m"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"o"</span><span class="p">,</span> <span class="s2">"l"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">";"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span><span class="p">]</span>
</code></pre></div></div>

<p>So we have an array of two items:</p>
<ul>
  <li>a <code class="language-plaintext highlighter-rouge">Symbol</code> <code class="language-plaintext highlighter-rouge">:symbol1</code></li>
  <li>a special character <code class="language-plaintext highlighter-rouge">";"</code> representing beginning of symbol link and an encoded <code class="language-plaintext highlighter-rouge">Integer</code> that represents a symbol with this index</li>
</ul>

<p>The algorithm for parsing <code class="language-plaintext highlighter-rouge">Symbol</code> should be changed a little bit
to save all symbols to an internal array.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span>
  <span class="c1"># ...</span>
  <span class="vi">@symbols_cache</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="c1"># ...</span>

<span class="k">def</span> <span class="nf">read_symbol</span>
  <span class="n">symbol</span> <span class="o">=</span> <span class="n">read_integer</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">read_char</span> <span class="p">}.</span><span class="nf">join</span><span class="p">.</span><span class="nf">to_sym</span> <span class="c1"># no changes here</span>
  <span class="vi">@symbols_cache</span> <span class="o">&lt;&lt;</span> <span class="n">symbol</span> <span class="c1"># save a symbol</span>
  <span class="n">symbol</span>
<span class="k">end</span>

<span class="c1"># ...</span>

<span class="k">when</span> <span class="s1">';'</span> <span class="k">then</span> <span class="n">read_symbol_link</span>

<span class="c1"># ...</span>

<span class="k">def</span> <span class="nf">read_symbol_link</span>
  <span class="vi">@symbols_cache</span><span class="p">[</span><span class="n">read_integer</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I’ll return to symbol links and my thoughts about how it can be used to compress marshalled output
in “Optimizations” section.</p>

<h2 id="object-links">Object links</h2>

<p>Same story here, when you have an object that appears multiple times in your data, <code class="language-plaintext highlighter-rouge">Marshal</code> will serialize it only once:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obj1</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a1</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">]</span>
<span class="n">a2</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj1</span><span class="p">]</span>

<span class="n">dumped1</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="n">dumped1</span><span class="p">.</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">18</span>

<span class="n">dumped2</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">dumped2</span><span class="p">.</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">16</span>
</code></pre></div></div>

<p>A symbol that indicates a beginning of an object link is <code class="language-plaintext highlighter-rouge">"@"</code>. However the criteria for
dumping an object link instead of an object itself is objects equality (<code class="language-plaintext highlighter-rouge">equal?</code>).
Here’s the problem: if you dump an array <code class="language-plaintext highlighter-rouge">[{}, {}]</code>, <code class="language-plaintext highlighter-rouge">Marshal</code> will dump
both objects without any object links, because these objects are not equal.</p>

<p>Also <code class="language-plaintext highlighter-rouge">Marshal</code> doesn’t cache:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code>/<code class="language-plaintext highlighter-rouge">nil</code></li>
  <li><code class="language-plaintext highlighter-rouge">Integer</code></li>
  <li><code class="language-plaintext highlighter-rouge">String</code> when it’s a part of float/regexp</li>
  <li><code class="language-plaintext highlighter-rouge">Hash</code> when it’s a hash of instance variables/struct members</li>
</ul>

<p>Which is mostly correct.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code>/<code class="language-plaintext highlighter-rouge">nil</code>/integers/floats always point to the same object in the memory</li>
  <li>If we dump <code class="language-plaintext highlighter-rouge">[s, Regexp.new(s)]</code> it will not create an object link. Why? <code class="language-plaintext highlighter-rouge">Regexp.new</code> always creates a copy of the string inside, so there’s no way to save any memory using object links, <code class="language-plaintext highlighter-rouge">regexp.source</code> is always a unique object in the memory.</li>
  <li>If we dump two objects with the same hash of instance variables there are two cases:
    <ul>
      <li>If these objects have the same class, then it’s almost 100% gurantee
that these objects are the same. Then the output stream looks like <code class="language-plaintext highlighter-rouge">[Object, ObjectLink]</code>.</li>
      <li>If these objects have a different class but the same hash of ivars -
then we shouldn’t create an object link and that’s correct.</li>
    </ul>
  </li>
</ul>

<p>The code for object links is quite big to paste it here, you can find it
<a href="https://github.com/iliabylich/pure_ruby_marshal/commit/a26aa1aecec20cee1c2a908673fe79275dcdfa58">here</a></p>

<h2 id="other-cases">Other cases</h2>

<p>To be honest, there are a few more cases, but they are too complex
for implementing and pasting it here. I’m not going to cover here:</p>
<ul>
  <li>Encoding</li>
  <li>User marshalled objects (i.e. with <code class="language-plaintext highlighter-rouge">marshal_dump/load</code>)</li>
  <li>Bignum</li>
  <li>Edge cases of <code class="language-plaintext highlighter-rouge">Float</code> like infinity</li>
  <li>Some stuff that I just don’t know from marshalling like UserDef/Hashdef/ModuleOld</li>
</ul>

<h1 id="writing">Writing</h1>

<p>If you’ve read the previous part, I suppose it should be clear for you how to write it youself :)</p>

<h1 id="optimizations">Optimizations</h1>

<p>Let’s try on the real-world examples. Stuff that usually gets serialized is your data.
And I can remember only one example where <code class="language-plaintext highlighter-rouge">Marshal</code> is used - model caching.</p>

<p>Imagine I have a model <code class="language-plaintext highlighter-rouge">User</code> with the following columns:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code></li>
  <li><code class="language-plaintext highlighter-rouge">email</code></li>
  <li><code class="language-plaintext highlighter-rouge">created_at</code>/<code class="language-plaintext highlighter-rouge">updated_at</code></li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">891</span>
</code></pre></div></div>

<p>That’s a lot… The easiest solution is to dump only <code class="language-plaintext highlighter-rouge">attributes</code> hash:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">marshal_dump</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
    <span class="n">attributes</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">marshal_load</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">initialize</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="vi">@new_record</span> <span class="o">=</span> <span class="nb">id</span><span class="p">.</span><span class="nf">blank?</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="c1">#&lt;User id: 131 ...&gt;</span>
<span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">205</span>
</code></pre></div></div>

<p>That’s better, let’s see what else we can improve.</p>

<p>By default <code class="language-plaintext highlighter-rouge">ActiveRecord::Base#attributes</code> returns a hash where keys are <code class="language-plaintext highlighter-rouge">String</code>. That sounds like
it can be optimized by calling <code class="language-plaintext highlighter-rouge">attributes.symbolize_keys</code> in <code class="language-plaintext highlighter-rouge">marshal_dump</code> to use symbol links
when we dump a collection. <strong>But that’s not true!</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:attributes</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:keys</span><span class="p">).</span><span class="nf">flatten</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:object_id</span><span class="p">).</span><span class="nf">uniq</span><span class="p">.</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">4</span> <span class="p">(</span><span class="k">for</span> <span class="mi">4</span> <span class="n">columns</span><span class="p">)</span>
</code></pre></div></div>

<p>This is an amazing example of optimization!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span><span class="o">::</span><span class="no">AttrNames</span><span class="p">.</span><span class="nf">constants</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:ATTR_9646</span><span class="p">,</span> <span class="ss">:ATTR_56d61696c6</span><span class="p">,</span> <span class="ss">:ATTR_36275616475646f51647</span><span class="p">,</span> <span class="ss">:ATTR_57074616475646f51647</span><span class="p">]</span>

<span class="no">User</span><span class="o">::</span><span class="no">AttrNames</span><span class="p">.</span><span class="nf">constants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">const_name</span><span class="o">|</span>
  <span class="no">User</span><span class="o">::</span><span class="no">AttrNames</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">const_name</span><span class="p">)</span>
<span class="k">end</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"id"</span><span class="p">,</span> <span class="s2">"email"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="p">,</span> <span class="s2">"updated_at"</span><span class="p">]</span>
</code></pre></div></div>

<p>Keys in the <code class="language-plaintext highlighter-rouge">attributes</code> hash are from these constants, so they are always the same
objects, so <code class="language-plaintext highlighter-rouge">Marshal</code> cashes them using object links.</p>

<p>By the way, why does ActiveRecord save attribute names as <code class="language-plaintext highlighter-rouge">String</code>? The answer is simple,
<code class="language-plaintext highlighter-rouge">Symbol</code> doesn’t support encodings.</p>

<p>Well, currently our record is represented by:</p>
<ul>
  <li>class name as a symbol (so it’s cacheable)</li>
  <li>hash of attributes:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">String</code> “id” / object link</li>
      <li><code class="language-plaintext highlighter-rouge">Integer</code> id - can’t do anything here</li>
      <li><code class="language-plaintext highlighter-rouge">String</code> “email” / object link</li>
      <li><code class="language-plaintext highlighter-rouge">String</code> email - nothing to optimize</li>
      <li><code class="language-plaintext highlighter-rouge">String</code> “created_at” / object link</li>
      <li><code class="language-plaintext highlighter-rouge">ActiveSupport::TimeWithZone</code> created_at - probably optimizable</li>
      <li><code class="language-plaintext highlighter-rouge">String</code> “updated_at” / object link</li>
      <li><code class="language-plaintext highlighter-rouge">ActiveSupport::TimeWithZone</code> udpated_at - see #6</li>
    </ol>
  </li>
</ul>

<p>Let’s see what happens when we serialize <code class="language-plaintext highlighter-rouge">AS::TimeWithZone</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">zone</span><span class="p">.</span><span class="nf">now</span><span class="p">).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">120</span>
</code></pre></div></div>

<p>So, from 205 characters of our record 120 is taken for a time with zone. <code class="language-plaintext highlighter-rouge">AS::TimeWithZone</code> has
its custom implementation of <code class="language-plaintext highlighter-rouge">marshal_load</code> that converts it to <code class="language-plaintext highlighter-rouge">[utc, zone, time]</code>.
If you always use your application time zone,
then you can store it as epoch time:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ActiveSupport::TimeWithZone</span>
  <span class="k">def</span> <span class="nf">marshal_dump</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
    <span class="n">to_i</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">marshal_load</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
    <span class="n">utc</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
    <span class="n">zone</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">time_zone</span>
    <span class="n">local</span> <span class="o">=</span> <span class="n">utc</span><span class="p">.</span><span class="nf">in_time_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
    <span class="n">initialize</span><span class="p">(</span><span class="n">utc</span><span class="p">.</span><span class="nf">utc</span><span class="p">,</span> <span class="o">::</span><span class="no">Time</span><span class="p">.</span><span class="nf">find_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">local</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">139</span>
<span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">261</span>
</code></pre></div></div>

<p>Personally I’m not sure that the next optimization is a good idea, but you can try:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">marshallable_attributes</span>
    <span class="vi">@marshallable_attributes</span> <span class="o">||=</span> <span class="sx">%w(
      id
      email
      created_at
      updated_at
    )</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">marshal_dump</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">marshallable_attributes</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">attribute</span><span class="o">|</span>
      <span class="n">attributes</span><span class="p">[</span><span class="n">attribute</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">marshal_load</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">marshallable_attributes</span><span class="p">.</span><span class="nf">zip</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">[</span><span class="n">attributes</span><span class="p">]</span>
    <span class="n">initialize</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="vi">@new_record</span> <span class="o">=</span> <span class="nb">id</span><span class="p">.</span><span class="nf">blank?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The idea is to store a hard-coded sequence of attribute names and using it
serialize only values of attributes. It allows us to not serialize object links
of attribute names.</p>

<p>Why can’t we just get <code class="language-plaintext highlighter-rouge">attributes.keys.sort</code>? Because you can add one more
column that may come to the middle of that array. As a result, your
attributes may become shuffled. But probably you can avoid it by changing a cache key
right after adding a column.</p>

<p>You can extend this solution to something similar to <code class="language-plaintext highlighter-rouge">ActiveModel::Serializer</code>
where you have a separate serializer class for every model class.</p>

<p>Let’s see what this optimization gives us:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">84</span>
<span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">to_a</span><span class="p">).</span><span class="nf">length</span>
 <span class="o">=&gt;</span> <span class="mi">190</span>
</code></pre></div></div>

<p>That’s 10 times less then initial size, good job!</p>

<p>Of course, if you have columns with type <code class="language-plaintext highlighter-rouge">text</code> there’s nothing to
optimize, this is my example and my expirience.</p>

<h1 id="what-is-it-for">What is it for?</h1>

<p>I’ve been working for about 3 weeks on implementing <code class="language-plaintext highlighter-rouge">Marshal</code> module for <a href="https://github.com/opal/opal">opal</a>.
It’s almost compatible with MRI implementation. I believe <code class="language-plaintext highlighter-rouge">Marshal</code> is the thing
that can bring real isomorphism to opal applications. If you have a dumpable object
on the server and its class was compiled on the client, you can pass it <strong>directly</strong>
from the server without any serialization on the client/server.</p>

<h1 id="links">Links</h1>

<p><a href="https://github.com/iliabylich/pure_ruby_marshal">Github repo with PureRubyMarshal</a></p>

<p><a href="https://github.com/opal/opal/pull/1191">Possible Opal implementation of Marshal</a></p>]]></content><author><name></name></author><category term="ruby" /><category term="marshalling" /><category term="serialization" /><category term="tlv" /><summary type="html"><![CDATA[Marshalling is a serialization process when you convert an object to a binary string. Ruby has a standard class Marshal that does all the job for serialization and deserialization. To serialize an object, use Marshal.dump, to deserialize - Marshal.load or Marshal.restore.]]></summary></entry><entry><title type="html">HandlerSocket + Ruby</title><link href="https://iliabylich.github.io/2015/11/09/handlersocket-with-ruby.html" rel="alternate" type="text/html" title="HandlerSocket + Ruby" /><published>2015-11-09T21:00:00+00:00</published><updated>2015-11-09T21:00:00+00:00</updated><id>https://iliabylich.github.io/2015/11/09/handlersocket-with-ruby</id><content type="html" xml:base="https://iliabylich.github.io/2015/11/09/handlersocket-with-ruby.html"><![CDATA[<h1 id="what-is-handlersocket-hs">What is HandlerSocket (HS)</h1>

<ul>
  <li>a plugin for MySQL</li>
  <li>which allows you to read/write to MySQL</li>
  <li>and gives you a separate connection to MySQL</li>
  <li>and doesn’t allow you to run SQL queries</li>
  <li>but allows to run simple CRUD queries <em>only</em> using indexes</li>
</ul>

<p>HandlerSocket query language is very simple (I’d even say it’s primitive), but it’s much faster than MySQL’s one. Though, of course, there are some limitations. Interested?</p>

<h1 id="installation">Installation</h1>

<p>You already have it if you are using Percona Server or MariaDB. If not, install it from <a href="https://github.com/DeNA/HandlerSocket-Plugin-for-MySQL">the source</a>.</p>

<p>To activate the plugin, run:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">INSTALL</span> <span class="n">PLUGIN</span> <span class="n">handlersocket</span> <span class="n">SONAME</span> <span class="s1">'handlersocket.so'</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="configuration">Configuration</h1>

<p>My configuration is the following:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># [mysqld] section
# the port number to bind to for read requests
loose_handlersocket_port = 9998
# the port number to bind to for write requests
loose_handlersocket_port_wr = 9999
# the number of worker threads for read requests
loose_handlersocket_threads = 16
# the number of worker threads for write requests
loose_handlersocket_threads_wr = 1
open_files_limit = 65535
</code></pre></div></div>

<p>You can find a detailed documentation of all available configuration options <a href="https://github.com/ahiguti/HandlerSocket-Plugin-for-MySQL/blob/master/docs-en/configuration-options.en.txt">here</a></p>

<p>Restart your MySQL server and run:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">processlist</span><span class="err">\</span><span class="k">G</span>
</code></pre></div></div>

<p>You should see a lot of rows like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           Id: 1
         User: system user
         Host: connecting host
           db: NULL
      Command: Connect
         Time: NULL
        State: handlersocket: mode=rd, 0 conns, 0 active
         Info: NULL
    Rows_sent: 0
Rows_examined: 0
</code></pre></div></div>
<p>which means that HS daemon is up and running.</p>

<h1 id="simple-queries">Simple queries</h1>

<p>You can test it locally using <code class="language-plaintext highlighter-rouge">telnet</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>telnet 0.0.0.0 9999
Trying 0.0.0.0...
Connected to 0.0.0.0.
Escape character is <span class="s1">'^]'</span><span class="nb">.</span>
</code></pre></div></div>

<p>Type <code class="language-plaintext highlighter-rouge">P -&gt; 0 -&gt; your_database -&gt; your_table -&gt; PRIMARY -&gt; id,some_column</code> (where <code class="language-plaintext highlighter-rouge">-&gt;</code> is Tab). And press Enter. It should return <code class="language-plaintext highlighter-rouge">0 -&gt; 1</code>.</p>

<p>This protocol looks ugly, but it may save you a lot of network usage. It’s very compact, and parsing doesn’t require any CPU usage.</p>

<h1 id="use-cases">Use cases</h1>

<p>If you don’t have too much queries per second, probably you don’t need HS. It doesn’t optimize queries, but you may save some time on request parsing + some network. You may find it interesting if you have a lot of simple queries, like simple <code class="language-plaintext highlighter-rouge">SELECT</code>’s by primary key.</p>

<h1 id="ruby-adapter">Ruby adapter</h1>

<p>Here goes my Ruby for HandlerSocket protocol. You can find it <a href="https://github.com/iliabylich/handlersocket-ruby">here</a>.</p>

<p>It has two implementations inside:</p>
<ul>
  <li><a href="https://github.com/iliabylich/handlersocket-ruby/blob/master/lib/handlersocket/pure.rb">Ruby-based</a></li>
  <li><a href="https://github.com/iliabylich/handlersocket-ruby/blob/master/ext/handlersocket_ext/handlersocket_ext.c">C-based</a></li>
</ul>

<p>Ruby implementation is very slow, it’s there mainly to explain the protocol. C-based is quite fast.</p>

<h1 id="adapter-api">Adapter API</h1>

<p>To require a specific implementation, run</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For slow pure Ruby implementation</span>
<span class="nb">require</span> <span class="s1">'handlersocket/pure'</span>
<span class="c1"># For fast C implementation</span>
<span class="nb">require</span> <span class="s1">'handlersocket/ext'</span>
</code></pre></div></div>

<p>To create a connection, run</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hs</span> <span class="o">=</span> <span class="no">Handlersocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'0.0.0.0'</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span>
</code></pre></div></div>

<p>Both pure Ruby and C implementations have the same API, so the <code class="language-plaintext highlighter-rouge">require</code> place is the only difference.</p>

<p>To open an index, run</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hs</span><span class="p">.</span><span class="nf">open_index</span><span class="p">(</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'hs_test'</span><span class="p">,</span> <span class="s1">'users'</span><span class="p">,</span> <span class="s1">'PRIMARY'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'id'</span><span class="p">,</span> <span class="s1">'email'</span><span class="p">])</span>
</code></pre></div></div>

<p>To read the data from that index, run</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hs</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'='</span><span class="p">,</span> <span class="p">[</span><span class="s1">'12'</span><span class="p">],</span> <span class="p">[</span><span class="s1">'100]'</span><span class="p">])</span>
<span class="c1"># Which is equal to</span>
<span class="c1"># SELECT id, name FROM hs_test.users WHERE id = 12 LIMIT 100</span>
</code></pre></div></div>

<p>Other commands like auth/insert/update/delete are not there yet. But it’s not that difficult to add them, check out <a href="https://github.com/iliabylich/handlersocket-ruby/blob/master/lib/handlersocket.rb#L37">this file</a>, implementation of other methods also takes ~2 lines of code.</p>

<h1 id="benchmarks">Benchmarks</h1>

<p>The most interesting part. To run benchmarks locally, clone the gem repository on <a href="https://github.com/iliabylich/handlersocket-ruby">github</a> and run <code class="language-plaintext highlighter-rouge">rake benchmark</code>. It compares Mysql2 gem to Ruby-based and C-based implementations. Here are my results:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Calculating -------------------------------------
             pure HS     2.000  i/100ms
              ext HS     3.149k i/100ms
              mysql2   669.000  i/100ms
-------------------------------------------------
             pure HS     49.979  (± 2.0%) i/s -    250.000
              ext HS    110.369M (±15.7%) i/s -    467.793M
              mysql2      5.218M (±16.3%) i/s -     23.869M

Comparison:
              ext HS: 110369437.2 i/s
              mysql2:  5218120.6 i/s - 21.15x slower
             pure HS:       50.0 i/s - 2208314.91x slower
</code></pre></div></div>

<p>I’ve run these benchmarks on 4 cores server with 4GB ram on Percona server 5.6. On both small and huge (30 millions records) datasets, with enabled and disabled query cache, with a small and a big value of <code class="language-plaintext highlighter-rouge">innodb_buffer_pool_size</code>.</p>

<p>There’s a 20-30x performance difference between Mysql2 and a C-based version of HandlerSocket because:</p>
<ul>
  <li>almost no time is taken for request parsing</li>
  <li>mysql2 is just a way more complex than my gem</li>
</ul>

<p>And I was really disappointed by performance of Ruby-based implementation. It’s 2 millions times slower than C-based. Why? There’s a magical number <code class="language-plaintext highlighter-rouge">50.0 i/s</code>, but I cannot find what does it mean. If you have an answer, please, ping me on Twitter.</p>

<h1 id="future-plans">Future plans</h1>

<p>The gem <em>mostly</em> works, but there are some points that should be refined. Currently when network goes down there’s no way to reconnect because HS protocol is stateful. There’s no history tracking in HS objects, so if you open an index and then reconnect, you lose your opened index. I’m not sure if it should be implemented on a low level of abstraction in HS gem, probably it’s better to make a separated high-level gem for AR that does this job.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Once again, HandlerSocket saves your time on query parsing, buliding a query plan, it’s more compact, but is very limited. If you don’t have too many requests, don’t even think about using it.</p>

<h1 id="links">Links</h1>

<p><a href="https://github.com/DeNA/HandlerSocket-Plugin-for-MySQL/blob/master/docs-en/protocol.en.txt">HandlerSocket protocol</a></p>

<p><a href="https://github.com/iliabylich/handlersocket-ruby">Ruby gem for HandlerSocket</a></p>

<p><a href="https://github.com/ahiguti/HandlerSocket-Plugin-for-MySQL/blob/master/docs-en/configuration-options.en.txt">HandlerSocket configuration</a></p>]]></content><author><name></name></author><category term="ruby" /><category term="mysql" /><category term="handlersocket" /><category term="databases" /><category term="sql" /><category term="nosql" /><summary type="html"><![CDATA[What is HandlerSocket (HS)]]></summary></entry><entry><title type="html">Saving execution context for later debugging</title><link href="https://iliabylich.github.io/2015/08/20/saving-execution-context-for-later-debugging.html" rel="alternate" type="text/html" title="Saving execution context for later debugging" /><published>2015-08-20T21:00:00+00:00</published><updated>2015-08-20T21:00:00+00:00</updated><id>https://iliabylich.github.io/2015/08/20/saving-execution-context-for-later-debugging</id><content type="html" xml:base="https://iliabylich.github.io/2015/08/20/saving-execution-context-for-later-debugging.html"><![CDATA[<p>Consider the following situation: you’ve got an exception in production. Of course, all of us are good developers, but you know, sometimes *it just happens. What do you usually do to get some information about the error? You just grab the request parameters to test it locally, right? Then I might have a better solution for you: dump your memory once an error happens and restore the dump later to debug it.</p>

<h2 id="binding">Binding</h2>

<p>In Ruby the best candidate for doing this is <code class="language-plaintext highlighter-rouge">Binding</code> class. If you have a binding, your can easily do some debug using well-known <code class="language-plaintext highlighter-rouge">pry</code> gem. But the binding itself cannot be dumped (at least not, using default Ruby tools).</p>

<p>How to get a local binding? Just use <code class="language-plaintext highlighter-rouge">binding</code>. How to get a binding from an object? Just add a method to you class:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="k">def</span> <span class="nf">local_binding</span>
    <span class="nb">binding</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">MyClass</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">local_binding</span>
<span class="c1"># =&gt; #&lt;Binding&gt;</span>
</code></pre></div></div>

<p>Binding encapsulates the execution context at the place in your code where the interpreter is currently running and retains this context for future use. So, to dump and load back a binding we need to:</p>
<ul>
  <li>Dump the context of the binding (i.e. <code class="language-plaintext highlighter-rouge">binding.eval('self')</code>)</li>
  <li>Dump all local variables (i.e. <code class="language-plaintext highlighter-rouge">binding.eval('local_variables')</code>)</li>
</ul>

<p>In fact, that’s all you need to restore your binding.</p>

<h2 id="marshaling">Marshaling</h2>

<p>How can we dump an arbitrary structure? Ruby has a class in stdlib called <code class="language-plaintext highlighter-rouge">Marshal</code>. The two core methods of this class are <code class="language-plaintext highlighter-rouge">dump</code> and <code class="language-plaintext highlighter-rouge">load</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Point</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">34</span><span class="p">,</span> <span class="mi">65</span><span class="p">)</span>
<span class="n">marshaled</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># =&gt; "\x04\bS:\nPoint\a:\x06xi':\x06yiF"</span>
<span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">marshaled</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;struct Point x=34, y=65&gt;</span>
</code></pre></div></div>

<h2 id="limitations">Limitations</h2>

<p>Unfortunately, not everything can be marshaled. According to the documentation, the following objects cannot be dumped:</p>
<ul>
  <li>bindings (e.g., the return value of binding itself)</li>
  <li>procedure or method objects (e.g., <code class="language-plaintext highlighter-rouge">proc {}</code> or <code class="language-plaintext highlighter-rouge">object.method(:method_name)</code>)</li>
  <li>instances of class IO (e.g., <code class="language-plaintext highlighter-rouge">IO.new(1)</code> or <code class="language-plaintext highlighter-rouge">StringIO.new</code>)</li>
  <li>anonymous classes and modules (e.g. <code class="language-plaintext highlighter-rouge">Class.new</code> or <code class="language-plaintext highlighter-rouge">Module.new</code>)</li>
</ul>

<p>That sound really sad, but in most cases we can ignore these limitations. When was the last time you needed to debug an IO object that was doing something strange? In real life we rarely use any of these classes <strong>during debugging process</strong>. So, instead of dumping and loading back  an <code class="language-plaintext highlighter-rouge">IO</code> object we can just return a new one.</p>

<h2 id="converting-objects-to-marshalable-data">Converting objects to marshalable data</h2>

<p>Well, we can patch every single class in Ruby and add <code class="language-plaintext highlighter-rouge">marshal_load</code> and <code class="language-plaintext highlighter-rouge">marshal_dump</code> hooks to them, but that’s just horrible. It would be much, much better to write a set of classes that are each responsible for converting a specific group of objects.</p>

<p>With that in mind I’ve implemented:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">PrimitiveDumper</code> - for dumping primitive objects, like numbers, booleans.</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayDumper</code> - for arrays.</li>
  <li><code class="language-plaintext highlighter-rouge">HashDumper</code> - for hashes.</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectDumper</code> - for custom objects.</li>
  <li><code class="language-plaintext highlighter-rouge">ClassDumper</code> - for classes.</li>
  <li><code class="language-plaintext highlighter-rouge">ProcDumper</code> - for proc/method objects</li>
  <li><code class="language-plaintext highlighter-rouge">MagicDumper</code> - for “magical objects” (see ‘dumping magical objects’ section)</li>
  <li><code class="language-plaintext highlighter-rouge">ExistingObjectDumper</code> - for existing objects (see ‘dumping recurring objects’ section)</li>
</ol>

<p>Every dumper takes an object that we need to dump and returns its marshalable representation. Later you can use the same dumper to deconvert representation back and get the original object.</p>

<p>You can find the implementation of these dumpers <a href="https://github.com/iliabylich/binding_dumper/tree/master/lib/binding_dumper/dumpers">here</a> and the specs for them <a href="https://github.com/iliabylich/binding_dumper/tree/master/spec/binding_dumper/dumpers">here</a>.</p>

<p>Here is, probably, the most complicated example:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">undumpable_recursive_object</span>
  <span class="vi">@undumpable_recursive</span> <span class="o">||=</span> <span class="k">begin</span>
    <span class="nb">p</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">allocate</span>
    <span class="nb">p</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="nb">p</span>
    <span class="nb">p</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span>
    <span class="nb">p</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>After converting this object using a system of dumpers result looks like this:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">_klass: </span><span class="no">Point</span><span class="p">,</span>
  <span class="ss">_ivars: </span><span class="p">{</span>
    <span class="ss">:@x</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="ss">_existing_object_id: </span><span class="mi">1234566</span> <span class="c1"># or similar</span>
    <span class="p">},</span>
    <span class="ss">:@y</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="ss">_klass: </span><span class="no">StringIO</span><span class="p">,</span>
      <span class="ss">_undumpable: </span><span class="kp">true</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="ss">_old_object_id: </span><span class="mi">1234566</span> <span class="c1"># same as above</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This hash can be easily marshaled and restored back. But yes, we lose our <code class="language-plaintext highlighter-rouge">StringIO</code> instance - when the object is loaded back, that variable will be blank.</p>

<h2 id="dumping-magical-objects">Dumping Magical objects</h2>

<p>After writing the first version of the library, I’ve tested it with a blank Rails application. The testing code was:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># 5 records</span>
    <span class="n">local_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}</span>
    <span class="n">render</span> <span class="ss">json: </span><span class="vi">@users</span>
    <span class="no">StoredBinding</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">data: </span><span class="nb">binding</span><span class="p">.</span><span class="nf">dump</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The length of the dump was  ~30 screens and it took ~20 seconds to generate it. Most of the data was coming from objects related to Rails itself. Things like Rails configs, backtrace cleaners, arrays of middlewares, and so on. Do we need them? No. These objects are the same for every request, so we can ignore them.</p>

<p>But at the same time, we need to save and restore all references from ‘dumpable’ objects to ‘magic’ objects, we can’t just omit them. This logic is implemented in <a href="https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/magic_objects.rb">BindingDumper::MagicObjects</a> module and here’s how you can use it:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span>
  <span class="vi">@config</span> <span class="o">=</span> <span class="ss">:config</span>
<span class="k">end</span>

<span class="no">BindingDumper</span><span class="o">::</span><span class="no">MagicObjects</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="no">A</span><span class="p">)</span>
<span class="nb">p</span> <span class="no">BindingDumper</span><span class="o">::</span><span class="no">MagicObjects</span><span class="p">.</span><span class="nf">pool</span>
<span class="o">=&gt;</span> <span class="p">{</span><span class="mi">10633360</span><span class="o">=&gt;</span><span class="s2">"A"</span><span class="p">,</span> <span class="mi">600668</span><span class="o">=&gt;</span><span class="s2">"A.instance_variable_get(:@config)"</span><span class="p">}</span>
</code></pre></div></div>

<p>So, it builds a mapping between <code class="language-plaintext highlighter-rouge">object_id</code> and the way how to get this object. Using this functionality we can easily get whether existing object is ‘magical’, and if yes - dump its string representation (to eval it on loading phase). Let’s say, we need to dump <code class="language-plaintext highlighter-rouge">Rails.application.config</code>, one of the ‘magical’ objects. We need to get its <code class="language-plaintext highlighter-rouge">object_id</code>, find it in the pool and remember the string that returns rails config after evaluation, i.e.:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"Rails.
  instance_variable_get(:@app_class).
  instance_variable_get(:@instance).
  instance_variable_get(:@config)"</span>
</code></pre></div></div>

<p>After this optimization we have to spend ~20ms to build an object pool and ~200ms to dump a binding.</p>

<h2 id="dumping-recurring-objects">Dumping recurring objects</h2>

<p>We can optimize it even more. A lot of things like <code class="language-plaintext highlighter-rouge">request</code>, <code class="language-plaintext highlighter-rouge">response</code> are shared as instance variables across ~10 objects. We can dump our <code class="language-plaintext highlighter-rouge">request</code> object only once, remember its <code class="language-plaintext highlighter-rouge">object_id</code> and use a reference while dumping other objects that use it.</p>

<p>Let’s say, we are in the initial memory (MEM1). We dump a binding, open another console with separated memory (MEM2) and restore a binding. In the example above (about recursive structure) there was a key <code class="language-plaintext highlighter-rouge">:_existing_object_id</code> that returns an <code class="language-plaintext highlighter-rouge">object_id</code> from MEM1.</p>

<p>In MEM2 we restore a binding and create a mapping</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="n">object_id_from_MEM1</span> <span class="o">=&gt;</span>
  <span class="n">restored_object_in_MEM2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using this mapping (in the gem it’s called <a href="https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/memories.rb">memories</a>) we can restore the reference to duplicated objects.</p>

<h2 id="restoring-a-binding">Restoring a binding</h2>

<p>At this point you can be really confused, but relax, we are almost done.</p>

<p>So, we have a binding. To dump it we need to:</p>
<ol>
  <li>Build a <code class="language-plaintext highlighter-rouge">hash1</code> with the context of binding and local variables</li>
  <li>Convert it to a marshalable nested <code class="language-plaintext highlighter-rouge">hash2</code></li>
  <li><code class="language-plaintext highlighter-rouge">Marshal.dump(hash2)</code></li>
  <li>Store the result in any persistent storage.</li>
</ol>

<p>To load it back:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Marshal.load</code> the dump to get <code class="language-plaintext highlighter-rouge">hash2</code></li>
  <li>Convert <code class="language-plaintext highlighter-rouge">hash2</code> to <code class="language-plaintext highlighter-rouge">hash1</code> using the same converters</li>
  <li>Load the context and all local variables from <code class="language-plaintext highlighter-rouge">hash1</code></li>
  <li>Patch the context a little bit to make it pretty.</li>
</ol>

<p>Steps 1-4 and 1-3 are already implemented. The last step – making the context pretty – means that we need to inject local_binding method into the context and make it look like the “real” binding (inject local variables to the binding).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we just have it,</span>
<span class="c1"># it's a `self` from the place where `binding.dump` was called</span>
<span class="n">context</span>

<span class="c1"># and we have also local variables</span>
<span class="nb">local_variables</span>

<span class="c1"># here we need to get a binding that:</span>
<span class="n">subject</span><span class="p">.</span><span class="nf">local_binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'self'</span><span class="p">)</span> <span class="o">==</span> <span class="n">context</span>
<span class="c1"># =&gt; true</span>
<span class="n">subject</span><span class="p">.</span><span class="nf">local_binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'local_variables'</span><span class="p">)</span> <span class="o">==</span> <span class="nb">local_variables</span>
<span class="c1"># =&gt; true</span>
</code></pre></div></div>

<p>The pseudo-code for loading and patching the context looks like:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">marshaled</span> <span class="o">=</span> <span class="no">StoredBinding</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">data</span>
<span class="n">converted</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">marshaled</span><span class="p">)</span>
<span class="n">restored</span> <span class="o">=</span> <span class="no">Dumpers</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">converted</span><span class="p">)</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">undumped</span><span class="p">[</span><span class="ss">:context</span><span class="p">]</span>
<span class="n">locals</span> <span class="o">=</span> <span class="n">undumped</span><span class="p">[</span><span class="ss">:locals</span><span class="p">]</span>

<span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">context</span>
  <span class="k">def</span> <span class="nf">local_binding</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">binding</span>

    <span class="n">locals</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lvar_name</span><span class="p">,</span> <span class="n">lvar</span><span class="o">|</span>
      <span class="n">result</span><span class="p">.</span><span class="nf">local_variable_set</span><span class="p">(</span><span class="n">lvar_name</span><span class="p">,</span> <span class="n">lvar</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The actual implementation can be found <a href="https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/core_ext/binding_ext.rb">here</a>. After calling <code class="language-plaintext highlighter-rouge">Binding.load(dumped).pry</code> you can start debugging it!</p>

<h2 id="compatibility-with-old-versions-of-ruby">Compatibility with old versions of Ruby</h2>

<p>Currently the gem supports Ruby versions from 1.9.3 to 2.2.3. I had a few issues with porting the code from 2.0.0 to 1.9.3, like the lack of kwargs and <code class="language-plaintext highlighter-rouge">Module#prepend</code>. The funniest one was that in versions before 2.1.0 there is no <code class="language-plaintext highlighter-rouge">binding.local_variable_set</code> - there is only <code class="language-plaintext highlighter-rouge">binding.eval</code> that takes a string, not a block.</p>

<p>How can we pass a complex object to <code class="language-plaintext highlighter-rouge">eval</code>? The solution is not so difficult, because we have the object right here and right now, and the binding uses the same memory as the main thread. This means that we can pass the <code class="language-plaintext highlighter-rouge">object_id</code> of our object to <code class="language-plaintext highlighter-rouge">eval</code> string and get it there using <code class="language-plaintext highlighter-rouge">ObjectSpace._id2ref</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undumped</span><span class="p">[</span><span class="ss">:lvars</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lvar_name</span><span class="p">,</span> <span class="n">lvar</span><span class="o">|</span>
  <span class="n">result</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">lvar_name</span><span class="si">}</span><span class="s2"> = ObjectSpace._id2ref(</span><span class="si">#{</span><span class="n">lvar</span><span class="p">.</span><span class="nf">object_id</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="known-issues">Known issues</h2>

<p>I’ve tested the gem locally with a few projects. Everything was fine, but:</p>
<ol>
  <li>Encoding. The data that the gem produces should be stored in UTF-8</li>
  <li>The difference between Rails server and Rails console. There are some classes that are loaded only when the server is started (like <code class="language-plaintext highlighter-rouge">Rails::BacktraceCleaner</code> and some others from <code class="language-plaintext highlighter-rouge">NewRelic</code> gem). You have to require corresponding files manually before loading the binding in the console.</li>
</ol>

<h2 id="demo">Demo</h2>

<p>To try it out, clone the <a href="https://github.com/iliabylich/binding_dumper">GitHub repository</a>, install dependencies, prepare the database using <code class="language-plaintext highlighter-rouge">bin/dummy_rake db:create db:migrate</code>, and start the server via <code class="language-plaintext highlighter-rouge">bin/dummy_rails s</code>. Then visit <a href="http://localhost:3000/users">http://localhost:3000/users</a> to dump the binding of <code class="language-plaintext highlighter-rouge">UsersController#index</code>. After that you can open a console using <code class="language-plaintext highlighter-rouge">bin/dummy_rails c</code> and run <code class="language-plaintext highlighter-rouge">StoredBinding.last.debug</code>. You’re now in your controller, in the same state that it was in a moment ago when you hit that /users page!.</p>

<h2 id="testing">Testing</h2>

<p>The gem is fully tested with its specs running on <a href="https://travis-ci.org/iliabylich/binding_dumper/">Travis CI</a>. There’s also a <a href="https://github.com/iliabylich/binding_dumper/blob/master/bin/multitest">script</a> that can be used to run the whole test suite locally on <strong>every</strong> supported version of Ruby. But that’s definitely not enough for a gem to become completely production-ready.</p>

<p>That’s why I ask everyone who read this article: if you think that the idea of this gem should stay alive, that this method of debugging can be useful, and you would like to use it yourself, please, try it out locally and share your finding with me (via Twitter or Github).</p>

<h2 id="links">Links</h2>

<p><a href="https://github.com/iliabylich/binding_dumper">Github repo</a></p>]]></content><author><name></name></author><category term="ruby" /><category term="binding" /><category term="closure" /><category term="debugging" /><summary type="html"><![CDATA[Consider the following situation: you’ve got an exception in production. Of course, all of us are good developers, but you know, sometimes *it just happens. What do you usually do to get some information about the error? You just grab the request parameters to test it locally, right? Then I might have a better solution for you: dump your memory once an error happens and restore the dump later to debug it.]]></summary></entry><entry><title type="html">Wrapping JavaScript library with Opal</title><link href="https://iliabylich.github.io/2015/07/22/wrapping-javascript-library-with-opal.html" rel="alternate" type="text/html" title="Wrapping JavaScript library with Opal" /><published>2015-07-22T21:00:00+00:00</published><updated>2015-07-22T21:00:00+00:00</updated><id>https://iliabylich.github.io/2015/07/22/wrapping-javascript-library-with-opal</id><content type="html" xml:base="https://iliabylich.github.io/2015/07/22/wrapping-javascript-library-with-opal.html"><![CDATA[<h1 id="introduction">Introduction</h1>

<p>The task that is solved here is not real, but it’s still a good example of (probably?) real work with Opal. I could choose some complex enough JavaScript library and write a simple wrapper using Opal, but there’s no fun. Instead, let’s write a wrapper for existing rich client-side application (it may show you how to wrap your existing application logic). Well, wrapper for something like a client-side scheduler may sound boring, so I’ve chosen a JS-based browser game called <a href="http://browserquest.mozilla.org">BrowserQuest</a> <a href="https://github.com/mozilla/BrowserQuest">written</a> by Mozilla, and I’ll show you how to write a bot for it using Opal.</p>

<h1 id="opal">Opal</h1>

<p>There are so many posts about <a href="https://github.com/opal/opal">Opal</a>, so I’m just going to say “it’s a Ruby to JavaScript” compiler, that’s enough.</p>

<h1 id="environment">Environment</h1>

<p>First of all, we need something that runs the game and injects a bot into the page. I, personally, while writing integration tests (this is the place, where we usually face to web drivers), prefer PhantomJS, but it’s headless, so you can’t enjoy watching how your bot works. We have to use something like Capybara + Selenium:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Gemfile</span>
<span class="n">gem</span> <span class="s1">'capybara'</span>
<span class="n">gem</span> <span class="s1">'selenium-webdriver'</span>

<span class="c1"># runner.rb</span>
<span class="nb">require</span> <span class="s1">'capybara'</span>

<span class="no">Capybara</span><span class="p">.</span><span class="nf">register_driver</span> <span class="ss">:selenium</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
  <span class="no">Capybara</span><span class="o">::</span><span class="no">Selenium</span><span class="o">::</span><span class="no">Driver</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="ss">:browser</span> <span class="o">=&gt;</span> <span class="ss">:firefox</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">Capybara</span><span class="p">.</span><span class="nf">javascript_driver</span> <span class="o">=</span> <span class="ss">:selenium</span>
<span class="no">Capybara</span><span class="p">.</span><span class="nf">default_driver</span> <span class="o">=</span> <span class="ss">:selenium</span>
<span class="no">Capybara</span><span class="p">.</span><span class="nf">run_server</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div></div>

<p>So, the script registers a driver, specifies its browser (Firefox), makes it default and runs Capybara in browser mode (i.e. without own server in the background)</p>

<h1 id="opening-the-page">Opening the page</h1>

<p>Dead simple:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Capybara</span><span class="p">.</span><span class="nf">current_session</span><span class="p">.</span><span class="nf">visit</span><span class="p">(</span><span class="s1">'http://browserquest.mozilla.org'</span><span class="p">)</span>
<span class="c1"># or in object-oriented style</span>
<span class="k">class</span> <span class="nc">Game</span>
  <span class="kp">include</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">DSL</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># all methods of</span>
    <span class="c1"># Capybara.current_session</span>
    <span class="c1"># are available here</span>
    <span class="n">visit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">play</span>
    <span class="c1"># logic of the bot</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Game</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'http://browserquest.mozilla.org/'</span><span class="p">).</span><span class="nf">play</span>
</code></pre></div></div>

<p>Now it runs a Firefox and opens the page with the game.</p>

<h1 id="compiling-opal">Compiling Opal</h1>

<p>So, there are two ways to compile Ruby into Javascript:</p>
<ul>
  <li>compiling Ruby code as a string to JS string</li>
  <li>compiling specified Ruby file to JS string</li>
</ul>

<p>To compile a file with Ruby, run:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Opal</span><span class="p">.</span><span class="nf">append_path</span><span class="p">(</span><span class="s1">'some/path/to/dir/with/your/files'</span><span class="p">)</span>
<span class="no">Opal</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="s1">'relative/path/from/that/dir/to/you/file'</span><span class="p">)</span>
</code></pre></div></div>

<p>To compile a string with ruby:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Opal</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"plain ruby code"</span><span class="p">)</span>
</code></pre></div></div>

<p>The first way is what we really need:</p>
<ol>
  <li>create a directory with all opal files</li>
  <li>add it to Opal’s load path</li>
  <li>(all <code class="language-plaintext highlighter-rouge">require</code> commands work as in MRI)</li>
  <li>create a file called <code class="language-plaintext highlighter-rouge">app.rb</code> that <code class="language-plaintext highlighter-rouge">require</code>-s other files</li>
  <li>embed <code class="language-plaintext highlighter-rouge">app.rb</code> to the page</li>
</ol>

<h1 id="fetching-the-data-from-the-game">Fetching the data from the game</h1>

<p><a href="https://github.com/mozilla/BrowserQuest/blob/master/client/js/main.js#L7">This</a> is the place where the main <code class="language-plaintext highlighter-rouge">App</code> class is created. But! It’s defined in anonymous function, so this variable is not available outside the context.</p>

<p>This game uses CommonJS for loading files. This library caches(?) all previously required files and instantly returns cached result on the seconds <code class="language-plaintext highlighter-rouge">require</code>.</p>

<p>We can use it:</p>
<ol>
  <li>require <code class="language-plaintext highlighter-rouge">app</code> file.</li>
  <li>wrap any of its methods with some logic that stores current app instance globally and then call <code class="language-plaintext highlighter-rouge">super</code></li>
</ol>

<p>I’ve chosen a method called <code class="language-plaintext highlighter-rouge">start</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># opal/bot.rb</span>
<span class="k">module</span> <span class="nn">Patch</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">apply</span>
    <span class="sx">%x{
      var app = require('app');
      oldStart = app.prototype.start;
      app.prototype.start = function(username) {
        window.currentApplication = this;
        oldStart.apply(this, arguments);
      }
    }</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Patch</span><span class="p">.</span><span class="nf">apply</span>
</code></pre></div></div>

<p>Some explanations:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">%x{js code}</code> just passes provided JS into compiled version (i.e. runs it without any translation)</li>
  <li>After compiling this file we have access to a variable <code class="language-plaintext highlighter-rouge">currentApplication</code> that contains an instance of <code class="language-plaintext highlighter-rouge">App</code> class</li>
</ul>

<h1 id="starting-the-game">Starting the game</h1>

<p>As you can see, to start the game you need to:</p>
<ol>
  <li>type your player name</li>
  <li>wait for ‘Play’ button to activate (become red)</li>
  <li>press ‘Play’ button</li>
  <li>wait until all assets will be loaded</li>
  <li>close instructions that the game opens for any new player</li>
</ol>

<p>After all of these steps the game will be ready, but the point here is that most of the steps are asynchronous. You can’t just type your name and <strong>immediately</strong> press ‘Play’ button (and you can’t press ‘Play’ without waiting for loading)</p>

<p>This is the place where promises shine. Opal has its own standard library that</p>
<ul>
  <li>ships with Opal’s code, so it’s already in the page</li>
  <li>has a class called <code class="language-plaintext highlighter-rouge">Promise</code> that acts pretty much like a <code class="language-plaintext highlighter-rouge">jQuery.Deferred()</code></li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'promise'</span>

<span class="n">promise</span> <span class="o">=</span> <span class="no">Promise</span><span class="p">.</span><span class="nf">new</span>
<span class="n">promise</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">'Done'</span> <span class="p">}</span>
<span class="n">promise</span><span class="p">.</span><span class="nf">fail</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">'Fail'</span> <span class="p">}</span>
<span class="n">promise</span><span class="p">.</span><span class="nf">resolve</span>
<span class="c1"># =&gt; 'Done' (in JS console)</span>
<span class="c1"># or</span>
<span class="n">promise</span><span class="p">.</span><span class="nf">reject</span>
<span class="c1"># =&gt; 'Fail'</span>
</code></pre></div></div>

<p>(<code class="language-plaintext highlighter-rouge">Promise</code> is like an object that is a combination of <code class="language-plaintext highlighter-rouge">callback</code>-s and <code class="language-plaintext highlighter-rouge">errback</code>-s, but you don’t invoke callbacks manually, instead you just switch the state of your promise-object and it automatically triggers callbacks/errobacks)</p>

<p>Here is a little helper module that saves our time:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Utils</span>
  <span class="k">def</span> <span class="nf">wait_for</span><span class="p">(</span><span class="n">promise</span> <span class="o">=</span> <span class="no">Promise</span><span class="p">.</span><span class="nf">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiting</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">waiting</span><span class="p">.</span><span class="nf">call</span>
    <span class="k">if</span> <span class="o">!!</span><span class="n">result</span>
      <span class="n">promise</span><span class="p">.</span><span class="nf">resolve</span>
    <span class="k">else</span>
      <span class="n">after</span> <span class="mf">0.1</span> <span class="k">do</span>
        <span class="n">wait_for</span><span class="p">(</span><span class="n">promise</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiting</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">promise</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># and usage</span>

<span class="k">class</span> <span class="nc">MyClass</span>
  <span class="kp">include</span> <span class="no">Utils</span>

  <span class="k">def</span> <span class="nf">call</span>
    <span class="n">some_async_method_without_ability_to_pass_callback</span>
    <span class="n">wait_for</span> <span class="k">do</span>
      <span class="n">method_called</span> <span class="o">&amp;&amp;</span> <span class="n">result_is_success</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">wait_for</code> method takes a promise (which is a blank promise object by default) and a block (which will be converted to JS function). It calls the block and <code class="language-plaintext highlighter-rouge">resolve</code>-s the promise if it is returned true. If not, it calls itself again after 100ms (<code class="language-plaintext highlighter-rouge">after</code> = <code class="language-plaintext highlighter-rouge">setTimeout</code>) with <strong>the same promise object</strong></p>

<p>To type player’s name we should run:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># I'm using opal-jquery here</span>
<span class="c1"># I think it doesn't require any explanation</span>
<span class="n">input</span> <span class="o">=</span> <span class="no">Element</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="s1">'#nameinput'</span><span class="p">)</span>
<span class="n">input</span><span class="p">.</span><span class="nf">value</span> <span class="o">=</span> <span class="vi">@player_name</span>
<span class="n">wait_for</span> <span class="k">do</span>
  <span class="no">Element</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="s1">'.play.button.disabled'</span><span class="p">).</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">end</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
  <span class="c1"># Button is ready, we can click it here</span>
<span class="k">end</span>
</code></pre></div></div>

<p>To click the button, run:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">button</span> <span class="o">=</span> <span class="no">Element</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="s1">'#createcharacter .play.button div'</span><span class="p">)</span>
<span class="n">button</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span>
<span class="n">wait_for</span> <span class="k">do</span>
  <span class="no">Element</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="s1">'#instructions'</span><span class="p">).</span><span class="nf">has_class?</span><span class="p">(</span><span class="s1">'active'</span><span class="p">)</span>
<span class="k">end</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
  <span class="c1"># The game is ready here</span>
  <span class="c1"># And it shows us instructions</span>
  <span class="c1"># We are almost ready to start the game</span>
<span class="k">end</span>
</code></pre></div></div>

<p>To close instructions, run:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Element</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="s1">'#instructions'</span><span class="p">).</span><span class="nf">trigger</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span>
</code></pre></div></div>

<p><a href="https://github.com/iliabylich/opal-browserquest-bot/blob/master/bot/opal/commands/start_game.rb">And put everything together</a></p>

<p>To run this command, call</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">StartGame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'Bot player'</span><span class="p">).</span><span class="nf">invoke</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
  <span class="n">alert</span><span class="p">(</span><span class="s2">"I'm in the game"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h1 id="time-to-wrap-the-code-of-the-game">Time to wrap the code of the game</h1>

<p>As an enter point we are going to use global JS variable <code class="language-plaintext highlighter-rouge">currentApplication</code>. It has a property <code class="language-plaintext highlighter-rouge">game</code> (that, unexpectedly, returns instance of <code class="language-plaintext highlighter-rouge">Game</code> class). <code class="language-plaintext highlighter-rouge">game</code> has a <code class="language-plaintext highlighter-rouge">player</code> property (instance of <code class="language-plaintext highlighter-rouge">Player</code>) and <code class="language-plaintext highlighter-rouge">entities</code> property which is an object containing all entities on the map, their types and coordinates. You can easily find their JS implementations in the GitHub repository of the game.</p>

<p>So, our main objects are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">currentApplication</code></li>
  <li><code class="language-plaintext highlighter-rouge">currentApplication.game</code></li>
  <li><code class="language-plaintext highlighter-rouge">currentApplication.game.player</code></li>
  <li><code class="language-plaintext highlighter-rouge">currentApplication.game.entities</code></li>
</ul>

<p>First class for wrapping is definitely an <code class="language-plaintext highlighter-rouge">App</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Application</span>
  <span class="kp">include</span> <span class="no">Native</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">current</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="sb">`currentApplication`</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">native</span><span class="p">)</span>
    <span class="vi">@native</span> <span class="o">=</span> <span class="n">native</span>
  <span class="k">end</span>

  <span class="n">alias_native</span> <span class="ss">:game</span><span class="p">,</span> <span class="ss">:game</span><span class="p">,</span> <span class="ss">as: </span><span class="no">Game</span>

  <span class="k">def</span> <span class="nf">to_n</span>
    <span class="vi">@native</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>So, we have a class called <code class="language-plaintext highlighter-rouge">Application</code> that wraps some native JS object and has a ruby-method <code class="language-plaintext highlighter-rouge">game</code> that calls JS-method <code class="language-plaintext highlighter-rouge">game</code> and wraps it using <code class="language-plaintext highlighter-rouge">Game</code> class (see below). As a bonus, we have a class-method <code class="language-plaintext highlighter-rouge">current</code> that returns wrapped <code class="language-plaintext highlighter-rouge">currentApplication</code>.</p>

<p>The next class is a <code class="language-plaintext highlighter-rouge">Game</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Game</span>
  <span class="kp">include</span> <span class="no">Native</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">current</span>
    <span class="no">Application</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">game</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">native</span><span class="p">)</span>
    <span class="vi">@native</span> <span class="o">=</span> <span class="n">native</span>
  <span class="k">end</span>

  <span class="n">alias_native</span> <span class="ss">:player</span><span class="p">,</span> <span class="ss">:player</span><span class="p">,</span> <span class="ss">as: </span><span class="no">Player</span>
  <span class="n">alias_native</span> <span class="ss">:say</span>

  <span class="k">def</span> <span class="nf">to_n</span>
    <span class="vi">@native</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">entities</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">native_entities</span> <span class="o">=</span> <span class="sb">`currentApplication.game.entities`</span>
    <span class="no">Native</span><span class="o">::</span><span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">native_entities</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e_id</span><span class="p">,</span> <span class="n">e</span><span class="o">|</span>
      <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="no">Native</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="no">EntityCollection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And again, this class can wrap any JS game object, has methods <code class="language-plaintext highlighter-rouge">player</code>, <code class="language-plaintext highlighter-rouge">say</code> and <code class="language-plaintext highlighter-rouge">entities</code> (<code class="language-plaintext highlighter-rouge">EntityCollection</code> is our next class to implement).</p>

<p>(we can test method <code class="language-plaintext highlighter-rouge">say</code> write now, just put <code class="language-plaintext highlighter-rouge">Game.current.say('Hello')</code> to the block where the game is ready and start chatting with other players)</p>

<h1 id="entities">Entities</h1>

<p>The game provides a global JS object <code class="language-plaintext highlighter-rouge">Types</code> with all mobs/items/armors/weapons information, it allows to identify unknown entity, compare armors and weapons by rank. Basically, it provides everything for writing a bot logic.</p>

<p>To convert it to Ruby, use <code class="language-plaintext highlighter-rouge">Types = Native(`Types`)</code> and use this object in the Ruby world!</p>

<p>Here is my definition of <code class="language-plaintext highlighter-rouge">Entity</code> class:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Entity</span>
  <span class="kp">include</span> <span class="no">Native</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">native</span><span class="p">)</span>
    <span class="vi">@native</span> <span class="o">=</span> <span class="n">native</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_n</span>
    <span class="vi">@native</span>
  <span class="k">end</span>

  <span class="n">alias_native</span> <span class="ss">:kind</span>

  <span class="k">def</span> <span class="nf">player?</span>
    <span class="no">Types</span><span class="p">.</span><span class="nf">isPlayer</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># some other methods</span>
  <span class="c1"># like mob?</span>
  <span class="c1"># or heal?</span>

  <span class="k">def</span> <span class="nf">weapon_rank</span>
    <span class="no">Types</span><span class="p">.</span><span class="nf">getWeaponRank</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">armor_rank</span>
    <span class="no">Types</span><span class="p">.</span><span class="nf">getArmorRank</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Well, this class can wrap player/mob/armor/weapon/healing, but this is only a value-object, we still need to implement our collection-object <code class="language-plaintext highlighter-rouge">EntityCollection</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EntityCollection</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">native_entities</span><span class="p">)</span>
    <span class="vi">@entities</span> <span class="o">=</span> <span class="n">native_entities</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">native_entity</span><span class="o">|</span>
      <span class="no">Entity</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">native_entity</span><span class="p">.</span><span class="nf">to_n</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">players</span>
    <span class="n">entities</span> <span class="o">=</span> <span class="vi">@entities</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:player?</span><span class="p">)</span>
    <span class="no">EntityCollection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># similar methods like</span>
  <span class="c1"># mobs/weapons/armors/healings</span>
  <span class="c1"># are omitted and are just like 'players' method</span>
<span class="k">end</span>
</code></pre></div></div>

<h1 id="player-class">Player class</h1>

<p>(quickly and without any explanation):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Player</span>
  <span class="kp">include</span> <span class="no">Utils</span>
  <span class="kp">include</span> <span class="no">Native</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">current</span>
    <span class="no">Game</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">player</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">native</span><span class="p">)</span>
    <span class="vi">@native</span> <span class="o">=</span> <span class="n">native</span>
  <span class="k">end</span>

  <span class="n">alias_native</span> <span class="ss">:distance_to</span><span class="p">,</span> <span class="ss">:getDistanceToEntity</span>
  <span class="n">alias_native</span> <span class="ss">:moving?</span><span class="p">,</span> <span class="ss">:isMoving</span>
  <span class="n">alias_native</span> <span class="ss">:attacking?</span><span class="p">,</span> <span class="ss">:isAttacking</span>
  <span class="n">alias_native</span> <span class="ss">:hp</span><span class="p">,</span> <span class="ss">:hitPoints</span>
  <span class="n">alias_native</span> <span class="ss">:max_hp</span><span class="p">,</span> <span class="ss">:maxHitPoints</span>

  <span class="k">def</span> <span class="nf">full_hp?</span>
    <span class="n">hp</span> <span class="o">==</span> <span class="n">max_hp</span>
  <span class="k">end</span>

  <span class="n">alias_native</span> <span class="ss">:weapon_name</span><span class="p">,</span> <span class="ss">:getWeaponName</span>
  <span class="n">alias_native</span> <span class="ss">:armor_name</span><span class="p">,</span> <span class="ss">:getArmorName</span>
<span class="k">end</span>
</code></pre></div></div>

<h1 id="writing-the-code-of-the-bot">Writing the code of the bot</h1>

<p>It’s not as difficult once we have all these classes prepared. The algorithm of  farming is like:</p>
<ol>
  <li>Find a closest mob and kill it</li>
  <li>Find a closest weapon (and pick up if it’s enough close)</li>
  <li>Find a closest armor (and pick up if it’s enough close)</li>
  <li>Find a closest healing (and pick up if it’s enough close)</li>
  <li>GOTO 1</li>
</ol>

<p>All of these steps will be our methods, and all of them <strong>must</strong> be asynchronous.</p>

<p>Just one method is missing here (<code class="language-plaintext highlighter-rouge">closest</code>):</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EntityCollection</span>
  <span class="k">def</span> <span class="nf">by_distance</span>
    <span class="n">entities</span> <span class="o">=</span> <span class="vi">@entities</span><span class="p">.</span><span class="nf">sort_by</span> <span class="k">do</span> <span class="o">|</span><span class="n">entity</span><span class="o">|</span>
      <span class="no">Player</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">distance_to</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="no">EntityCollection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">first</span>
    <span class="vi">@entities</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">last</span>
    <span class="vi">@entities</span><span class="p">.</span><span class="nf">last</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">closest</span>
    <span class="n">by_distance</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="killing-a-mob">Killing a mob</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kill_mob</span>
  <span class="n">closest_mob</span> <span class="o">=</span> <span class="no">Game</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">entities</span><span class="p">.</span><span class="nf">mobs</span><span class="p">.</span><span class="nf">closest</span>
  <span class="sb">`</span><span class="si">#{</span><span class="no">Game</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">to_n</span><span class="si">}</span><span class="sb">.makePlayerAttack(</span><span class="si">#{</span><span class="n">closest_mob</span><span class="p">.</span><span class="nf">to_n</span><span class="si">}</span><span class="sb">)`</span>
  <span class="c1"># TODO: move this method to the game class</span>
  <span class="c1"># using alias_native :)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="picking-up-an-abstract-item">Picking up an abstract item</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pick_up</span>
  <span class="sb">`</span><span class="si">#{</span><span class="no">Game</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">to_n</span><span class="si">}</span><span class="sb">.makePlayerGoToItem(</span><span class="si">#{</span><span class="n">item</span><span class="p">.</span><span class="nf">to_n</span><span class="si">}</span><span class="sb">);`</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="picking-up-a-weapon">Picking up a weapon</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_armor</span>
  <span class="n">current_weapon_name</span> <span class="o">=</span> <span class="no">Player</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">weapon_name</span>
  <span class="n">weapons</span> <span class="o">=</span> <span class="no">Game</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">entities</span><span class="p">.</span><span class="nf">weapons</span>
  <span class="n">closest_weapon</span> <span class="o">=</span> <span class="n">weapons</span><span class="p">.</span><span class="nf">better_than</span><span class="p">(</span><span class="n">current_weapon_name</span><span class="p">).</span><span class="nf">closest</span>
  <span class="k">if</span> <span class="n">closest_weapon</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="c1"># No weapon, probably next time</span>
    <span class="k">return</span>
  <span class="k">end</span>
  <span class="k">if</span> <span class="no">Player</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">distance_to</span><span class="p">(</span><span class="n">closest_weapon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span>
    <span class="c1"># Weapon is too far away, next time</span>
    <span class="k">return</span>
  <span class="k">end</span>
  <span class="n">pick_up</span><span class="p">(</span><span class="n">closest_weapon</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="picking-up-an-armor">Picking up an armor</h2>

<p>Just like a previous snippet, but with <code class="language-plaintext highlighter-rouge">armors</code> instead of <code class="language-plaintext highlighter-rouge">weapons</code></p>

<h2 id="whats-missing">What’s missing?</h2>

<p>All of these steps should return promises, every single method written below should wait for player to stop moving and attacking. To make this we need some common method like:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wait_until_inactive</span>
  <span class="n">promise</span> <span class="o">=</span> <span class="no">Promise</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">wait_for</span> <span class="k">do</span>
    <span class="o">!</span><span class="no">Player</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">moving?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="no">Player</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">attacking?</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
    <span class="c1"># Wait 1 more second to continue</span>
    <span class="n">after</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">promise</span><span class="p">.</span><span class="nf">resolve</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">promise</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And put it to the end of each action method.</p>

<h1 id="wrapping-a-wrapper">Wrapping a wrapper</h1>

<p>We need the main method <code class="language-plaintext highlighter-rouge">farm</code>, right?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">farm</span>
  <span class="n">kill_mob</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
    <span class="n">get_weapon</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
      <span class="n">get_armor</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
        <span class="n">heal</span><span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
          <span class="n">farm</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This, is probably the thing that I’ve personally learned during writing this article. Even if you think in Ruby, you still have to deal with asynchronous components like callbacks/promises. When you need to make an HTTP request in Ruby, you just get you favorite HTTP adapter (mine is <code class="language-plaintext highlighter-rouge">RestClient</code>), send a request and your interpreter waits for response. In JS you have to process response in some callback, because you can’t just stop your interpreter (you know, it blocks UI).</p>

<h1 id="conclusion">Conclusion</h1>

<p>As for me, the main thing Opal gives to you is some ability to think in terms of Ruby classes/modules/inheritance system. But it doesn’t let you completely escape from JS ecosystem (no callbacks? - block is a callback). I would say, most of Opal functionality related to Ruby classes can be replaced with, for example, <a href="http://jsclass.jcoglan.com/">JsClass</a> library (which is really wonderful). Opal allows you to compile <strong>existing</strong> Ruby libraries to JavaScript and use them on the client - this is probably the main feature. Some day significant amount of Ruby libraries will be ported to client-side and probably some day we will think in terms of Ruby even on the client.</p>]]></content><author><name></name></author><category term="ruby" /><category term="opal" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Capybara and asynchronous stuff</title><link href="https://iliabylich.github.io/2015/06/30/capybara-and-asynchronous-stuff.html" rel="alternate" type="text/html" title="Capybara and asynchronous stuff" /><published>2015-06-30T21:00:00+00:00</published><updated>2015-06-30T21:00:00+00:00</updated><id>https://iliabylich.github.io/2015/06/30/capybara-and-asynchronous-stuff</id><content type="html" xml:base="https://iliabylich.github.io/2015/06/30/capybara-and-asynchronous-stuff.html"><![CDATA[<p>In this entry I will try to cover the following aspects:</p>
<ol>
  <li>Running asynchronous code in a web driver</li>
  <li>Making the call synchronous</li>
  <li>Wrapping it into some common solution</li>
  <li>Advanced example - working with IndexedDB from Capybara</li>
</ol>

<h1 id="what-is-capybara-poltergeist-and-phantomjs">What is Capybara, Poltergeist and PhantomJS?</h1>

<h2 id="phantomjs">PhantomJS</h2>
<p>First of all, we need to know what is PhantomJS. I would say it’s a ‘tool that acts like a browser but can be controlled from outside using simple command interface’. In more common words, it’s a web driver. It’s a full-featured WebKit (an engine of Chrome/Safari/few last versions of Opera and other browsers), but in console. You can use it for scripting, automating or testing.</p>

<h2 id="poltergeist">Poltergeist</h2>
<p>Poltergeist is a Ruby wrapper for PhantomJS. Usually you write the code for PhantomJS on JavaScript, with Poltergeist you can run it on Ruby.</p>

<h2 id="capybara">Capybara</h2>
<p>Well, I’m pretty sure you know what it is. It’s a test framework. And it supports different web drivers like:</p>

<p><strong>RackTest</strong>  - web driver that doesn’t support javascript, extremely fast, but deadly primitive; best solution for tests that don’t require any JS execution</p>

<p><strong>Selenium</strong>  - the most popular web driver</p>

<p>Advantages:</p>
<ol>
  <li>Supports a lot of browsers (so you can run multiple test suites in different browsers)</li>
  <li>Super stable</li>
</ol>

<p>Disadvantages:</p>
<ol>
  <li>Requires X server to be installed on the machine that runs it (some cloud CI services just don’t have it)</li>
  <li>Opens a real browser that executes your test scenario, that slows your test suite.</li>
</ol>

<p><strong>Capybara-webkit</strong> - headless WebKit (doesn’t run a browser), but still requires X server</p>

<p><strong>Poltergeist</strong> - see above, headless WebKit, <strong>doesn’t require X server</strong>, so you can run it everywhere.</p>

<h1 id="asynchronous-javascript-code-in-your-tests">Asynchronous JavaScript code in your tests</h1>

<p>When you write integration tests sometimes you need to run asynchronous JavaScript in context of your page and get a response back to Ruby. Here is an example from my current project: the client part of our application supports offline mode, so we store the data in WebSQL and sync it with server once connection is restored. The API of WebSQL is asynchronous, so we have a result of execution in some provided callback:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// something like</span>
<span class="nx">WebSQLWrapper</span><span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="dl">'</span><span class="s1">select 1</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// result of execution becomes available after some time</span>
<span class="p">});</span>
</code></pre></div></div>

<p>We have integration tests with Capybara+Poltergeist+PhantomJS combo that tests the whole stack of interaction between a client-side application and a server API. And WebSQL should be flushed between tests or populated with startup data before some specific tests. We also have delayed operations on the client that runs periodically.</p>

<p>All these features require us to run JavaScript code manually in PhantomJS between/before tests.</p>

<h1 id="capybarapoltergeistphantomjs-installation">Capybara/Poltergeist/PhantomJS installation</h1>

<p>Quite simple:</p>
<ol>
  <li>PhantomJS: <code class="language-plaintext highlighter-rouge">sudo apt-get install phantomjs</code> or download binaries from the official site (you can even try 2.0 beta there).</li>
  <li>Capybara: <code class="language-plaintext highlighter-rouge">gem 'capybara'</code> and that’s it.</li>
  <li>Poltergeist: <code class="language-plaintext highlighter-rouge">gem 'poltergeist'</code>.</li>
</ol>

<p>Require both of them in your <code class="language-plaintext highlighter-rouge">spec_helper</code> and force Capybara to use Poltergeist as a web driver:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'capybara/rails'</span>
<span class="nb">require</span> <span class="s1">'capybara/poltergeist'</span>

<span class="no">Capybara</span><span class="p">.</span><span class="nf">register_driver</span> <span class="ss">:poltergeist_debug</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
  <span class="n">driver_options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">inspector: </span><span class="kp">true</span><span class="p">,</span>
    <span class="ss">timeout: </span><span class="mi">5</span><span class="p">,</span>
    <span class="ss">js_errors: </span><span class="kp">false</span><span class="p">,</span>
    <span class="ss">debug: </span><span class="kp">false</span><span class="p">,</span>
    <span class="ss">phantomjs_logger: </span><span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'/dev/null'</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'DEBUG_PHANTOMJS'</span><span class="p">]</span>
    <span class="n">driver_options</span><span class="p">.</span><span class="nf">merge!</span><span class="p">({</span>
      <span class="ss">logger: </span><span class="no">Kernel</span><span class="p">,</span>
      <span class="ss">js_errors: </span><span class="kp">true</span><span class="p">,</span>
      <span class="ss">debug: </span><span class="kp">true</span><span class="p">,</span>
      <span class="ss">phantomjs_logger: </span><span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'log/phantomjs.log'</span><span class="p">),</span> <span class="s1">'a'</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="k">end</span>
  <span class="no">Capybara</span><span class="o">::</span><span class="no">Poltergeist</span><span class="o">::</span><span class="no">Driver</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">driver_options</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">Capybara</span><span class="p">.</span><span class="nf">javascript_driver</span> <span class="o">=</span> <span class="ss">:poltergeist_debug</span>
<span class="no">Capybara</span><span class="p">.</span><span class="nf">default_driver</span> <span class="o">=</span> <span class="ss">:poltergeist_debug</span>
</code></pre></div></div>

<p>With this configuration Poltergeist doesn’t print any noisy output, but you can enable it by passing <code class="language-plaintext highlighter-rouge">DEBUG_PHANTOMJS=true</code></p>

<h1 id="small-example">Small example</h1>

<p>Here is a simple of the code that returns it’s response asynchronously:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Thanks for waiting 1 second</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>
<p>This code actually does nothing, but it’s a demonstration of how asynchronous stuff works.</p>

<h1 id="but-capybara-waits-for-my-ajax-requests">But… Capybara waits for my AJAX requests</h1>

<p>Yes, when you write something like:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">it</span> <span class="s1">'displays a message'</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_text</span><span class="p">(</span><span class="s1">'Hey'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>
<p>and at the moment of running this expectation your page doesn’t have this text <strong>but receives it a second later</strong> - the test will be green. Why?</p>

<p>Capybara has a setting called <code class="language-plaintext highlighter-rouge">default_wait_time</code> (was changed to <code class="language-plaintext highlighter-rouge">default_max_wait_time</code>, but is still acceptable) which is 2 seconds by default. <a href="https://github.com/jnicklas/capybara/blob/master/lib/capybara/node/base.rb#L76">Here is how Capybara uses it</a>.</p>

<p>It runs the code again and again, and stops if</p>
<ol>
  <li>It has a result of code execution - then it simple returns it</li>
  <li>The time has come (2 seconds) - then it raises an error</li>
</ol>

<p>(A little remark here. Capybara saves the time on the beginning of this method and on every iteration compares this time with <code class="language-plaintext highlighter-rouge">Time.now</code> - this is a very nice hack to save Capybara from wrapping API calls into <code class="language-plaintext highlighter-rouge">Timecop.freeze</code> - good job!)</p>

<h1 id="can-we-reuse-it">Can we reuse it?</h1>

<p>Yes, of course. Let’s simplify it a little bit:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">WaitHelper</span>
  <span class="kp">extend</span> <span class="nb">self</span>

  <span class="c1"># Calls provided +block+ every 100ms</span>
  <span class="c1">#   and stops when it returns false</span>
  <span class="c1">#</span>
  <span class="c1"># @param timeout [Fixnum]</span>
  <span class="c1"># @yield block for execution</span>
  <span class="c1">#</span>
  <span class="c1"># @example</span>
  <span class="c1">#   current_time = Time.now</span>
  <span class="c1">#   WaitHelper.wait_until(3) do</span>
  <span class="c1">#     Time.now - current_time &gt; 2</span>
  <span class="c1">#   end</span>
  <span class="c1">#</span>
  <span class="c1">#   # 2 seconds later ...</span>
  <span class="c1">#   # =&gt; true</span>
  <span class="c1">#</span>
  <span class="c1">#   current_time = Time.now</span>
  <span class="c1">#   WaitHelper.wait_until(3) do</span>
  <span class="c1">#     Time.now - current_time &gt; 10</span>
  <span class="c1">#   end</span>
  <span class="c1">#</span>
  <span class="c1">#   # 3 seconds later (after timeout)</span>
  <span class="c1">#   # =&gt; false</span>
  <span class="c1">#</span>
  <span class="k">def</span> <span class="nf">wait_until</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">begin</span>
      <span class="no">Timeout</span><span class="p">.</span><span class="nf">timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="k">do</span>
        <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="k">until</span> <span class="n">value</span> <span class="o">=</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span>
        <span class="n">value</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">TimeoutError</span>
      <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Alright, now let’s use it.</p>
<ol>
  <li>Modify JS code to set result into some global variable (JS function context, you know)</li>
  <li>Run the code that gets response in callback.</li>
  <li>Run the code that polls the response from global varialbe</li>
  <li>Wrap this code with <code class="language-plaintext highlighter-rouge">WaitHelper.wait_until(timeout) {}</code></li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">code_for_execution</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">JS</span><span class="sh">
  setTimeout(function() {
    window.asyncResponse = 'some response';
  }, 1000)
</span><span class="no">JS</span>

<span class="n">code_for_polling</span> <span class="o">=</span> <span class="s1">'window.asyncResponse'</span>

<span class="no">Capybara</span><span class="p">.</span><span class="nf">current_session</span><span class="p">.</span><span class="nf">evaluate_script</span><span class="p">(</span><span class="n">code_for_execution</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="no">WaitHelper</span><span class="p">.</span><span class="nf">wait_until</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">Capybara</span><span class="p">.</span><span class="nf">current_session</span><span class="p">.</span><span class="nf">evaluate_script</span><span class="p">(</span><span class="n">code_for_polling</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="n">result</span>
<span class="c1"># =&gt; 'some response'</span>
</code></pre></div></div>

<h1 id="can-we-organize-it-as-a-common-reusable-solution">Can we organize it as a common reusable solution?</h1>

<p>Why not. Here is a gem called <a href="https://github.com/iliabylich/capybara-async-runner">capybara-async-runner</a>. And here is how to use it.</p>

<p>Installation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Gemfile</span>
<span class="n">gem</span> <span class="s1">'capybara-async_runner'</span>
<span class="c1"># spec/spec_helper.rb</span>
<span class="nb">require</span> <span class="s1">'capybara/async_runner'</span>
</code></pre></div></div>

<p>First of all, I don’t like to mix JS and Ruby code in a single file, so we need templates (like <code class="language-plaintext highlighter-rouge">.js.erb</code>). You need to specify the directory with templates:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># spec/spec_helper.rb</span>
<span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">setup</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">commands_directory</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'spec/fixtures/async_commands'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s write our first command</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestCommand</span> <span class="o">&lt;</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="o">::</span><span class="no">Command</span>
  <span class="c1"># global command name</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">command_name</span> <span class="o">=</span> <span class="ss">:test_command_name</span>

  <span class="c1"># .js.erb file in directory specified above</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">file_to_run</span> <span class="o">=</span> <span class="s1">'template'</span>

  <span class="n">response</span> <span class="ss">:parsed_json</span> <span class="k">do</span> <span class="o">|</span><span class="n">data</span><span class="o">|</span>
    <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This class follows the Command pattern, you can invoke it in the following way:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">:test_command_name</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="no">TestCommand</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">invoke</span>
</code></pre></div></div>

<p>Let’s create our template for this command:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// spec/fixtures/async_commands/template.js.erb</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>
  <span class="o">&lt;%=</span> <span class="nx">parsed_json</span><span class="p">(</span><span class="nx">js</span><span class="p">[:</span><span class="nx">json</span><span class="p">])</span> <span class="o">%&gt;</span>
<span class="p">})</span>
</code></pre></div></div>

<p>There are few things that I need to explain:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">parsed_json</code> - this is an output point from the script that was defined in the command class. When you call it in the template, it embeds some JavaScript that stores passed data into the global variable. <code class="language-plaintext highlighter-rouge">parsed_json(123)</code> produces something like <code class="language-plaintext highlighter-rouge">window.parsed_json_result = 123</code> (so we can can grab this response later from the second script)</li>
  <li><code class="language-plaintext highlighter-rouge">js</code> - this is a proxy method from the gem that acts like a Hash. The method <code class="language-plaintext highlighter-rouge">[]</code> on this Hash returns passed key (and the whole method <code class="language-plaintext highlighter-rouge">js</code> is kind of “JavaScript memory”). <code class="language-plaintext highlighter-rouge">&lt;%= parsed_json(js[:json]) %&gt;</code> produces <code class="language-plaintext highlighter-rouge">window.parsed_json_result = json</code> which is exactly what we need.</li>
  <li>When you call <code class="language-plaintext highlighter-rouge">Capybara::AsyncRunner.run(:test_command_name)</code>, the gem executes the script generated from your template in the context of <code class="language-plaintext highlighter-rouge">Capybara.current_session</code>. Then it subscribes to all defined responses (this is actually, the second script) and returns the first one that becomes defined (<code class="language-plaintext highlighter-rouge">window.parsed_json_result</code> in this case).</li>
  <li>The block that we’ve specified for <code class="language-plaintext highlighter-rouge">parsed_json</code> is like a handler for transforming data which it returns (we invoke <code class="language-plaintext highlighter-rouge">parsed_json</code> method with <code class="language-plaintext highlighter-rouge">json</code> variable which contains raw JSON, our handler parses it)</li>
</ol>

<p>If you are familiar with templates in Ruby, just quickly look at the <a href="https://github.com/iliabylich/capybara-async-runner/blob/master/lib/capybara/async_runner/env.rb">code</a>, this class is a context of rendering.</p>

<h1 id="wrapping-up">Wrapping up</h1>

<p>You need to follow these steps to create a command using a gem:</p>
<ol>
  <li>Specify the directory with templates in the gem config</li>
  <li>Create a command class</li>
  <li>Specify its name</li>
  <li>Specify the name of template</li>
  <li>Create a template file</li>
  <li>Define a response(s)</li>
  <li>Call them in the template</li>
</ol>

<h1 id="passing-data-to-template">Passing data to template</h1>

<p>You can pass any data to the template:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestCommand</span> <span class="o">&lt;</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="o">::</span><span class="no">Command</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">command_name</span> <span class="o">=</span> <span class="ss">:test</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">template</span> <span class="o">=</span> <span class="s1">'template'</span>
  <span class="c1"># if you don't pass any block</span>
  <span class="c1"># it will return raw value</span>
  <span class="n">response</span> <span class="ss">:done</span>
<span class="k">end</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">name: </span><span class="s1">'Ilya'</span>
<span class="p">}</span>
<span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">:test</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="c1"># =&gt; 'Ilya'</span>
</code></pre></div></div>

<p>And use it template:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">someLongRunningMethod</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 'done' is a method that generates JavaScript</span>
  <span class="c1">// 'data' returns data that we've passed to 'run'</span>
  <span class="c1">// :name is a key in that Hash</span>
  <span class="o">&lt;%=</span> <span class="nx">done</span><span class="p">(</span><span class="nx">data</span><span class="p">[:</span><span class="nx">name</span><span class="p">])</span> <span class="o">%&gt;</span>
<span class="p">})</span>
</code></pre></div></div>

<h1 id="lets-write-something-complex">Let’s write something complex</h1>

<p>As I mentioned before, on my current project we use WebSQL, but it’s <a href="http://www.w3.org/TR/webdatabase/">deprecated</a>, so I’m not going to use it in examples. Instead let’s write a wrapper for IndexedDB.</p>

<p>First of all, we need a JavaScript wrapper, I don’t like the native IndexedDB API. First result from google = <a href="http://www.dexie.org/">Dexie.js</a>.</p>

<p>Let’s plan our scenario:</p>
<ol>
  <li>Visit any page</li>
  <li>Inject Dexie.js into the page</li>
  <li>Create IndexedDB instance</li>
  <li>Write some data to the database</li>
  <li>Read them and print</li>
</ol>

<h2 id="visiting-the-page">Visiting the page</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Capybara</span><span class="p">.</span><span class="nf">current_session</span><span class="p">.</span><span class="nf">visit</span><span class="p">(</span><span class="s1">'http://google.com'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="injecting-dexiejs-into-the-page">Injecting Dexie.js into the page</h2>

<ul>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/commands/wrapper_loader.rb">Command</a></li>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/templates/wrapper/inject.js.erb">Template</a></li>
</ul>

<p>How to invoke:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">IndexedDB</span>
  <span class="no">URL</span> <span class="o">=</span> <span class="s1">'http://www.url.to.dexie.js.source'</span>
<span class="k">end</span>

<span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="s1">'indexeddb:wrapper:inject'</span><span class="p">,</span> <span class="ss">url: </span><span class="no">IndexedDB</span><span class="o">::</span><span class="no">URL</span><span class="p">)</span>
</code></pre></div></div>

<p>Explanation:</p>
<ol>
  <li>JS code detects whether the library has already been loaded</li>
  <li>If not - appends <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> tag to the <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code></li>
  <li>If yes - returns ‘success’</li>
  <li>If 3 seconds passed and we still have no library code - returns ‘error’</li>
</ol>

<p>The command raises an exception if response is <code class="language-plaintext highlighter-rouge">error</code>.</p>

<p>All this manipulations are synchronous for Ruby. The end of running the command means that we can continue execution.</p>

<p>Moreover, this command is safe, we can call it multiple times and it will inject the script into the page only once.</p>

<h2 id="create-indexeddb-instance">Create IndexedDB instance</h2>

<ul>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/commands/wrapper_initializer.rb">Command</a></li>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/templates/wrapper/initialize.js.erb">Template</a></li>
</ul>

<p>How to invoke:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="s1">'indexeddb:wrapper:initialize'</span><span class="p">)</span>
</code></pre></div></div>

<p>Explanation:</p>
<ol>
  <li>JS opens the database using Dexie.js</li>
  <li>If callback was called, returns <code class="language-plaintext highlighter-rouge">sucess</code></li>
  <li>If errback was called, returns <code class="language-plaintext highlighter-rouge">error</code> with error message</li>
  <li>Ruby command raises error if <code class="language-plaintext highlighter-rouge">error</code> was returned</li>
</ol>

<h2 id="write-some-data-to-the-database">Write some data to the database</h2>

<ul>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/commands/insert.rb">Command</a></li>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/templates/commands/insert.js.erb">Template</a></li>
</ul>

<p>How to invoke:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user_data</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">name: </span><span class="s1">'Some Name'</span> <span class="p">}</span>

<span class="n">user_id</span> <span class="o">=</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="s1">'indexeddb:insert'</span><span class="p">,</span> <span class="ss">store: </span><span class="s1">'users'</span><span class="p">,</span> <span class="ss">data: </span><span class="n">user_data</span><span class="p">)</span>
<span class="nb">p</span> <span class="s2">"User ID: </span><span class="si">#{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>This step is quite simple if you understand the previous one.</p>

<h2 id="reading-data">Reading data</h2>

<ul>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/commands/query.rb">Command</a></li>
  <li><a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/templates/commands/query.js.erb">Template</a></li>
</ul>

<p>How to invoke:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">methods</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="ss">method: </span><span class="s1">'where'</span><span class="p">,</span> <span class="ss">arguments: </span><span class="p">[</span><span class="s1">'id'</span><span class="p">]},</span>
  <span class="p">{</span> <span class="ss">method: </span><span class="s1">'equals'</span><span class="p">,</span> <span class="ss">arguments: </span><span class="p">[</span><span class="n">user_id</span><span class="p">]</span> <span class="p">},</span>
  <span class="p">{</span> <span class="ss">method: </span><span class="s1">'toArray'</span><span class="p">,</span> <span class="ss">arguments: </span><span class="p">[]</span> <span class="p">}</span>
<span class="p">]</span>

<span class="nb">p</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">AsyncRunner</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="s1">'indexeddb:query'</span><span class="p">,</span> <span class="ss">store: </span><span class="s1">'users'</span><span class="p">,</span> <span class="ss">methods: </span><span class="nb">methods</span><span class="p">)</span>
</code></pre></div></div>

<p>Here we pass an array of methods and their arguments to template, iterate over them and build a dexie scope (just like <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code>), and return a result back to ruby command.</p>

<p>After wrapping it even more we can get interface like <a href="https://github.com/iliabylich/capybara-async-runner/blob/master/examples/indexeddb/indexdb.rb#L133">this</a></p>

<p>Full example can be found <a href="https://github.com/iliabylich/capybara-async-runner/tree/master/examples/indexeddb">here</a></p>

<h1 id="conclusion">Conclusion</h1>

<p>I would say the topic of this article is not so popular. Single page applications that work in offline mode (and because of this, use WebSQL/IndexedDB/some other async storage, probably) are still not frequent today. Usually when you build an SPA, you just write your tests using Jasmine or something like that. You mock your requests to the server API and test your client in some isolated environment. But these tests are still functional (you verify a single component - client, in this case - but not the whole application).</p>

<p>Someday working on a rich client-side application, remember about the idea of this post. You can control the logical flow of your client-server communication in integration tests, and this is good. Wrap your client code, build a micro-framework on top of this gem and test every piece of your code.</p>]]></content><author><name></name></author><category term="ruby" /><category term="capybara" /><category term="webdriver" /><summary type="html"><![CDATA[In this entry I will try to cover the following aspects: Running asynchronous code in a web driver Making the call synchronous Wrapping it into some common solution Advanced example - working with IndexedDB from Capybara]]></summary></entry><entry><title type="html">Apipie - amazing tool for documenting your Rails API</title><link href="https://iliabylich.github.io/2015/06/07/apipie-amazing-tool-for-documenting-your-rails-api.html" rel="alternate" type="text/html" title="Apipie - amazing tool for documenting your Rails API" /><published>2015-06-07T21:00:00+00:00</published><updated>2015-06-07T21:00:00+00:00</updated><id>https://iliabylich.github.io/2015/06/07/apipie-amazing-tool-for-documenting-your-rails-api</id><content type="html" xml:base="https://iliabylich.github.io/2015/06/07/apipie-amazing-tool-for-documenting-your-rails-api.html"><![CDATA[<p>This article is about <a href="https://github.com/Apipie/apipie-rails">Apipie gem</a> which provides a DSL for documenting your API. I will try to cover features that I personally use on my project.</p>

<p>Comparing to other tools for generating API documentation (yardoc, sdoc) I would say that the main thing that you gain with Apipie is that your documentation is a real ruby code, so you can write computations, concerns etc.</p>

<p>Here is a simple example of how it looks in code:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="n">resource_description</span> <span class="k">do</span>
    <span class="n">formats</span> <span class="p">[</span><span class="ss">:json</span><span class="p">]</span>
    <span class="n">api_versions</span> <span class="s1">'public'</span>
  <span class="k">end</span>

  <span class="n">api</span> <span class="ss">:POST</span><span class="p">,</span> <span class="s1">'/users'</span> <span class="s1">'Create user'</span>
  <span class="n">description</span> <span class="s1">'Create user with specifed user params'</span>
  <span class="n">param</span> <span class="ss">:user</span><span class="p">,</span> <span class="no">Hash</span><span class="p">,</span> <span class="ss">desc: </span><span class="s1">'User information'</span> <span class="k">do</span>
    <span class="n">param</span> <span class="ss">:full_name</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">desc: </span><span class="s1">'Full name of the user'</span>
    <span class="n">param</span> <span class="ss">:age</span><span class="p">,</span> <span class="no">Fixnum</span><span class="p">,</span> <span class="ss">desc: </span><span class="s1">'Age of the user'</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">create</span>
    <span class="c1"># Some application code</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So, you invoke a DSL from Apipie before your action method and it automatically comes to generated docs.</p>

<h1 id="features">Features</h1>

<h2 id="gathering-information-from-your-routes">Gathering information from your routes</h2>

<p>In the example above we’ve passed an http verb and a path of this action. We don’t have to do it! Instead, we can simply write:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">api!</span> <span class="s1">'Some description'</span>
<span class="c1"># other docs here...</span>
<span class="k">def</span> <span class="nf">create</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It automatically takes information from your routes that look like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resources</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">only: </span><span class="p">[</span><span class="ss">:create</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="api-versioning">API versioning</h2>

<p>You can pass versions of your API that include this endpoint on</p>
<ol>
  <li>resource level (as in example)</li>
  <li>action level (in pretty much the same way, <code class="language-plaintext highlighter-rouge">api_versions ...</code></li>
</ol>

<h2 id="parameters-typing">Parameters typing</h2>

<p>As you can see, in the first example we had 3 types:</p>
<ol>
  <li>Hash</li>
  <li>Array</li>
  <li>Fixnum</li>
</ol>

<p>Apipie has also:</p>
<ol>
  <li>Enum</li>
  <li>Regexp</li>
</ol>

<h2 id="parameters-validation">Parameters validation</h2>

<p>We have already typed parameters, so why do we ignore it and write custom <code class="language-plaintext highlighter-rouge">before_action</code>-s for validating parameters manually? This feature is enabled by default, but if you don’t think that it’s a good idea to validate your parameters through documenting tool, just pass</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">validate</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div></div>

<p>The creator of the gem told me that ‘People either love it or don’t understand why it’s even there’, so it’s up to you to decide if you need it.</p>

<h2 id="concerns">Concerns</h2>

<p>I would say that it doesn’t work as people usually expect.</p>

<p><code class="language-plaintext highlighter-rouge">Apipie::DSL::Concern</code> allows you to document actions that are defined in concerns.</p>

<p><a href="https://github.com/Apipie/apipie-rails#concerns">A quick example</a></p>

<p>Usually people think that it allows you to extract documentation from your controller in order to not mix code with documentation and application logic. And, to be honest, I think so too. The workaround for doing this goes below in the sections ‘Extracting docs to mixins’</p>

<h2 id="specs-recording">Specs recording</h2>

<p>Are you tired of writing examples manually? Me too :) With Apipie you can record request/response pairs to separated yaml file and display them in generated html. Pass <code class="language-plaintext highlighter-rouge">:show_in_doc</code> to metadata of your RSpec example and enjoy. Apipie embeds a module for recording requests to `    ActionController::TestCase::Behavior<code class="language-plaintext highlighter-rouge"> which is the core of all requests specs for RSpec and Minitest (yes, both of them delegate performing requests internally to </code>    ActionController::TestCase::Behavior` - <a href="https://github.com/rspec/rspec-rails/blob/master/lib/rspec/rails/example/controller_example_group.rb#L12">source</a>).</p>

<h2 id="other-features">Other features</h2>
<p>There is a plenty of other things in Apipie that are very cool, by I didn’t have a chance to use it yet.</p>

<ol>
  <li>Localization. Currently it supports English, Russian, Chinese and Brazilian. If you want to add support for your language, use this as an example - <a href="https://github.com/Apipie/apipie-rails/blob/master/config/locales/en.yml">source</a></li>
  <li>Disqus integration. This is extremely useful when you have a decentralized team. If you have any questions - just leave a comment and wait for response! No need to define any models for storing users/comments/relations, everything is in the cloud.</li>
  <li>Custom markup processors. Not sure that anyone can need it, default markup processor looks very stable.</li>
</ol>

<h1 id="customization">Customization</h1>

<p>Some of these items can be difficult to explain, if you have any questions after reading it, just google it, answers for all of them should be in ruby docs (or ping me if you still don’t get it).</p>

<h2 id="extracting-docs-to-mixins">Extracting docs to mixins</h2>

<p>This is the main question I’ve got after reading official readme. I don’t want to mix documentation and application logic. First of all we need to understand how exactly Apipie builds mapping between action names and compiled DSL. Even without reading source code the only guess that we may have is <code class="language-plaintext highlighter-rouge">method_added</code> hook. Every time when you define a method (on instance or on class, it doesn’t matter), Ruby automatically fires <code class="language-plaintext highlighter-rouge">method_added</code> method on your class.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestClass</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">method_added</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"Added method </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method1</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">method2</span><span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># =&gt; Added method method1</span>
<span class="c1"># =&gt; Added method method2</span>
</code></pre></div></div>

<p>So, the algorithm is like this:</p>
<ol>
  <li>You invoke method <code class="language-plaintext highlighter-rouge">api</code> (or <code class="language-plaintext highlighter-rouge">api!</code>)</li>
  <li>Apipie internally saves action name (let’s say, as <code class="language-plaintext highlighter-rouge">Apipie.current_action_name</code>) and arguments (in <code class="language-plaintext highlighter-rouge">Apipie.current_action_data</code>, for example)</li>
  <li>You invoke other DSL methods</li>
  <li>Apipie appends this data to <code class="language-plaintext highlighter-rouge">Apipie.current_action_data</code></li>
  <li>You define a method (action in our case)</li>
  <li>Apipie adds mapping <code class="language-plaintext highlighter-rouge">Apipie.current_action_name =&gt; Apipie.current_action_data</code> to a global Hash like <code class="language-plaintext highlighter-rouge">Apipie.all_docs</code></li>
  <li>When you visit <code class="language-plaintext highlighter-rouge">/docs</code>, Apipie displays all data from <code class="language-plaintext highlighter-rouge">Apipie.all_docs</code></li>
</ol>

<p>And if it’s true we can write something like:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/docs/users_doc.rb</span>
<span class="k">module</span> <span class="nn">UsersDoc</span>
  <span class="c1"># we need the DSL, right?</span>
  <span class="kp">extend</span> <span class="no">Apipie</span><span class="o">::</span><span class="no">DSL</span><span class="o">::</span><span class="no">Concern</span>

  <span class="n">api</span> <span class="ss">:GET</span><span class="p">,</span> <span class="s1">'/users'</span><span class="p">,</span> <span class="s1">'List users'</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="c1"># Nothing here, it's just a stub</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/controller/users_controller.rb</span>
<span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="kp">include</span> <span class="no">UsersDoc</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="c1"># Application code goes here</span>
    <span class="c1"># and it overrides blank method</span>
    <span class="c1"># from the module</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And yes, it works! Let’s add resource description</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">UsersDoc</span>
  <span class="kp">extend</span> <span class="no">Apipie</span><span class="o">::</span><span class="no">DSL</span><span class="o">::</span><span class="no">Concern</span>

  <span class="n">resource_description</span> <span class="k">do</span>
    <span class="n">formats</span> <span class="p">[</span><span class="ss">:json</span><span class="p">]</span>
    <span class="n">api_versions</span> <span class="s1">'public'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Which breaks it…</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Apipie: Can not resolve resource UsersDoc name.
</code></pre></div></div>
<p>Yes, because our resource is <code class="language-plaintext highlighter-rouge">UsersController</code>. The error happens in the following lines in Apipie source code:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">get_resource_name</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class</span> <span class="o">==</span> <span class="no">String</span>
        <span class="n">klass</span>
      <span class="k">elsif</span> <span class="vi">@controller_to_resource_id</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
        <span class="vi">@controller_to_resource_id</span><span class="p">[</span><span class="n">klass</span><span class="p">]</span>
      <span class="k">elsif</span> <span class="no">Apipie</span><span class="p">.</span><span class="nf">configuration</span><span class="p">.</span><span class="nf">namespaced_resources?</span> <span class="o">&amp;&amp;</span> <span class="n">klass</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:controller_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">klass</span> <span class="o">==</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">controller_path</span>
        <span class="n">path</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="n">version_prefix</span><span class="p">(</span><span class="n">klass</span><span class="p">),</span> <span class="s2">""</span><span class="p">).</span><span class="nf">gsub</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="s2">"-"</span><span class="p">)</span>
      <span class="k">elsif</span> <span class="n">klass</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:controller_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">klass</span> <span class="o">==</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>
        <span class="n">klass</span><span class="p">.</span><span class="nf">controller_name</span>
      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">"Apipie: Can not resolve resource </span><span class="si">#{</span><span class="n">klass</span><span class="si">}</span><span class="s2"> name."</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div></div>

<p>Most of this code doesn’t really matter, the thing is that Apipie doesn’t know what to do with module <code class="language-plaintext highlighter-rouge">UsersDoc</code>. It has no <code class="language-plaintext highlighter-rouge">resource_id</code>, let’s define it.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resource_description</span> <span class="k">do</span>
  <span class="n">resource_id</span> <span class="s1">'Users'</span>
  <span class="c1"># other dsl</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we get an error</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undefined</span> <span class="nb">method</span> <span class="sb">`superclass' for UsersDoc:Module
</span></code></pre></div></div>

<p>But… Module (I mean, an instance of Module class) can’t have a superclass. It’s a module!</p>

<p>Forget that you are a ruby developer and define a method called <code class="language-plaintext highlighter-rouge">superclass</code> on your module :)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># before calling DSL</span>
<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">superclass</span>
  <span class="no">UsersController</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So, from this moment</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">UsersDoc</span><span class="p">.</span><span class="nf">superclass</span> <span class="o">==</span> <span class="no">UsersController</span>
<span class="c1"># =&gt; true</span>
</code></pre></div></div>

<p>Refresh the page with documentation and see that it finally works!
Here is a gist with a full code that wraps ugly code and blank methods:
<a href="https://gist.github.com/iliabylich/c8032b193405673062e7">full gist</a></p>

<h2 id="the-power-of-ruby-based-doc">The power of ruby-based doc</h2>

<p>Imagine the following scenario:</p>

<p>I have two versions of API. When I was young and stupid, I implemented the first one (<code class="language-plaintext highlighter-rouge">v1</code>). And it has an authentication by plain username and password (in headers). Few years later something changed in my mind and I created another one (<code class="language-plaintext highlighter-rouge">v2</code>) which has token-based authentication.</p>

<p>First API contains 100 actions in 10 controllers, so does the second one, too. To make a documentation I have to copy-paste 2 lines of code 200 times (to put it for every action) or 20 times (to put it to every resource).</p>

<p>Instead of repeated copying the real description of authentication mechanism it would be really nice to have something like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># for Api::V1</span>
<span class="n">auth_with</span> <span class="ss">:password</span>
<span class="c1"># for Api::V2</span>
<span class="n">auth_with</span> <span class="ss">:token</span>
</code></pre></div></div>

<p>And describe authentication in a more declarative way. In order to make it we need to add our own method to DSL. Here is what it may look like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">BaseDoc</span>
  <span class="c1"># ... code from the gist</span>

  <span class="no">AUTH_METHODS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">password: </span><span class="no">Api</span><span class="o">::</span><span class="no">Auth</span><span class="o">::</span><span class="no">PasswordDoc</span><span class="p">,</span>
    <span class="ss">token: </span><span class="no">Api</span><span class="o">::</span><span class="no">Auth</span><span class="o">::</span><span class="no">TokenDoc</span>
  <span class="p">}</span>

  <span class="k">def</span> <span class="nf">auth_with</span><span class="p">(</span><span class="n">auth_method</span><span class="p">)</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="no">AUTH_METHODS</span><span class="p">[</span><span class="n">auth_method</span><span class="p">]</span> <span class="n">or</span>
      <span class="k">raise</span> <span class="s2">"Unknown auth strategy </span><span class="si">#{</span><span class="n">auth_method</span><span class="si">}</span><span class="s2">"</span>
    <span class="nb">send</span><span class="p">(</span><span class="ss">:include</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/docs/api/auth/password_doc.rb</span>
<span class="k">module</span> <span class="nn">Api::Auth::PasswordDoc</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">base</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="k">do</span>
      <span class="c1"># documentation of password-</span>
      <span class="c1">#  based authentication</span>
      <span class="n">header</span> <span class="ss">:username</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span>
      <span class="n">header</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">true</span>
      <span class="n">error</span> <span class="ss">code: </span><span class="mi">401</span><span class="p">,</span> <span class="ss">desc: </span><span class="s1">'Unauthorized'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/docs/api/auth/token_doc.rb</span>
<span class="k">module</span> <span class="nn">Api::Auth::TokenDoc</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">base</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="k">do</span>
      <span class="c1"># documentation of token-</span>
      <span class="c1">#  based authentication</span>
      <span class="n">header</span> <span class="s1">'Token'</span><span class="p">,</span> <span class="s1">'Your API token'</span>
      <span class="n">error</span> <span class="ss">code: </span><span class="mi">401</span><span class="p">,</span> <span class="ss">desc: </span><span class="s1">'Token is requried'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And from now we can write</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Api::V1::UsersDoc</span>
  <span class="kp">extend</span> <span class="no">BaseDoc</span>

  <span class="n">doc_for</span> <span class="ss">:show</span> <span class="k">do</span>
    <span class="n">auth_with</span> <span class="ss">:password</span>
    <span class="c1"># or</span>
    <span class="c1"># auth_with :token</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="ability-to-define-default-documentation-for-all-actions-in-resource">Ability to define default documentation for all actions in resource</h2>

<p>So, we have a <code class="language-plaintext highlighter-rouge">resource_description</code> and <code class="language-plaintext highlighter-rouge">api</code> methods, but how can we define common parts for all of our actions? I hate copy-paste driven development, let’s write a DSL for this.</p>

<p>We want to have a <code class="language-plaintext highlighter-rouge">defaults</code> method which takes a block and executes it for each action.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">BaseDoc</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="vi">@defaults</span> <span class="o">=</span> <span class="n">block</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">doc_for</span><span class="p">(</span><span class="n">action_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="c1"># Only the next line added</span>
    <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="vi">@defaults</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@defaults</span>
    <span class="n">api_version</span> <span class="n">namespace_name</span> <span class="k">if</span> <span class="n">namespace_name</span>
    <span class="n">define_method</span><span class="p">(</span><span class="n">action_name</span><span class="p">)</span> <span class="k">do</span>
      <span class="c1"># ... define it in your controller with the real code</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So, we just store passed block and invoke it. This example is much simpler then the previous one.</p>

<h1 id="demo">Demo</h1>

<p><a href="https://github.com/iliabylich/apipie-demo">URL</a></p>

<p>You can click by statically generated docs (thanks to github pages):</p>

<ul>
  <li><a href="http://iliabylich.github.io/apipie-demo/doc/apidoc/private_v1.html">Private::V1</a></li>
  <li><a href="http://iliabylich.github.io/apipie-demo/doc/apidoc/private_v2.html">Private::V2</a></li>
  <li><a href="http://iliabylich.github.io/apipie-demo/doc/apidoc/public.html">Public</a></li>
</ul>

<h1 id="conclusion">Conclusion</h1>

<p>Apipie is an amazing library and its most significant advantage is that you document ruby using ruby (being a ruby developer), which gives you ability to define custom behaviors and scenarios. I can’t even imagine myself writing API docs using yardoc (however, I use it to document plain ruby classes).</p>

<p>If you have any bugs (or ideas to implement), please, <a href="https://github.com/Apipie/apipie-rails/issues">create an issue on GitHub</a>, let’s make it even better!</p>]]></content><author><name></name></author><category term="ruby" /><category term="apipie" /><category term="documenting" /><category term="API" /><summary type="html"><![CDATA[This article is about Apipie gem which provides a DSL for documenting your API. I will try to cover features that I personally use on my project.]]></summary></entry></feed>