<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon-precomposed sizes=192x192 href=/icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Saving execution context for later debugging"><title>Saving execution context for later debugging | Ilya Bylich - Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.c8a2df3058ea59fb74948f071267ef16e3a4d0b23b7ec84883692939ef5dea45.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/>Home</a></li><li><a tabindex=-1 class=menu-link href=https://github.com/iliabylich>GitHub</a></li><li><a tabindex=-1 class=menu-link href=https://twitter.com/IlyaBylich>Twitter</a></li><li><a tabindex=-1 class=menu-link href=mailto:ibylich@gmail.com>Email me</a></li><li><a tabindex=-1 class=menu-link href=/index.xml>RSS</a></li></ul></nav><div id=single-header><h1>Saving execution context for later debugging</h1><div id=single-meta><span class=datesub>Aug 21, 2015</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://iliabylich.github.io/tags/ruby/>#ruby</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/binding/>#binding</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/closure/>#closure</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/debugging/>#debugging</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#the-problem>The problem</a></li><li><a href=#binding>Binding</a></li><li><a href=#marshaling>Marshaling</a></li><li><a href=#limitations>Limitations</a></li><li><a href=#converting-objects-to-marshalable-data>Converting objects to marshalable data</a></li><li><a href=#dumping-magical-objects>Dumping Magical objects</a></li><li><a href=#dumping-recurring-objects>Dumping recurring objects</a></li><li><a href=#restoring-a-binding>Restoring a binding</a></li><li><a href=#compatibility-with-old-versions-of-ruby>Compatibility with old versions of Ruby</a></li><li><a href=#known-issues>Known issues</a></li><li><a href=#demo>Demo</a></li><li><a href=#testing>Testing</a></li><li><a href=#links>Links</a></li></ul></nav></aside><main><h2 id=the-problem>The problem</h2><p>Consider the following situation: you have got an exception in production. Of course, all of us are good developers, but you know, sometimes *it just happens. What do you usually do to get some information about the error? You just grab the request parameters to test it locally, right? Then I might have a better solution for you: dump your memory once an error happens and restore the dump later to debug it.</p><h2 id=binding>Binding</h2><p>In Ruby the best candidate for doing this is <code>Binding</code> class. If you have a binding, your can easily do some debug using well-known <code>pry</code> gem. But the binding itself cannot be dumped (at least not, using default Ruby tools).</p><p>How to get a local binding? Just use <code>binding</code>. How to get a binding from an object? Just add a method to you class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>local_binding</span>
</span></span><span style=display:flex><span>    binding
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>MyClass</span><span style=color:#f92672>.</span>new<span style=color:#f92672>.</span>local_binding
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; #&lt;Binding&gt;</span>
</span></span></code></pre></div><p>Binding encapsulates the execution context at the place in your code where the interpreter is currently running and retains this context for future use. So, to dump and load back a binding we need to:</p><ul><li>Dump the context of the binding (i.e. <code>binding.eval('self')</code>)</li><li>Dump all local variables (i.e. <code>binding.eval('local_variables')</code>)</li></ul><p>In fact, that&rsquo;s all you need to restore your binding.</p><h2 id=marshaling>Marshaling</h2><p>How can we dump an arbitrary structure? Ruby has a class in the standard library called <code>Marshal</code>. The two core methods of this class are <code>dump</code> and <code>load</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>Point</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Struct</span><span style=color:#f92672>.</span>new(<span style=color:#e6db74>:x</span>, <span style=color:#e6db74>:y</span>)
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span><span style=color:#f92672>.</span>new(<span style=color:#ae81ff>34</span>, <span style=color:#ae81ff>65</span>)
</span></span><span style=display:flex><span>marshaled <span style=color:#f92672>=</span> <span style=color:#66d9ef>Marshal</span><span style=color:#f92672>.</span>dump(a)
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; &#34;\x04\bS:\nPoint\a:\x06xi&#39;:\x06yiF&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Marshal</span><span style=color:#f92672>.</span>load(marshaled)
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; #&lt;struct Point x=34, y=65&gt;</span>
</span></span></code></pre></div><h2 id=limitations>Limitations</h2><p>Unfortunately, not everything can be marshaled. According to the documentation, the following objects cannot be dumped:</p><ul><li>bindings (e.g., the return value of binding itself)</li><li>procedure or method objects (e.g., <code>proc {}</code> or <code>object.method(:method_name)</code>)</li><li>instances of class IO (e.g., <code>IO.new(1)</code> or <code>StringIO.new</code>)</li><li>anonymous classes and modules (e.g. <code>Class.new</code> or <code>Module.new</code>)</li></ul><p>That sound really sad, but in most cases we can ignore these limitations. When was the last time you needed to debug an IO object that was doing something strange? In real life we rarely use any of these classes <strong>during debugging process</strong>. So, instead of dumping and loading back an <code>IO</code> object we can just return a new one.</p><h2 id=converting-objects-to-marshalable-data>Converting objects to marshalable data</h2><p>Well, we can patch every single class in Ruby and add <code>marshal_load</code> and <code>marshal_dump</code> hooks to them, but that&rsquo;s just horrible. It would be much, much better to write a set of classes that are each responsible for converting a specific group of objects.</p><p>With that in mind I have implemented:</p><ol><li><code>PrimitiveDumper</code> - for dumping primitive objects, like numbers, booleans.</li><li><code>ArrayDumper</code> - for arrays.</li><li><code>HashDumper</code> - for hashes.</li><li><code>ObjectDumper</code> - for custom objects.</li><li><code>ClassDumper</code> - for classes.</li><li><code>ProcDumper</code> - for <code>proc</code>/method objects</li><li><code>MagicDumper</code> - for &ldquo;magical objects&rdquo; (see &lsquo;dumping magical objects&rsquo; section)</li><li><code>ExistingObjectDumper</code> - for existing objects (see &lsquo;dumping recurring objects&rsquo; section)</li></ol><p>Every dumper takes an object that we need to dump and returns its marshalable representation. Later you can use the same dumper to restore representation back and get the original object.</p><p>You can find the implementation of these dumpers <a href=https://github.com/iliabylich/binding_dumper/tree/master/lib/binding_dumper/dumpers target=_blank rel="noreferrer nofollow">here</a>
and the specs for them <a href=https://github.com/iliabylich/binding_dumper/tree/master/spec/binding_dumper/dumpers target=_blank rel="noreferrer nofollow">here</a>
.</p><p>Here is, probably, the most complicated example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>undumpable_recursive_object</span>
</span></span><span style=display:flex><span>  @undumpable_recursive <span style=color:#f92672>||=</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span><span style=color:#f92672>.</span>allocate
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> p
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>y <span style=color:#f92672>=</span> <span style=color:#66d9ef>StringIO</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>    p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>After converting this object using a system of dumpers result looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#e6db74>_klass</span>: <span style=color:#66d9ef>Point</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>_ivars</span>: {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:@x</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>_existing_object_id</span>: <span style=color:#ae81ff>1234566</span> <span style=color:#75715e># or similar</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:@y</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>_klass</span>: <span style=color:#66d9ef>StringIO</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>_undumpable</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#e6db74>_old_object_id</span>: <span style=color:#ae81ff>1234566</span> <span style=color:#75715e># same as above</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This hash can be easily marshaled and restored back. But yes, we lose our <code>StringIO</code> instance - when the object is loaded back, that variable will be blank.</p><h2 id=dumping-magical-objects>Dumping Magical objects</h2><p>After writing the first version of the library, I have tested it with a blank Rails application. The testing code was:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UsersController</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>ApplicationController</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>index</span>
</span></span><span style=display:flex><span>    @users <span style=color:#f92672>=</span> <span style=color:#66d9ef>User</span><span style=color:#f92672>.</span>all<span style=color:#f92672>.</span>to_a <span style=color:#75715e># 5 records</span>
</span></span><span style=display:flex><span>    local_proc <span style=color:#f92672>=</span> proc { <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> }
</span></span><span style=display:flex><span>    render <span style=color:#e6db74>json</span>: @users
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>StoredBinding</span><span style=color:#f92672>.</span>create(<span style=color:#e6db74>data</span>: binding<span style=color:#f92672>.</span>dump)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The length of the dump was ~30 screens and it took ~20 seconds to generate it. Most of the data was coming from objects related to Rails itself. Things like Rails configuration, backtrace cleaners, arrays of middlewares, and so on. Do we need them? No. These objects are the same for every request, so we can ignore them.</p><p>But at the same time, we need to save and restore all references from &lsquo;serializable&rsquo; objects to &lsquo;magic&rsquo; objects, we can&rsquo;t just omit them. This logic is implemented in <a href=https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/magic_objects.rb target=_blank rel="noreferrer nofollow"><code>BindingDumper::MagicObjects</code></a>
module and here’s how you can use it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>
</span></span><span style=display:flex><span>  @config <span style=color:#f92672>=</span> <span style=color:#e6db74>:config</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>BindingDumper</span><span style=color:#f92672>::</span><span style=color:#66d9ef>MagicObjects</span><span style=color:#f92672>.</span>register(A)
</span></span><span style=display:flex><span>p <span style=color:#66d9ef>BindingDumper</span><span style=color:#f92672>::</span><span style=color:#66d9ef>MagicObjects</span><span style=color:#f92672>.</span>pool
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> {<span style=color:#ae81ff>10633360</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#ae81ff>600668</span><span style=color:#f92672>=&gt;</span><span style=color:#e6db74>&#34;A.instance_variable_get(:@config)&#34;</span>}
</span></span></code></pre></div><p>So, it builds a mapping between <code>object_id</code> and the way how to get this object. Using this functionality we can easily get whether existing object is &lsquo;magical&rsquo;, and if yes - dump its string representation (to <code>eval</code> it on loading phase). Let&rsquo;s say, we need to dump <code>Rails.application.config</code>, one of the &lsquo;magical&rsquo; objects. We need to get its <code>object_id</code>, find it in the pool and remember the string that returns rails configuration after evaluation, i.e.:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#e6db74>&#34;Rails.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  instance_variable_get(:@app_class).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  instance_variable_get(:@instance).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  instance_variable_get(:@config)&#34;</span>
</span></span></code></pre></div><p>After this optimization we have to spend ~20 ms to build an object pool and ~200 ms to dump a binding.</p><h2 id=dumping-recurring-objects>Dumping recurring objects</h2><p>We can optimize it even more. A lot of things like <code>request</code>, <code>response</code> are shared as instance variables across ~10 objects. We can dump our <code>request</code> object only once, remember its <code>object_id</code> and use a reference while dumping other objects that use it.</p><p>Let&rsquo;s say, we are in the initial memory (<code>MEM1</code>). We dump a binding, open another console with separated memory (<code>MEM2</code>) and restore a binding. In the example above (about recursive structure) there was a key <code>:_existing_object_id</code> that returns an <code>object_id</code> from <code>MEM1</code>.</p><p>In <code>MEM2</code> we restore a binding and create a mapping</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>{
</span></span><span style=display:flex><span>  object_id_from_MEM1 <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  restored_object_in_MEM2
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using this mapping (in the gem it&rsquo;s called <a href=https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/memories.rb target=_blank rel="noreferrer nofollow">memories</a>
) we can restore the reference to duplicated objects.</p><h2 id=restoring-a-binding>Restoring a binding</h2><p>At this point you can be really confused, but relax, we are almost done.</p><p>So, we have a binding. To dump it we need to:</p><ol><li>Build a <code>hash1</code> with the context of binding and local variables</li><li>Convert it to a marshalable nested <code>hash2</code></li><li><code>Marshal.dump(hash2)</code></li><li>Store the result in any persistent storage.</li></ol><p>To load it back:</p><ol><li><code>Marshal.load</code> the dump to get <code>hash2</code></li><li>Convert <code>hash2</code> to <code>hash1</code> using the same converters</li><li>Load the context and all local variables from <code>hash1</code></li><li>Patch the context a little bit to make it pretty.</li></ol><p>Steps 1-4 and 1-3 are already implemented. The last step – making the context pretty – means that we need to inject local_binding method into the context and make it look like the “real” binding (inject local variables to the binding).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># we just have it,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># it&#39;s a `self` from the place where `binding.dump` was called</span>
</span></span><span style=display:flex><span>context
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># and we have also local variables</span>
</span></span><span style=display:flex><span>local_variables
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># here we need to get a binding that:</span>
</span></span><span style=display:flex><span>subject<span style=color:#f92672>.</span>local_binding<span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#39;self&#39;</span>) <span style=color:#f92672>==</span> context
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; true</span>
</span></span><span style=display:flex><span>subject<span style=color:#f92672>.</span>local_binding<span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#39;local_variables&#39;</span>) <span style=color:#f92672>==</span> local_variables
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; true</span>
</span></span></code></pre></div><p>The pseudo-code for loading and patching the context looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>marshaled <span style=color:#f92672>=</span> <span style=color:#66d9ef>StoredBinding</span><span style=color:#f92672>.</span>last<span style=color:#f92672>.</span>data
</span></span><span style=display:flex><span>converted <span style=color:#f92672>=</span> <span style=color:#66d9ef>Marshal</span><span style=color:#f92672>.</span>load(marshaled)
</span></span><span style=display:flex><span>restored <span style=color:#f92672>=</span> <span style=color:#66d9ef>Dumpers</span><span style=color:#f92672>.</span>load(converted)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context <span style=color:#f92672>=</span> undumped<span style=color:#f92672>[</span><span style=color:#e6db74>:context</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>locals <span style=color:#f92672>=</span> undumped<span style=color:#f92672>[</span><span style=color:#e6db74>:locals</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#f92672>&lt;&lt;</span> context
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>local_binding</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> binding
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    locals<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>lvar_name, lvar<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      result<span style=color:#f92672>.</span>local_variable_set(lvar_name, lvar)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The actual implementation can be found <a href=https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/core_ext/binding_ext.rb target=_blank rel="noreferrer nofollow">here</a>
. After calling <code>Binding.load(dumped).pry</code> you can start debugging it!</p><h2 id=compatibility-with-old-versions-of-ruby>Compatibility with old versions of Ruby</h2><p>Currently the gem supports Ruby versions from 1.9.3 to 2.2.3. I had a few issues with porting the code from 2.0.0 to 1.9.3, like the lack of keyword arguments and <code>Module#prepend</code>. The funniest one was that in versions before 2.1.0 there is no <code>binding.local_variable_set</code> - there is only <code>binding.eval</code> that takes a string, not a block.</p><p>How can we pass a complex object to <code>eval</code>? The solution is not so difficult, because we have the object right here and right now, and the binding uses the same memory as the main thread. This means that we can pass the <code>object_id</code> of our object to <code>eval</code> string and get it there using <code>ObjectSpace._id2ref</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>undumped<span style=color:#f92672>[</span><span style=color:#e6db74>:lvars</span><span style=color:#f92672>].</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>lvar_name, lvar<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  result<span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>#{</span>lvar_name<span style=color:#e6db74>}</span><span style=color:#e6db74> = ObjectSpace._id2ref(</span><span style=color:#e6db74>#{</span>lvar<span style=color:#f92672>.</span>object_id<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h2 id=known-issues>Known issues</h2><p>I have tested the gem locally with a few projects. Everything was fine, but:</p><ol><li>Encoding. The data that the gem produces should be stored in UTF-8</li><li>The difference between Rails server and Rails console. There are some classes that are loaded only when the server is started (like <code>Rails::BacktraceCleaner</code> and some others from <code>NewRelic</code> gem). You have to require corresponding files manually before loading the binding in the console.</li></ol><h2 id=demo>Demo</h2><p>To try it out, clone the <a href=https://github.com/iliabylich/binding_dumper target=_blank rel="noreferrer nofollow">GitHub repository</a>
, install dependencies, prepare the database using <code>bin/dummy_rake db:create db:migrate</code>, and start the server via <code>bin/dummy_rails s</code>. Then visit <a href=http://localhost:3000/users target=_blank rel="noreferrer nofollow">http://localhost:3000/users</a>
to dump the binding of <code>UsersController#index</code>. After that you can open a console using <code>bin/dummy_rails c</code> and run <code>StoredBinding.last.debug</code>. You’re now in your controller, in the same state that it was in a moment ago when you hit that /users page!.</p><h2 id=testing>Testing</h2><p>The gem is fully tested with its specs running on <a href=https://travis-ci.org/iliabylich/binding_dumper/ target=_blank rel="noreferrer nofollow">Travis CI</a>
. There&rsquo;s also a <a href=https://github.com/iliabylich/binding_dumper/blob/master/bin/multitest target=_blank rel="noreferrer nofollow">script</a>
that can be used to run the whole test suite locally on <strong>every</strong> supported version of Ruby. But that&rsquo;s definitely not enough for a gem to become completely production-ready.</p><p>That&rsquo;s why I ask everyone who read this article: if you think that the idea of this gem should stay alive, that this method of debugging can be useful, and you would like to use it yourself, please, try it out locally and share your finding with me (via Twitter or GitHub).</p><h2 id=links>Links</h2><p><a href=https://github.com/iliabylich/binding_dumper target=_blank rel="noreferrer nofollow">GitHub repository</a></p></main><br><footer><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=e.textContent;navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script></footer></body></html>