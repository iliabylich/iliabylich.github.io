<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Saving execution context for later debugging &middot; Ilya Bylich
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="192x192" href="/public/apple-touch-icon-192-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Ilya Bylich
        </a>
      </h1>
      <p class="lead">I'm a Ruby/Rust developer, sometimes I write long technical stories</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      <a class="sidebar-nav-item" href="https://github.com/iliabylich">GitHub</a>
      <a class="sidebar-nav-item" href="https://twitter.com/IlyaBylich">Twitter</a>
      <a class="sidebar-nav-item" href="mailto:ibylich@gmail.com">Email me</a>

      <span class="sidebar-nav-item">
  <label for="current-theme">Theme</label>
  <select id="current-theme">
    <option>08</option>
    <option>09</option>
    <option>0a</option>
    <option>0b</option>
    <option>0c</option>
    <option>0d</option>
    <option>0f</option>
  </select>

  <script type="text/javascript">
    class Theme {
      static DEFAULT = "0b";

      static getCurrent() {
        return localStorage.getItem("current-theme") || Theme.DEFAULT;
      }

      static setCurrent(theme) {
        localStorage.setItem("current-theme", theme);
        document.body.className = `theme-base-${theme}`;
      }
    }

    const themeSelector = document.getElementById("current-theme");
    Theme.setCurrent(Theme.getCurrent());
    themeSelector.value = Theme.getCurrent();

    themeSelector.onchange = (e) => {
      const theme = e.target.value;
      Theme.setCurrent(theme);
    }
  </script>
</span>

    </nav>

    <p>&copy; 2022. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Saving execution context for later debugging</h1>
  <span class="post-date">20 Aug 2015</span>

  <div id="table-of-contents">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#binding">Binding</a></li>
<li class="toc-entry toc-h2"><a href="#marshaling">Marshaling</a></li>
<li class="toc-entry toc-h2"><a href="#limitations">Limitations</a></li>
<li class="toc-entry toc-h2"><a href="#converting-objects-to-marshalable-data">Converting objects to marshalable data</a></li>
<li class="toc-entry toc-h2"><a href="#dumping-magical-objects">Dumping Magical objects</a></li>
<li class="toc-entry toc-h2"><a href="#dumping-recurring-objects">Dumping recurring objects</a></li>
<li class="toc-entry toc-h2"><a href="#restoring-a-binding">Restoring a binding</a></li>
<li class="toc-entry toc-h2"><a href="#compatibility-with-old-versions-of-ruby">Compatibility with old versions of Ruby</a></li>
<li class="toc-entry toc-h2"><a href="#known-issues">Known issues</a></li>
<li class="toc-entry toc-h2"><a href="#demo">Demo</a></li>
<li class="toc-entry toc-h2"><a href="#testing">Testing</a></li>
<li class="toc-entry toc-h2"><a href="#links">Links</a></li>
</ul>
  </div>

  <p>Consider the following situation: you’ve got an exception in production. Of course, all of us are good developers, but you know, sometimes *it just happens. What do you usually do to get some information about the error? You just grab the request parameters to test it locally, right? Then I might have a better solution for you: dump your memory once an error happens and restore the dump later to debug it.</p>

<h2 id="binding">Binding</h2>

<p>In Ruby the best candidate for doing this is <code class="language-plaintext highlighter-rouge">Binding</code> class. If you have a binding, your can easily do some debug using well-known <code class="language-plaintext highlighter-rouge">pry</code> gem. But the binding itself cannot be dumped (at least not, using default Ruby tools).</p>

<p>How to get a local binding? Just use <code class="language-plaintext highlighter-rouge">binding</code>. How to get a binding from an object? Just add a method to you class:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="k">def</span> <span class="nf">local_binding</span>
    <span class="nb">binding</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">MyClass</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">local_binding</span>
<span class="c1"># =&gt; #&lt;Binding&gt;</span>
</code></pre></div></div>

<p>Binding encapsulates the execution context at the place in your code where the interpreter is currently running and retains this context for future use. So, to dump and load back a binding we need to:</p>
<ul>
  <li>Dump the context of the binding (i.e. <code class="language-plaintext highlighter-rouge">binding.eval('self')</code>)</li>
  <li>Dump all local variables (i.e. <code class="language-plaintext highlighter-rouge">binding.eval('local_variables')</code>)</li>
</ul>

<p>In fact, that’s all you need to restore your binding.</p>

<h2 id="marshaling">Marshaling</h2>

<p>How can we dump an arbitrary structure? Ruby has a class in stdlib called <code class="language-plaintext highlighter-rouge">Marshal</code>. The two core methods of this class are <code class="language-plaintext highlighter-rouge">dump</code> and <code class="language-plaintext highlighter-rouge">load</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Point</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">34</span><span class="p">,</span> <span class="mi">65</span><span class="p">)</span>
<span class="n">marshaled</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># =&gt; "\x04\bS:\nPoint\a:\x06xi':\x06yiF"</span>
<span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">marshaled</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;struct Point x=34, y=65&gt;</span>
</code></pre></div></div>

<h2 id="limitations">Limitations</h2>

<p>Unfortunately, not everything can be marshaled. According to the documentation, the following objects cannot be dumped:</p>
<ul>
  <li>bindings (e.g., the return value of binding itself)</li>
  <li>procedure or method objects (e.g., <code class="language-plaintext highlighter-rouge">proc {}</code> or <code class="language-plaintext highlighter-rouge">object.method(:method_name)</code>)</li>
  <li>instances of class IO (e.g., <code class="language-plaintext highlighter-rouge">IO.new(1)</code> or <code class="language-plaintext highlighter-rouge">StringIO.new</code>)</li>
  <li>anonymous classes and modules (e.g. <code class="language-plaintext highlighter-rouge">Class.new</code> or <code class="language-plaintext highlighter-rouge">Module.new</code>)</li>
</ul>

<p>That sound really sad, but in most cases we can ignore these limitations. When was the last time you needed to debug an IO object that was doing something strange? In real life we rarely use any of these classes <strong>during debugging process</strong>. So, instead of dumping and loading back  an <code class="language-plaintext highlighter-rouge">IO</code> object we can just return a new one.</p>

<h2 id="converting-objects-to-marshalable-data">Converting objects to marshalable data</h2>

<p>Well, we can patch every single class in Ruby and add <code class="language-plaintext highlighter-rouge">marshal_load</code> and <code class="language-plaintext highlighter-rouge">marshal_dump</code> hooks to them, but that’s just horrible. It would be much, much better to write a set of classes that are each responsible for converting a specific group of objects.</p>

<p>With that in mind I’ve implemented:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">PrimitiveDumper</code> - for dumping primitive objects, like numbers, booleans.</li>
  <li><code class="language-plaintext highlighter-rouge">ArrayDumper</code> - for arrays.</li>
  <li><code class="language-plaintext highlighter-rouge">HashDumper</code> - for hashes.</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectDumper</code> - for custom objects.</li>
  <li><code class="language-plaintext highlighter-rouge">ClassDumper</code> - for classes.</li>
  <li><code class="language-plaintext highlighter-rouge">ProcDumper</code> - for proc/method objects</li>
  <li><code class="language-plaintext highlighter-rouge">MagicDumper</code> - for “magical objects” (see ‘dumping magical objects’ section)</li>
  <li><code class="language-plaintext highlighter-rouge">ExistingObjectDumper</code> - for existing objects (see ‘dumping recurring objects’ section)</li>
</ol>

<p>Every dumper takes an object that we need to dump and returns its marshalable representation. Later you can use the same dumper to deconvert representation back and get the original object.</p>

<p>You can find the implementation of these dumpers <a href="https://github.com/iliabylich/binding_dumper/tree/master/lib/binding_dumper/dumpers">here</a> and the specs for them <a href="https://github.com/iliabylich/binding_dumper/tree/master/spec/binding_dumper/dumpers">here</a>.</p>

<p>Here is, probably, the most complicated example:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">undumpable_recursive_object</span>
  <span class="vi">@undumpable_recursive</span> <span class="o">||=</span> <span class="k">begin</span>
    <span class="nb">p</span> <span class="o">=</span> <span class="no">Point</span><span class="p">.</span><span class="nf">allocate</span>
    <span class="nb">p</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="nb">p</span>
    <span class="nb">p</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="no">StringIO</span><span class="p">.</span><span class="nf">new</span>
    <span class="nb">p</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>After converting this object using a system of dumpers result looks like this:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">_klass: </span><span class="no">Point</span><span class="p">,</span>
  <span class="ss">_ivars: </span><span class="p">{</span>
    <span class="ss">:@x</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="ss">_existing_object_id: </span><span class="mi">1234566</span> <span class="c1"># or similar</span>
    <span class="p">},</span>
    <span class="ss">:@y</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="ss">_klass: </span><span class="no">StringIO</span><span class="p">,</span>
      <span class="ss">_undumpable: </span><span class="kp">true</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="ss">_old_object_id: </span><span class="mi">1234566</span> <span class="c1"># same as above</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This hash can be easily marshaled and restored back. But yes, we lose our <code class="language-plaintext highlighter-rouge">StringIO</code> instance - when the object is loaded back, that variable will be blank.</p>

<h2 id="dumping-magical-objects">Dumping Magical objects</h2>

<p>After writing the first version of the library, I’ve tested it with a blank Rails application. The testing code was:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># 5 records</span>
    <span class="n">local_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}</span>
    <span class="n">render</span> <span class="ss">json: </span><span class="vi">@users</span>
    <span class="no">StoredBinding</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">data: </span><span class="nb">binding</span><span class="p">.</span><span class="nf">dump</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The length of the dump was  ~30 screens and it took ~20 seconds to generate it. Most of the data was coming from objects related to Rails itself. Things like Rails configs, backtrace cleaners, arrays of middlewares, and so on. Do we need them? No. These objects are the same for every request, so we can ignore them.</p>

<p>But at the same time, we need to save and restore all references from ‘dumpable’ objects to ‘magic’ objects, we can’t just omit them. This logic is implemented in <a href="https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/magic_objects.rb">BindingDumper::MagicObjects</a> module and here’s how you can use it:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span>
  <span class="vi">@config</span> <span class="o">=</span> <span class="ss">:config</span>
<span class="k">end</span>

<span class="no">BindingDumper</span><span class="o">::</span><span class="no">MagicObjects</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="no">A</span><span class="p">)</span>
<span class="nb">p</span> <span class="no">BindingDumper</span><span class="o">::</span><span class="no">MagicObjects</span><span class="p">.</span><span class="nf">pool</span>
<span class="o">=&gt;</span> <span class="p">{</span><span class="mi">10633360</span><span class="o">=&gt;</span><span class="s2">"A"</span><span class="p">,</span> <span class="mi">600668</span><span class="o">=&gt;</span><span class="s2">"A.instance_variable_get(:@config)"</span><span class="p">}</span>
</code></pre></div></div>

<p>So, it builds a mapping between <code class="language-plaintext highlighter-rouge">object_id</code> and the way how to get this object. Using this functionality we can easily get whether existing object is ‘magical’, and if yes - dump its string representation (to eval it on loading phase). Let’s say, we need to dump <code class="language-plaintext highlighter-rouge">Rails.application.config</code>, one of the ‘magical’ objects. We need to get its <code class="language-plaintext highlighter-rouge">object_id</code>, find it in the pool and remember the string that returns rails config after evaluation, i.e.:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"Rails.
  instance_variable_get(:@app_class).
  instance_variable_get(:@instance).
  instance_variable_get(:@config)"</span>
</code></pre></div></div>

<p>After this optimization we have to spend ~20ms to build an object pool and ~200ms to dump a binding.</p>

<h2 id="dumping-recurring-objects">Dumping recurring objects</h2>

<p>We can optimize it even more. A lot of things like <code class="language-plaintext highlighter-rouge">request</code>, <code class="language-plaintext highlighter-rouge">response</code> are shared as instance variables across ~10 objects. We can dump our <code class="language-plaintext highlighter-rouge">request</code> object only once, remember its <code class="language-plaintext highlighter-rouge">object_id</code> and use a reference while dumping other objects that use it.</p>

<p>Let’s say, we are in the initial memory (MEM1). We dump a binding, open another console with separated memory (MEM2) and restore a binding. In the example above (about recursive structure) there was a key <code class="language-plaintext highlighter-rouge">:_existing_object_id</code> that returns an <code class="language-plaintext highlighter-rouge">object_id</code> from MEM1.</p>

<p>In MEM2 we restore a binding and create a mapping</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="n">object_id_from_MEM1</span> <span class="o">=&gt;</span>
  <span class="n">restored_object_in_MEM2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using this mapping (in the gem it’s called <a href="https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/memories.rb">memories</a>) we can restore the reference to duplicated objects.</p>

<h2 id="restoring-a-binding">Restoring a binding</h2>

<p>At this point you can be really confused, but relax, we are almost done.</p>

<p>So, we have a binding. To dump it we need to:</p>
<ol>
  <li>Build a <code class="language-plaintext highlighter-rouge">hash1</code> with the context of binding and local variables</li>
  <li>Convert it to a marshalable nested <code class="language-plaintext highlighter-rouge">hash2</code></li>
  <li><code class="language-plaintext highlighter-rouge">Marshal.dump(hash2)</code></li>
  <li>Store the result in any persistent storage.</li>
</ol>

<p>To load it back:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Marshal.load</code> the dump to get <code class="language-plaintext highlighter-rouge">hash2</code></li>
  <li>Convert <code class="language-plaintext highlighter-rouge">hash2</code> to <code class="language-plaintext highlighter-rouge">hash1</code> using the same converters</li>
  <li>Load the context and all local variables from <code class="language-plaintext highlighter-rouge">hash1</code></li>
  <li>Patch the context a little bit to make it pretty.</li>
</ol>

<p>Steps 1-4 and 1-3 are already implemented. The last step – making the context pretty – means that we need to inject local_binding method into the context and make it look like the “real” binding (inject local variables to the binding).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we just have it,</span>
<span class="c1"># it's a `self` from the place where `binding.dump` was called</span>
<span class="n">context</span>

<span class="c1"># and we have also local variables</span>
<span class="nb">local_variables</span>

<span class="c1"># here we need to get a binding that:</span>
<span class="n">subject</span><span class="p">.</span><span class="nf">local_binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'self'</span><span class="p">)</span> <span class="o">==</span> <span class="n">context</span>
<span class="c1"># =&gt; true</span>
<span class="n">subject</span><span class="p">.</span><span class="nf">local_binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'local_variables'</span><span class="p">)</span> <span class="o">==</span> <span class="nb">local_variables</span>
<span class="c1"># =&gt; true</span>
</code></pre></div></div>

<p>The pseudo-code for loading and patching the context looks like:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">marshaled</span> <span class="o">=</span> <span class="no">StoredBinding</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">data</span>
<span class="n">converted</span> <span class="o">=</span> <span class="no">Marshal</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">marshaled</span><span class="p">)</span>
<span class="n">restored</span> <span class="o">=</span> <span class="no">Dumpers</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">converted</span><span class="p">)</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">undumped</span><span class="p">[</span><span class="ss">:context</span><span class="p">]</span>
<span class="n">locals</span> <span class="o">=</span> <span class="n">undumped</span><span class="p">[</span><span class="ss">:locals</span><span class="p">]</span>

<span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">context</span>
  <span class="k">def</span> <span class="nf">local_binding</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">binding</span>

    <span class="n">locals</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lvar_name</span><span class="p">,</span> <span class="n">lvar</span><span class="o">|</span>
      <span class="n">result</span><span class="p">.</span><span class="nf">local_variable_set</span><span class="p">(</span><span class="n">lvar_name</span><span class="p">,</span> <span class="n">lvar</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The actual implementation can be found <a href="https://github.com/iliabylich/binding_dumper/blob/master/lib/binding_dumper/core_ext/binding_ext.rb">here</a>. After calling <code class="language-plaintext highlighter-rouge">Binding.load(dumped).pry</code> you can start debugging it!</p>

<h2 id="compatibility-with-old-versions-of-ruby">Compatibility with old versions of Ruby</h2>

<p>Currently the gem supports Ruby versions from 1.9.3 to 2.2.3. I had a few issues with porting the code from 2.0.0 to 1.9.3, like the lack of kwargs and <code class="language-plaintext highlighter-rouge">Module#prepend</code>. The funniest one was that in versions before 2.1.0 there is no <code class="language-plaintext highlighter-rouge">binding.local_variable_set</code> - there is only <code class="language-plaintext highlighter-rouge">binding.eval</code> that takes a string, not a block.</p>

<p>How can we pass a complex object to <code class="language-plaintext highlighter-rouge">eval</code>? The solution is not so difficult, because we have the object right here and right now, and the binding uses the same memory as the main thread. This means that we can pass the <code class="language-plaintext highlighter-rouge">object_id</code> of our object to <code class="language-plaintext highlighter-rouge">eval</code> string and get it there using <code class="language-plaintext highlighter-rouge">ObjectSpace._id2ref</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undumped</span><span class="p">[</span><span class="ss">:lvars</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lvar_name</span><span class="p">,</span> <span class="n">lvar</span><span class="o">|</span>
  <span class="n">result</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">lvar_name</span><span class="si">}</span><span class="s2"> = ObjectSpace._id2ref(</span><span class="si">#{</span><span class="n">lvar</span><span class="p">.</span><span class="nf">object_id</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="known-issues">Known issues</h2>

<p>I’ve tested the gem locally with a few projects. Everything was fine, but:</p>
<ol>
  <li>Encoding. The data that the gem produces should be stored in UTF-8</li>
  <li>The difference between Rails server and Rails console. There are some classes that are loaded only when the server is started (like <code class="language-plaintext highlighter-rouge">Rails::BacktraceCleaner</code> and some others from <code class="language-plaintext highlighter-rouge">NewRelic</code> gem). You have to require corresponding files manually before loading the binding in the console.</li>
</ol>

<h2 id="demo">Demo</h2>

<p>To try it out, clone the <a href="https://github.com/iliabylich/binding_dumper">GitHub repository</a>, install dependencies, prepare the database using <code class="language-plaintext highlighter-rouge">bin/dummy_rake db:create db:migrate</code>, and start the server via <code class="language-plaintext highlighter-rouge">bin/dummy_rails s</code>. Then visit <a href="http://localhost:3000/users">http://localhost:3000/users</a> to dump the binding of <code class="language-plaintext highlighter-rouge">UsersController#index</code>. After that you can open a console using <code class="language-plaintext highlighter-rouge">bin/dummy_rails c</code> and run <code class="language-plaintext highlighter-rouge">StoredBinding.last.debug</code>. You’re now in your controller, in the same state that it was in a moment ago when you hit that /users page!.</p>

<h2 id="testing">Testing</h2>

<p>The gem is fully tested with its specs running on <a href="https://travis-ci.org/iliabylich/binding_dumper/">Travis CI</a>. There’s also a <a href="https://github.com/iliabylich/binding_dumper/blob/master/bin/multitest">script</a> that can be used to run the whole test suite locally on <strong>every</strong> supported version of Ruby. But that’s definitely not enough for a gem to become completely production-ready.</p>

<p>That’s why I ask everyone who read this article: if you think that the idea of this gem should stay alive, that this method of debugging can be useful, and you would like to use it yourself, please, try it out locally and share your finding with me (via Twitter or Github).</p>

<h2 id="links">Links</h2>

<p><a href="https://github.com/iliabylich/binding_dumper">Github repo</a></p>

</div>


  <div class="comments">
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
          this.page.url = document.location.href;  // Replace PAGE_URL with your page's canonical URL variable
          this.page.identifier = document.location.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://ibylich-myblog.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>


<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2021/12/27/writing-bindings-upside-down.html">
            Writing bindings upside down
            <small>27 Dec 2021</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/11/22/lib-ruby-parser.html">
            lib-ruby-parser
            <small>22 Nov 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/01/25/evaluating-ruby-in-ruby.html">
            Evaluating Ruby in Ruby
            <small>25 Jan 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>
  </body>
</html>
