<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Writing bindings upside down &middot; Ilya Bylich
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Ilya Bylich
        </a>
      </h1>
      <p class="lead">I'm a Ruby/Rust developer, sometimes I write long technical stories</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      <a class="sidebar-nav-item" href="https://github.com/iliabylich">GitHub</a>
      <a class="sidebar-nav-item" href="https://twitter.com/IlyaBylich">Twitter</a>
      <a class="sidebar-nav-item" href="mailto:ibylich@gmail.com">Email me</a>

      <span class="sidebar-nav-item">
  <label for="current-theme">Theme</label>
  <select id="current-theme">
    <option>08</option>
    <option>09</option>
    <option>0a</option>
    <option>0b</option>
    <option>0c</option>
    <option>0d</option>
    <option>0f</option>
  </select>

  <script type="text/javascript">
    class Theme {
      static DEFAULT = "0b";

      static getCurrent() {
        return localStorage.getItem("current-theme") || Theme.DEFAULT;
      }

      static setCurrent(theme) {
        localStorage.setItem("current-theme", theme);
        document.body.className = `theme-base-${theme}`;
      }
    }

    const themeSelector = document.getElementById("current-theme");
    Theme.setCurrent(Theme.getCurrent());
    themeSelector.value = Theme.getCurrent();

    themeSelector.onchange = (e) => {
      const theme = e.target.value;
      Theme.setCurrent(theme);
    }
  </script>
</span>

    </nav>

    <p>&copy; 2022. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Writing bindings upside down</h1>
  <span class="post-date">27 Dec 2021</span>

  <div id="table-of-contents">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#traditional-way">Traditional way</a></li>
<li class="toc-entry toc-h2"><a href="#slow-but-more-reliable-solution">Slow but more reliable solution</a></li>
<li class="toc-entry toc-h2"><a href="#a-demo-small-but-representative">A demo, small but representative</a></li>
<li class="toc-entry toc-h2"><a href="#foreign-implementation">“Foreign” implementation</a></li>
<li class="toc-entry toc-h2"><a href="#example">Example</a></li>
<li class="toc-entry toc-h2"><a href="#implementing-bindings">Implementing bindings</a></li>
<li class="toc-entry toc-h2"><a href="#c-bindings-quickly">C++ bindings, quickly</a></li>
<li class="toc-entry toc-h2"><a href="#ruby-bindings-also-quickly">Ruby bindings, also quickly</a></li>
<li class="toc-entry toc-h2"><a href="#memory-leaks">Memory leaks</a></li>
<li class="toc-entry toc-h2"><a href="#performance">Performance</a></li>
<li class="toc-entry toc-h2"><a href="#the-whole-picture-again">The whole picture, again</a></li>
</ul>
  </div>

  <p>Quite a long time ago I started writing C/C++/Ruby/Node.JS/WASM bindings so I could call <a href="https://github.com/lib-ruby-parser/lib-ruby-parser">my Rust project</a> from those languages. It is a Ruby language parser.</p>

<p>I tried multiple ways and found one that is very (VERY) controversial, but I think it deserves it’s own article.</p>

<h2 id="traditional-way">Traditional way</h2>

<p>Let’s say you have a library in C. Just for simplicity, Rust is not special here.</p>

<p><img src="https://raw.githubusercontent.com/iliabylich/writing-bindings-upside-down/master/images/library-puzzle-piece.png" alt="library-puzzle-piece.png" /></p>

<p>How can you use it in C++? A very simple solution is to wrap your header file with</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
<span class="cp">#endif
</span>
<span class="c1">// C bindings</span>

<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>then change your includes to be slightly more compatible with C++ (<code class="language-plaintext highlighter-rouge">stdio.h</code> -&gt; <code class="language-plaintext highlighter-rouge">cstdio</code> etc) and call it a day.</p>

<ul>
  <li>Pros: very simple.</li>
  <li>Cons: your API has raw pointers, raw array/string structures that expose everything and are error-prone when used.</li>
</ul>

<p>How can you use it in Ruby/Node.JS? Again, let’s start with “traditional” solution. For Ruby take your C library, for Node.JS take C++ library and “wrap” it using a “native” extension.</p>

<p>It is possible to “attach” any arbitrary data to Ruby/Node.JS objects</p>
<ul>
  <li>Ruby has <a href="https://docs.ruby-lang.org/en/2.4.0/extension_rdoc.html#label-C+struct+to+Ruby+object"><code class="language-plaintext highlighter-rouge">TypedData_Wrap_Struct</code> function</a></li>
  <li>Node.JS has <a href="https://github.com/nodejs/node-addon-api/blob/main/doc/external.md"><code class="language-plaintext highlighter-rouge">Napi::External</code></a></li>
</ul>

<p>In both cases it’s possible to get pointer to attached data at any moment, both require you to specify a function that GC calls to free attached data.</p>

<p>Pros: still quite simple.
Cons: really error-prone, libraries designed this way quite frequently have memory leaks and segfaults.</p>

<p><img src="https://raw.githubusercontent.com/iliabylich/writing-bindings-upside-down/master/images/traditional-bindings.png" alt="traditional-bindings.png" /></p>

<h2 id="slow-but-more-reliable-solution">Slow but more reliable solution</h2>

<p>Of course it’d be unfair to not mention that it’s always possible to type-cast structures from low-level language to high-level:</p>

<ol>
  <li>C -&gt; C++ - by converting C structs to pretty C++ classes with smart pointers and collections</li>
  <li>C -&gt; Ruby - by creating Ruby objects from C structs</li>
  <li>C++ -&gt; Node.JS - by creating JavaScript objects from C++ classes</li>
</ol>

<ul>
  <li>Pros: this way it’s actually less dangerous. You can cover it with unit-tests and check with ASAN/Valgrind/LSAN that you have no segfaults, memory leaks or incorrect memory access.</li>
  <li>Cons: you have to copy a bunch of data and it will hurt performance. Many of your methods have to be rewritten to target language OR you have convert C++/Ruby/JS objects back to C to call original C functions.</li>
</ul>

<p>A small note on copying: it is possible to “move” some data in certain cases and languages:</p>

<ul>
  <li>Ruby has a family of <code class="language-plaintext highlighter-rouge">rb_str_new_*</code> functions, but literally all of them take <code class="language-plaintext highlighter-rouge">const char *ptr, size_t len</code>, however, it’s possible to create a “dummy” heap-allocated Ruby <code class="language-plaintext highlighter-rouge">String</code> and set <code class="language-plaintext highlighter-rouge">ptr</code> and <code class="language-plaintext highlighter-rouge">len</code> on it. It is possible only (and only) because internals of all Ruby objects (including <code class="language-plaintext highlighter-rouge">String</code>) are fully exposed on C layer.</li>
  <li>Node.JS has a <a href="https://github.com/nodejs/node-addon-api/blob/main/doc/string.md"><code class="language-plaintext highlighter-rouge">Napi::String</code></a> class for that but it takes either a C++ <code class="language-plaintext highlighter-rouge">const std::string&amp;</code> or <code class="language-plaintext highlighter-rouge">const char *</code>. From what I know internals are not available, so copying is necessary.</li>
  <li>C++ has a <code class="language-plaintext highlighter-rouge">std::string</code> that doesn’t have a “take-and-store-what’s-given” constructor that takes a <code class="language-plaintext highlighter-rouge">char *</code> (I would call it a “move” constructor, but this name has a different meaning in C++ :D). There’s a <code class="language-plaintext highlighter-rouge">const char *</code> constructor that performs copying. Of course it’s possible to create a compiler-dependent type-casting to a class with the same set of fields, move pointer + len + capacity there and convert it back to <code class="language-plaintext highlighter-rouge">std::string</code>. It’s ugly, but definitely doable.</li>
</ul>

<h2 id="a-demo-small-but-representative">A demo, small but representative</h2>

<p>Let’s start. I’d like to demonstrate a different solution on a tiny example. Let’s write a micro-library that has several Rust structs, something like a function that, let’s say, takes a <code class="language-plaintext highlighter-rouge">String</code> and returns a <code class="language-plaintext highlighter-rouge">Vec</code> of all non-ascii chars. It’s called <code class="language-plaintext highlighter-rouge">foo</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pub fn foo(s: &amp;str) -&gt; Vec&lt;char&gt; {
    s.chars().filter(|c| !c.is_ascii()).collect()
}

#[test]
fn test_foo() {
    let chars = foo("abc😋中国def");
    assert_eq!(chars, vec!['😋', '中', '国']);
}
</code></pre></div></div>

<p>There are two structs that belong to Rust world exclusively: <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">char</code>.</p>

<h2 id="foreign-implementation">“Foreign” implementation</h2>

<p>Can we expose these two types in C? <code class="language-plaintext highlighter-rouge">Vec</code> is defined in Rust standard library and it has <code class="language-plaintext highlighter-rouge">#[repr(Rust)]</code>, <code class="language-plaintext highlighter-rouge">char</code> is a 4-byte structure with no public layout.</p>

<p>We could define our own <code class="language-plaintext highlighter-rouge">repr(C)</code> structs together with <code class="language-plaintext highlighter-rouge">impl From&lt;RustType&gt; for CType</code> and call <code class="language-plaintext highlighter-rouge">.into()</code>, but that’s not really the goal here.</p>

<p>Let’s think for a moment about C++, Ruby and Node:</p>

<ul>
  <li>In C++ I’d really like to use <code class="language-plaintext highlighter-rouge">std::vector</code> for <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">std::string</code> for <code class="language-plaintext highlighter-rouge">char</code>.</li>
  <li>For both Ruby and Node.JS I want <code class="language-plaintext highlighter-rouge">Array</code> for <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">String</code> for <code class="language-plaintext highlighter-rouge">char</code>.</li>
</ul>

<p>What if our library could depend on some contract that requires bindings to provide primitives? The contract will be the same for all bindings, but implementation will be different.</p>

<p>Rust doesn’t know what is C++ <code class="language-plaintext highlighter-rouge">std::vector</code> or Ruby <code class="language-plaintext highlighter-rouge">String</code>, but we know it, our bindings know it and by providing a set of foreign utility functions (implemented on the bindings side) we could work with it just like with native <code class="language-plaintext highlighter-rouge">std::Vec&lt;T&gt;</code>.</p>

<p><img src="https://raw.githubusercontent.com/iliabylich/writing-bindings-upside-down/master/images/library-with-external-primitives.png?v1" alt="library-with-external-primitives.png" /></p>

<p>Here “Primitives” will be:</p>

<ul>
  <li>Rust structures for Rust version of the library</li>
  <li>C structs for C version</li>
  <li>C++ classes for C++ version</li>
  <li>Ruby classes for Ruby version</li>
</ul>

<p>“Functions to work with primitives” will be a set of <code class="language-plaintext highlighter-rouge">extern "C"</code> functions that take and return these “foreign” objects. Rust can call them without any knowledge of these objects.</p>

<p>By swapping implementations at link time we can get the same algorithm that works with a different set of structures from different languages. “Link-time polymorphism” seems to be a good name for this concept.</p>

<h2 id="example">Example</h2>

<p>I think it makes sense to start with C, this is what I would like to get eventually:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef STRUCTS_H
#define STRUCTS_H

#include &lt;stddef.h&gt;
#include &lt;stdbool.h&gt;

typedef struct Char
{
    char bytes[4];
} Char;

typedef struct CharList
{
    Char *ptr;
    size_t len;
} CharList;

#endif // STRUCTS_H
</code></pre></div></div>

<p>Now the question is: how can we return this <code class="language-plaintext highlighter-rouge">CharList</code> from our Rust code? We could use bindgen and something-something. No, no and no.</p>

<p>Instead, let’s make Rust think that <code class="language-plaintext highlighter-rouge">CharList</code> on its side is some struct of some (AOT-known) size without any meaningful fields. To do that we need to dump sizes of our structs and make them available in C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include "structs.h"

int main()
{
    printf("CHAR_SIZE=%lu\n", sizeof(Char));
    printf("CHAR_LIST_SIZE=%lu\n", sizeof(CharList));

    return 0;
}
</code></pre></div></div>

<p>We compile it, we run it, and we save its output to a text file called <code class="language-plaintext highlighter-rouge">sizes</code>, here’s what I have locally</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CHAR_SIZE=4
CHAR_LIST_SIZE=16
</code></pre></div></div>

<p>Now our Rust library has to be changed to work in 2 different modes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">native</code> - when Rust structs are used as fields.</li>
  <li><code class="language-plaintext highlighter-rouge">external</code> - when only size of structs is known, but fields and their positions are not.</li>
</ul>

<p>We a new feature to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[features]
default = []

# enables "external" mode, when structs have only size but no fields
external = []
</code></pre></div></div>

<p>and we create a build script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#[cfg(feature = "external")]
fn main() {
    // read path of the `sizes` file from the ENV var
    let sizes_filepath = env!("SIZES_FILEPATH");
    // read `sizes` file
    let sizes = std::fs::read_to_string(sizes_filepath)
                  .expect("SIZES_FILEPATH has to point to a file");

    // parse it line by line and re-write to Rust
    let sizes_rs = sizes
        .lines()
        .map(|line| {
            let parts = line.split("=").collect::&lt;Vec&lt;_&gt;&gt;();
            let name = parts[0];
            let value = parts[1];
            format!("pub(crate) const {}: usize = {};", name, value)
        })
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .join("\n");

    // write it back to sizes.rs
    std::fs::write("src/sizes.rs", sizes_rs).unwrap();
}

#[cfg(not(feature = "external"))]
fn main() {
    // dummy main for "native" mode when no work is needed
}
</code></pre></div></div>

<p>Note: also there should be a <code class="language-plaintext highlighter-rouge">rerun-if-changed</code> line, but for the sake of implicitly I ignore dependencies here.</p>

<p>After running <code class="language-plaintext highlighter-rouge">SIZES_FILEPATH=path/to/sizes cargo build --features=external</code> we get <code class="language-plaintext highlighter-rouge">src/sizes.rs</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">const</span> <span class="n">CHAR_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">const</span> <span class="n">CHAR_LIST_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</code></pre></div></div>

<p>Time to use it! First we wrap existing definition of <code class="language-plaintext highlighter-rouge">Char</code> and <code class="language-plaintext highlighter-rouge">CharList</code> with</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">))]</span>
<span class="k">mod</span> <span class="n">native</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">type</span> <span class="n">Char</span> <span class="o">=</span> <span class="nb">char</span><span class="p">;</span>
  <span class="k">pub</span> <span class="k">type</span> <span class="n">CharList</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">))]</span>
<span class="k">use</span> <span class="nn">native</span><span class="p">::{</span><span class="n">Char</span><span class="p">,</span> <span class="n">CharList</span><span class="p">};</span>
</code></pre></div></div>

<p>(note that we use <code class="language-plaintext highlighter-rouge">not(feature = "external")</code> above, which means “native” mode, they are opposite, and so one feature is enough) and then we add conditionally included <code class="language-plaintext highlighter-rouge">external</code> module with <strong>all</strong> structs that we use:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">)]</span>
<span class="k">mod</span> <span class="n">sizes</span><span class="p">;</span>
<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">)]</span>
<span class="k">mod</span> <span class="n">external</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">sizes</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[repr(C)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Char</span> <span class="p">{</span>
        <span class="n">bytes</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">CHAR_SIZE</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="nd">#[repr(C)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">CharList</span> <span class="p">{</span>
        <span class="n">bytes</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">CHAR_LIST_SIZE</span><span class="p">],</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"external"</span><span class="nd">)]</span>
<span class="k">use</span> <span class="nn">external</span><span class="p">::{</span><span class="n">Char</span><span class="p">,</span> <span class="n">CharList</span><span class="p">};</span>
</code></pre></div></div>

<p>Now if we try to return <code class="language-plaintext highlighter-rouge">CharList</code> from our <code class="language-plaintext highlighter-rouge">foo</code> function we get compilation errors:</p>

<ul>
  <li>there’s no way to construct a <code class="language-plaintext highlighter-rouge">Char</code> from <code class="language-plaintext highlighter-rouge">char</code></li>
  <li>we can’t <code class="language-plaintext highlighter-rouge">collect()</code> <code class="language-plaintext highlighter-rouge">CharList</code> from <code class="language-plaintext highlighter-rouge">Iterator&lt;char&gt;</code></li>
</ul>

<p>How can we implement it? Let’s take a look again at used APIs.</p>

<ol>
  <li>we iterate over given string (it’ll be a <code class="language-plaintext highlighter-rouge">const *u8</code> in C API) - we have it</li>
  <li>we check <code class="language-plaintext highlighter-rouge">c.is_ascii()</code> - that’s also ok</li>
  <li>we need to map <code class="language-plaintext highlighter-rouge">char</code> to foreign <code class="language-plaintext highlighter-rouge">Char</code> - <strong>this requires a constructor</strong></li>
  <li>we need a way to construct <code class="language-plaintext highlighter-rouge">CharList</code> from chars - <strong>this requires methods like <code class="language-plaintext highlighter-rouge">CharList::new()</code> and <code class="language-plaintext highlighter-rouge">CharList::push()</code></strong></li>
  <li>we have a unit-test that needs <code class="language-plaintext highlighter-rouge">CharList::len()</code>, <code class="language-plaintext highlighter-rouge">CharList::at()</code>, <code class="language-plaintext highlighter-rouge">impl PartialEq for Char</code> (to compare individual chars) and <code class="language-plaintext highlighter-rouge">impl std::fmt::Debug for Char</code> (to print LHS/RHS if assertions fails)</li>
</ol>

<p>So, here’s a list of “external” (i.e. in the <code class="language-plaintext highlighter-rouge">mod external {}</code> block) methods we want to have:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Char</span> <span class="p">{</span> <span class="nd">todo!</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For now all of them can return <code class="language-plaintext highlighter-rouge">todo!()</code>, but we’ll implement them later. Time to rewrite our Rust implementation to use these new language-independent functionality:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">char_list</span> <span class="o">=</span> <span class="nn">CharList</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="nb">char</span> <span class="k">in</span> <span class="n">s</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nb">char</span><span class="nf">.is_ascii</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">char_list</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nb">char</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">char_list</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"abc😋中国"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">chars</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="sc">'😋'</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="sc">'中'</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.at</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="sc">'国'</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That was easy, right? Way less elegant but still easy.</p>

<h2 id="implementing-bindings">Implementing bindings</h2>

<p>At this point you might have a guess on what’s going to happen next. We are going to define a bunch of external C-ABI functions and blindly call them in all <code class="language-plaintext highlighter-rouge">todo!()</code> places. Later these functions will be implemented by the bindings library on C side:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">char__new</span><span class="p">(</span><span class="n">c1</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">c2</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">c3</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">c4</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Char</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">char__at</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">Char</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">byte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char__at</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
        <span class="n">c</span><span class="nf">.encode_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">);</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char__new</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">Char</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">c</span><span class="nf">.byte_at</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">zero_idx</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">bytes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">zero_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">zero_idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.chars</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">chars</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">idx</span><span class="p">|</span> <span class="k">self</span><span class="nf">.byte_at</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span><span class="nf">.byte_at</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="nn">char</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">char_list__new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">CharList</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CharList</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Char</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">CharList</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">CharList</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">const</span> <span class="n">Char</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__new</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Char</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ok, now we have a contract. Rust relies on it, but C so far doesn’t provide anything. If we try to run tests with <code class="language-plaintext highlighter-rouge">--features=external</code> we get a bunch of linkage errors, which is 100% expected. Time to implement in on C side.</p>

<p>This is a “shared” version that we’ll use for C++/Ruby/Node.JS bindings</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_H
#define BINDINGS_H
</span>
<span class="cp">#include DEFINITIONS_FILE
</span>
<span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
<span class="cp">#endif
</span>
    <span class="n">Char_BLOB</span> <span class="n">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">char__bytes</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

    <span class="n">CharList_BLOB</span> <span class="n">char_list__new</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Char_BLOB</span> <span class="n">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
</span>
<span class="cp">#endif // BINDINGS_H
</span></code></pre></div></div>

<p>It includes <code class="language-plaintext highlighter-rouge">DEFINITIONS_FILE</code> because we want it to be generic (and we’ll pass it as a dynamic define via <code class="language-plaintext highlighter-rouge">-D</code> flag). Also you might notice that methods take/return <code class="language-plaintext highlighter-rouge">&lt;type&gt;_BLOB</code> type, that’s because we want to pass C-compatible types. C types are C-compatible, and so we make another file <code class="language-plaintext highlighter-rouge">bindings-support.h</code> with</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_SUPPORT_H
#define BINDINGS_SUPPORT_H
</span>
<span class="cp">#include</span> <span class="cpf">"structs.h"</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="n">Char</span> <span class="n">Char_BLOB</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">CharList</span> <span class="n">CharList_BLOB</span><span class="p">;</span>

<span class="cp">#endif // BINDINGS_SUPPORT_H
</span></code></pre></div></div>

<p>… to create aliases. For C++ we’ll have to convert our classes to something C understands (I’ll cover it later).</p>

<p>Implementation time!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Char_BLOB</span> <span class="nf">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Char_BLOB</span><span class="p">){.</span><span class="n">bytes</span> <span class="o">=</span> <span class="p">{</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">}};</span>
<span class="p">}</span>
<span class="kt">uint8_t</span> <span class="nf">char__at</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">CharList_BLOB</span> <span class="nf">char_list__new</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">CharList_BLOB</span><span class="p">){.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Char</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Char</span><span class="p">));</span>
        <span class="n">free</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">size_t</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Char_BLOB</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We compile it</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang c-bindings/bindings.c <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-o</span> c-bindings/all.o
<span class="nv">$ </span>ar rc c-bindings/libbindings.a c-bindings/all.o
</code></pre></div></div>

<p>And change our <code class="language-plaintext highlighter-rouge">build.rs</code> script to link with it (the purpose of these env variables is to make external primitives implementation “pluggable”):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">external_lib_path</span> <span class="o">=</span> <span class="nd">env!</span><span class="p">(</span><span class="s">"EXTERNAL_LIB_PATH"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-search={}"</span><span class="p">,</span> <span class="n">external_lib_path</span><span class="p">);</span>

<span class="k">let</span> <span class="n">external_lib_name</span> <span class="o">=</span> <span class="nd">env!</span><span class="p">(</span><span class="s">"EXTERNAL_LIB_NAME"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-lib=static={}"</span><span class="p">,</span> <span class="n">external_lib_name</span><span class="p">);</span>
</code></pre></div></div>

<p>And now we can run tests:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>rust-lib
<span class="nv">$ EXTERNAL_LIB_PATH</span><span class="o">=</span><span class="s2">"../c-bindings"</span> <span class="se">\</span>
    <span class="nv">EXTERNAL_LIB_NAME</span><span class="o">=</span><span class="s2">"bindings"</span> <span class="se">\</span>
    <span class="nv">SIZES_FILEPATH</span><span class="o">=</span><span class="s2">"../c-bindings/sizes"</span> <span class="se">\</span>
    cargo <span class="nb">test</span> <span class="nt">--features</span><span class="o">=</span>external
</code></pre></div></div>

<p>and we get 1 passing test!</p>

<h2 id="c-bindings-quickly">C++ bindings, quickly</h2>

<p>I want this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef STRUCTS_HPP
#define STRUCTS_HPP
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Char</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">Char</span><span class="p">()</span> <span class="o">:</span> <span class="n">Char</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">explicit</span> <span class="n">Char</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c4</span><span class="p">)</span> <span class="o">:</span> <span class="n">bytes</span><span class="p">{</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">}</span> <span class="p">{}</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">size</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">size</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">as_string</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">CharList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Char</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cp">#endif // STRUCTS_HPP
</span></code></pre></div></div>

<p>C functions are the same, but these classes are incompatible with C FFI, so we need to define our BLOBs:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_SUPPORT_HPP
#define BINDINGS_SUPPORT_HPP
</span>
<span class="cp">#include</span> <span class="cpf">"structs.hpp"</span><span class="cp">
</span>
<span class="cp">#define DECLARE_BLOB(T)               \
    extern "C"                        \
    {                                 \
        struct T##_BLOB               \
        {                             \
            uint8_t bytes[sizeof(T)]; \
        };                            \
    }                                 \
    union T##_UNION                   \
    {                                 \
        T value;                      \
        T##_BLOB blob;                \
                                      \
        ~T##_UNION() {}               \
        T##_UNION()                   \
        {                             \
            new (&amp;value) T();         \
        }                             \
    };                                \
    T##_BLOB PACK_##T(T value)        \
    {                                 \
        T##_UNION u;                  \
        u.value = std::move(value);   \
        return u.blob;                \
    };                                \
    T UNPACK_##T(T##_BLOB blob)       \
    {                                 \
        T##_UNION u;                  \
        u.blob = blob;                \
        return std::move(u.value);    \
    }
</span>
<span class="n">DECLARE_BLOB</span><span class="p">(</span><span class="n">Char</span><span class="p">);</span>
<span class="n">DECLARE_BLOB</span><span class="p">(</span><span class="n">CharList</span><span class="p">);</span>

<span class="cp">#endif // BINDINGS_SUPPORT_HPP
</span></code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">DECLARE_BLOB</code> macro for given <code class="language-plaintext highlighter-rouge">Type</code> defines:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Type_BLOB</code> struct that is C-compatible</li>
  <li><code class="language-plaintext highlighter-rouge">Type_UNION</code> union that is a union of <code class="language-plaintext highlighter-rouge">Type</code> and <code class="language-plaintext highlighter-rouge">Type_BLOB</code></li>
  <li><code class="language-plaintext highlighter-rouge">PACK_Type</code> function that converts an instance of <code class="language-plaintext highlighter-rouge">Type</code> to <code class="language-plaintext highlighter-rouge">Type_BLOB</code> so we can return if <strong>from</strong> <code class="language-plaintext highlighter-rouge">extern "C"</code> function</li>
  <li><code class="language-plaintext highlighter-rouge">UNPACK_Type</code> function that converts <code class="language-plaintext highlighter-rouge">Type_BLOB</code> to <code class="language-plaintext highlighter-rouge">Type</code> so we can “unpack” blob that is passed <strong>to</strong> <code class="language-plaintext highlighter-rouge">extern "C"</code> function</li>
</ul>

<p>This conversion with <code class="language-plaintext highlighter-rouge">union</code> is an equivalent of <code class="language-plaintext highlighter-rouge">std::mem::transmute</code> from Rust (C++20 has <code class="language-plaintext highlighter-rouge">std::bit_cast</code> for that, but <code class="language-plaintext highlighter-rouge">union</code> shows better what happens under the hood). Also we <code class="language-plaintext highlighter-rouge">std::move</code> the value to and from <code class="language-plaintext highlighter-rouge">union</code> on conversion, this is important (otherwise, copyable types are copied).</p>

<p>However, it has a requirement for <code class="language-plaintext highlighter-rouge">T</code> to be both movable and constructible with no args. We could do <code class="language-plaintext highlighter-rouge">std::memset(this, 0, sizeof(T))</code>, but some move constructors/assignment operators swap fields of <code class="language-plaintext highlighter-rouge">this</code> and given <code class="language-plaintext highlighter-rouge">other</code>, and so sometimes it’s invalid to call a destructor on an object full of zeroes (of course it totally depends on the structure of the object).</p>

<p>With these blobs implementing binding functions is trivial:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
    <span class="n">Char_BLOB</span> <span class="n">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PACK_Char</span><span class="p">(</span><span class="n">Char</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">char__at</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Char</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">CharList_BLOB</span> <span class="n">char_list__new</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PACK_CharList</span><span class="p">(</span><span class="n">CharList</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="p">((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">UNPACK_Char</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">Char_BLOB</span> <span class="n">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PACK_Char</span><span class="p">(((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We compile and build a static library:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang++ <span class="nt">-std</span><span class="o">=</span>c++17 cpp-bindings/bindings.cpp <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-fPIE</span> <span class="nt">-o</span> cpp-bindings/all.o
<span class="nv">$ </span>ar rc cpp-bindings/libbindings.a cpp-bindings/all.o
</code></pre></div></div>

<p>One extra step that is specific to C++ libraries - we need to link with C++ runtime, so this extra code goes to <code class="language-plaintext highlighter-rouge">Cargo.toml</code> and <code class="language-plaintext highlighter-rouge">build.rs</code> respectively:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[features]</span>
<span class="c"># enables linking with C++ runtime</span>
<span class="py">link-with-cxx-runtime</span> <span class="p">=</span> <span class="p">[]</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">feature</span> <span class="o">=</span> <span class="s">"link-with-cxx-runtime"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">target_os</span> <span class="o">=</span> <span class="s">"linux"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-lib=dylib=stdc++"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-lib=dylib=c++"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally we can run our tests:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">EXTERNAL_LIB_PATH</span><span class="o">=</span><span class="s2">"../cpp-bindings"</span> <span class="se">\</span>
  <span class="nv">EXTERNAL_LIB_NAME</span><span class="o">=</span><span class="s2">"bindings"</span> <span class="se">\</span>
  <span class="nv">SIZES_FILEPATH</span><span class="o">=</span><span class="s2">"../cpp-bindings/sizes"</span> <span class="se">\</span>
  cargo <span class="nb">test</span> <span class="nt">--features</span><span class="o">=</span>external,link-with-cxx-runtime
</code></pre></div></div>

<h2 id="ruby-bindings-also-quickly">Ruby bindings, also quickly</h2>

<p>We want our <code class="language-plaintext highlighter-rouge">Char</code> to be a Ruby <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">CharList</code> to be an <code class="language-plaintext highlighter-rouge">Array</code>, in Ruby C API they are both represented as <code class="language-plaintext highlighter-rouge">VALUE</code> (that is technically a pointer to a tagged union (unless it’s a small number/<code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code>/<code class="language-plaintext highlighter-rouge">nil</code>, then it’s basically the value itself)).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef STRUCTS_H
#define STRUCTS_H
</span>
<span class="cp">#include</span> <span class="cpf">&lt;ruby.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="n">VALUE</span> <span class="n">Char</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">VALUE</span> <span class="n">CharList</span><span class="p">;</span>

<span class="cp">#endif // STRUCTS_H
</span></code></pre></div></div>

<p>and so sizes are these:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CHAR_SIZE=8
CHAR_LIST_SIZE=8
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">VALUE</code> is simply an alias to <code class="language-plaintext highlighter-rouge">unsigned long</code> on x86_64, so blobs are aliases:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef BINDINGS_SUPPORT_H
#define BINDINGS_SUPPORT_H
</span>
<span class="cp">#include</span> <span class="cpf">"structs.h"</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="n">Char</span> <span class="n">Char_BLOB</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">CharList</span> <span class="n">CharList_BLOB</span><span class="p">;</span>

<span class="cp">#endif // BINDINGS_SUPPORT_H
</span></code></pre></div></div>

<p>Bindings implementation (uses Ruby C API):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bindings-support.h"</span><span class="cp">
</span>
<span class="n">Char_BLOB</span> <span class="nf">char__new</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c3</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">c4</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">char</span><span class="p">)</span><span class="n">c1</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">c2</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">c3</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">c4</span><span class="p">};</span>
    <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c3</span><span class="p">)</span> <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c4</span><span class="p">)</span> <span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">rb_utf8_str_new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">uint8_t</span> <span class="nf">char__at</span><span class="p">(</span><span class="k">const</span> <span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">this</span> <span class="o">=</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">StringValuePtr</span><span class="p">(</span><span class="n">this</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">CharList_BLOB</span> <span class="nf">char_list__new</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_ary_new</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__push</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Char_BLOB</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">rb_ary_push</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">size_t</span> <span class="nf">char_list__len</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_array_len</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Char_BLOB</span> <span class="nf">char_list__at</span><span class="p">(</span><span class="k">const</span> <span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_ary_entry</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looks similar to C++ bindings, right? Ok, can we run Rust tests with Ruby primitives? Unfortunately, no. These methods expect Ruby VM to be up and running and embedding Ruby is not something many Ruby developers do.</p>

<p>Instead, we need to re-compile it to a dynamically-loaded library that (once loaded) registers a <code class="language-plaintext highlighter-rouge">foo</code> method that takes a string, passes its <code class="language-plaintext highlighter-rouge">const char *</code> pointer to our <code class="language-plaintext highlighter-rouge">foo</code> function defined in Rust and returns <code class="language-plaintext highlighter-rouge">CharList</code> back to Ruby space.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ruby.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"structs.h"</span><span class="cp">
</span>
<span class="n">CharList</span> <span class="nf">c_foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="n">VALUE</span> <span class="nf">rb_foo</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
    <span class="n">Check_Type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">T_STRING</span><span class="p">);</span>
    <span class="n">CharList</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">c_foo</span><span class="p">(</span><span class="n">StringValueCStr</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">chars</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Init_foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">rb_define_global_function</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="n">rb_foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">c_foo</code> is defined on Rust side with C linkage:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">c_foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ffi</span><span class="p">::</span><span class="nn">CStr</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="nf">.to_str</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">};</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now if we compile it to <code class="language-plaintext highlighter-rouge">.bundle</code> (this is for Mac, on Linux and Windows it’s a <code class="language-plaintext highlighter-rouge">.so</code> extension)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-Ipath</span>/to/ruby/includes ruby-bindings/init.c <span class="nt">-c</span> <span class="nt">-o</span> ruby-bindings/init.o
<span class="nv">$ </span>clang <span class="nt">-Ipath</span>/to/ruby/includes ruby-bindings/bindings.c <span class="nt">-c</span> <span class="nt">-o</span> ruby-bindings/bindings.o
<span class="nv">$ </span>ar rc ruby-bindings/libbindings.a ruby-bindings/bindings.o

<span class="nv">$ </span><span class="nb">cd </span>rust-lib
<span class="nv">$ EXTERNAL_LIB_PATH</span><span class="o">=</span><span class="s2">"../ruby-bindings"</span> <span class="se">\</span>
    <span class="nv">EXTERNAL_LIB_NAME</span><span class="o">=</span>bindings <span class="se">\</span>
    <span class="nv">SIZES_FILEPATH</span><span class="o">=</span><span class="s2">"../ruby-bindings/sizes"</span> <span class="se">\</span>
    cargo build <span class="nt">--features</span><span class="o">=</span>external
<span class="nv">$ </span><span class="nb">cd</span> ..

<span class="nv">$ </span>clang <span class="se">\</span>
    <span class="nt">-dynamic</span> <span class="se">\</span>
    <span class="nt">-bundle</span> <span class="se">\</span>
    <span class="nt">-o</span> ruby-bindings/foo.bundle <span class="se">\</span>
    ruby-bindings/init.o rust-foo/librust-foo-rust.a <span class="se">\</span>
    <span class="nt">-Wl</span>,-undefined,dynamic_lookup
</code></pre></div></div>

<p>.. we get <code class="language-plaintext highlighter-rouge">ruby-bindings/foo.bundle</code> that can be imported from Ruby:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ruby <span class="nt">-r</span>./ruby-bindings/foo <span class="nt">-e</span> <span class="s1">'p foo("abc😋中国")'</span>
<span class="o">[</span><span class="s2">"😋"</span>, <span class="s2">"中"</span>, <span class="s2">"国"</span><span class="o">]</span>
</code></pre></div></div>

<p>In fact there are many more options that are passed to <code class="language-plaintext highlighter-rouge">clang</code> above, check out <a href="https://github.com/iliabylich/writing-bindings-upside-down">the repo</a> if you want to try it yourself.</p>

<h2 id="memory-leaks">Memory leaks</h2>

<p>All versions above have a memory leak that can be easily identified by compiling with</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">detect_leaks</span><span class="o">=</span>1 <span class="nv">CXXFLAGS</span><span class="o">=</span><span class="s2">"-fsanitize=address"</span> clang++
</code></pre></div></div>

<p>or (to track it when running Rust tests)</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">RUSTFLAGS</span><span class="o">=</span><span class="s2">"-Z sanitizer=address"</span> ... cargo <span class="nb">test</span>
</code></pre></div></div>

<p>(On Mac make sure to use <code class="language-plaintext highlighter-rouge">clang</code> from Homebrew, version that ships with OS doesn’t support ASAN)</p>

<p>Running tests with this options shows that we have a leak somewhere in</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Direct leak of 96 byte(s) in 1 object(s) allocated from:
...
    #9 0x105905990 in char_list__push bindings.cpp:34
    #10 0x105904c04 in rust_foo::external::CharList::push::hf5bdccdb764b0c62 lib.rs:91
    #11 0x1059043bb in rust_foo::foo::hf9387b4435c6f8b6 lib.rs:108
    #12 0x10590442d in c_foo lib.rs:117
    #13 0x1059006e8 in cpp_foo(char const*) test.cpp:14
    #14 0x105900a10 in main test.cpp:24
</code></pre></div></div>

<p>And the reason is that our <code class="language-plaintext highlighter-rouge">CharList</code> is heap-allocated, but it has no destructor on the Rust side. To fix it we need to add 2 more functions to our bindings:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Char</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">CharList</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char__drop</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">CharList</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Of course, we need to add it to <code class="language-plaintext highlighter-rouge">bindings.h</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifdef __cplusplus
extern "C"
{
#endif

    void char__drop(Char_BLOB *self);
    void char_list__drop(CharList_BLOB *self);

#ifdef __cplusplus
}
#endif
</code></pre></div></div>

<p>Here’s a C implementation (depending on your implementation <code class="language-plaintext highlighter-rouge">char__drop</code> could to something):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Char has no allocations</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C++ implementation:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Char has no allocations</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="n">CharList</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">vector</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ruby:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">char__drop</span><span class="p">(</span><span class="n">Char_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Ruby has GC</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">char_list__drop</span><span class="p">(</span><span class="n">CharList_BLOB</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// noop, Ruby has GC</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="performance">Performance</h2>

<p>How about performance? When we compile with Rust primitives we use LTO and so things from Rust standard library can be optimized together with our code. Luckily, there’s a way to do that for external primitives too.</p>

<p>I’d like to demonstrate it on the low level, first let’s compile everything to LLVM IR:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang-13 <span class="nt">-S</span> <span class="nt">-emit-llvm</span> c-bindings/bindings.c <span class="nt">-o</span> c-bindings/bindings.ll
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> c-bindings/bindings.ll
define dso_local i32 @char__new<span class="o">(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span class="o">)</span> <span class="c">#0 {</span>
define dso_local zeroext i8 @char__at<span class="o">(</span>%struct.Char<span class="k">*</span> %0, i8 zeroext %1<span class="o">)</span> <span class="c">#0 {</span>
define dso_local void @char__drop<span class="o">(</span>%struct.Char<span class="k">*</span> %0<span class="o">)</span> <span class="c">#0 {</span>
</code></pre></div></div>

<p>^ that was the file with bindings implementation, C part. It defines all <code class="language-plaintext highlighter-rouge">char__</code> functions.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>rust-foo
<span class="nv">$ </span>rustc <span class="nt">--crate-name</span> rust_foo src/lib.rs <span class="nt">--crate-type</span> staticlib <span class="nt">--emit</span><span class="o">=</span>llvm-ir <span class="nt">--cfg</span> <span class="s1">'feature="default"'</span> <span class="nt">--cfg</span> <span class="s1">'feature="external"'</span>
<span class="nv">$ </span><span class="nb">cd</span> ..
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> rust-foo/rust_foo.ll
  %8 <span class="o">=</span> call i32 @char__new<span class="o">(</span>i8 zeroext %_8, i8 zeroext %_10, i8 zeroext %_12, i8 zeroext %_14<span class="o">)</span>
<span class="nb">declare </span>i32 @char__new<span class="o">(</span>i8 zeroext, i8 zeroext, i8 zeroext, i8 zeroext<span class="o">)</span> unnamed_addr <span class="c">#1</span>
</code></pre></div></div>

<p>^ that was the Rust part. It declares (as external) and calls some of our <code class="language-plaintext highlighter-rouge">char__</code> functions.</p>

<p>Let’s link them together:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llvm-link-13 c-bindings/bindings.ll rust-foo/rust_foo.ll <span class="nt">-S</span> <span class="nt">-o</span> merged.ll
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> merged.ll
define dso_local i32 @char__new<span class="o">(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span class="o">)</span> <span class="c">#0 {</span>
define dso_local zeroext i8 @char__at<span class="o">(</span>%struct.Char<span class="k">*</span> %0, i8 zeroext %1<span class="o">)</span> <span class="c">#0 {</span>
define dso_local void @char__drop<span class="o">(</span>%struct.Char<span class="k">*</span> %0<span class="o">)</span> <span class="c">#0 {</span>
  %8 <span class="o">=</span> call i32 @char__new<span class="o">(</span>i8 zeroext %_8, i8 zeroext %_10, i8 zeroext %_12, i8 zeroext %_14<span class="o">)</span>
</code></pre></div></div>

<p>These 2 modules have been merged, time to optimize them together:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>opt-13 <span class="nt">-O3</span> merged.ll <span class="nt">-S</span> <span class="nt">-o</span> optimized.ll
<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">"char__"</span> optimized.ll
define dso_local i32 @char__new<span class="o">(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span class="o">)</span> local_unnamed_addr <span class="c">#0 {</span>
define dso_local zeroext i8 @char__at<span class="o">(</span>%struct.Char<span class="k">*</span> nocapture <span class="nb">readonly</span> %0, i8 zeroext %1<span class="o">)</span> local_unnamed_addr <span class="c">#1 {</span>
define dso_local void @char__drop<span class="o">(</span>%struct.Char<span class="k">*</span> nocapture %0<span class="o">)</span> local_unnamed_addr <span class="c">#0 {</span>
</code></pre></div></div>

<p>Now we have only definitions, actual calls have been successfully inlined. Now we can compile it to an object file to see a final result:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llc-13 <span class="nt">-O3</span> <span class="nt">-filetype</span><span class="o">=</span>obj optimized.ll <span class="nt">-o</span> optimized.o
<span class="nv">$ </span>clang-13 test.c optimized.o <span class="nt">-O3</span> <span class="nt">-o</span> test-runner
<span class="nv">$ </span>objdump <span class="nt">-D</span> test-runner | <span class="nb">grep</span> <span class="s2">"call"</span> | <span class="nb">grep</span> <span class="s2">"char__"</span>
<span class="c"># no output</span>
<span class="nv">$ </span>objdump <span class="nt">-D</span> test-runner | <span class="nb">grep</span> <span class="s2">"call"</span> | <span class="nb">grep</span> <span class="s2">"char_list"</span>
  406bba: e8 01 01 00 00        callq  406cc0 &lt;char_list__drop&gt;
  406d21: e8 fa fe ff ff        callq  406c20 &lt;char_list__new&gt;
</code></pre></div></div>

<p>As you can see all <code class="language-plaintext highlighter-rouge">char__new</code> or <code class="language-plaintext highlighter-rouge">char__at</code> calls have been inlined, <code class="language-plaintext highlighter-rouge">char_list__drop</code> and <code class="language-plaintext highlighter-rouge">char_list__new</code> haven’t, because of how LLVM decides on what should or should not be inlined. Anyway, it works.</p>

<p>Of course, there’s an easier way to get the same result:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">RUSTFLAGS</span><span class="o">=</span><span class="s2">"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld"</span>
<span class="nv">$ </span><span class="nb">export </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-flto"</span>
</code></pre></div></div>

<p>^ this should be enough to get the same result. By adding <code class="language-plaintext highlighter-rouge">-Clinker-plugin-lto</code> we ask Rust to compile all object files to LLVM IR:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ RUSTFLAGS</span><span class="o">=</span><span class="s2">"-Clinker-plugin-lto -Clinker=clang-13 -Clink-arg=-fuse-ld=lld"</span> cargo build <span class="nt">--features</span><span class="o">=</span>external

<span class="nv">$ </span><span class="nb">mkdir </span>objects
<span class="nv">$ </span><span class="nb">cd </span>objects
<span class="nv">$ </span>ar x ../target/release/librust_foo.a
<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span>
<span class="c"># a ton of object files, that's what static library is about</span>

<span class="nv">$ </span>file <span class="k">*</span>.o

... snip ...
popcountti2.o:                                                                              ELF 64-bit LSB relocatable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, with debug_info, not stripped
powixf2.o:                                                                                  ELF 64-bit LSB relocatable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, with debug_info, not stripped
rust_foo-0f1418f7365bf15b.2nf5cb5qlud0f6qs.rcgu.o:                                          LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.0.rcgu.o:                                   LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.1.rcgu.o:                                   LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.2.rcgu.o:                                   LLVM IR bitcode
rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.3.rcgu.o:                                   LLVM IR bitcode
rustc_demangle-7f98f837d3579544.rustc_demangle.5563b4d3-cgu.0.rcgu.o:                       ELF 64-bit LSB relocatable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, with debug_info, not stripped
... snip ...
</code></pre></div></div>

<p>Rust standard library is compiled directly to object files, but our code is <code class="language-plaintext highlighter-rouge">LLVM IR bitcode</code>. <strong>This way we can get zero-cost bindings defined externally</strong>.</p>

<p>Of course, it’s not gonna work with Ruby or NodeJS, both of them have a giant <code class="language-plaintext highlighter-rouge">libruby.so</code> (or <code class="language-plaintext highlighter-rouge">libnode.so</code>) that defines all functions and constants that your extension relies on. The extension itself is compiled with <code class="language-plaintext highlighter-rouge">-Wl,-undefined,dynamic_lookup</code> and symbol lookup is performed at runtime. I feel like technically it’s possible, the entire Ruby/NodeJS runtime could be compiled to a static <code class="language-plaintext highlighter-rouge">libruby.a</code>/<code class="language-plaintext highlighter-rouge">libnode.a</code> that defines all VM objects as external (because that’s a singleton that we need to hook into), but all functions can provide their implementation (of course, in LLVM IR format), and so they can be inlined into our bindings implementation. I haven’t experimented with it yet, and honestly I’m not going to :) If you know anything about existing discussions around it, please, ping me on Twitter.</p>

<h2 id="the-whole-picture-again">The whole picture, again</h2>

<p>Demo repo is available <a href="https://github.com/iliabylich/writing-bindings-upside-down">here</a></p>

<p>To sum up:</p>

<ol>
  <li>Library maintainers can change their library to accept <strong>“pluggable” external primitives</strong>. If no external primitives provided native version is used.</li>
  <li>Library maintainers can <strong>provide headers</strong> that define what should be provided (i.e. a set of functions that take/return primitives). This is the definition of the contract.</li>
  <li>Authors of bindings <strong>define structure as they want</strong> (i.e. instead of vector they are free to use linked lists of hashmaps)</li>
  <li>Authors of bindings <strong>implement functions defined in headers</strong>. This is the implementation of the contract.</li>
  <li>To get full bindings the library is linked together with bindings. There might be a need to build a wrapper around functions defined in the library, but that’s trivial as these functions return objects that are “native” for bindings.</li>
</ol>

<p>Pros:</p>

<ul>
  <li>To implement bindings you don’t wrap every single function, instead you focus on implementing types and contract around them. Moreover, the contract is quite simple and many languages have a rich standard library, so implementing these library-defined functions can be very easy.</li>
  <li>Libraries can provide headers, so it’s hard to make a mistake.</li>
  <li>Libraries usually have a decent test suite, it can be used to verify bindings for correctness and memory leaks.</li>
</ul>

<p>Cons:</p>

<ul>
  <li>The library needs quite a lot of changes to support “external” primitives. That’s not an easy task.</li>
  <li>The library needs to ship with a “reference implementation”, to verify that existing external functions are enough to build everything.</li>
  <li>There are minor differences between standard types in languages, for example C++ has a small string optimization, and small strings are not “containers”. On the other side Rust strings are true containers, and library developers may expect “external” string to be a container, too, but on the bindings side <code class="language-plaintext highlighter-rouge">std::string</code> from C++ doesn’t fully match the contract (i.e. you can’t borrow a <code class="language-plaintext highlighter-rouge">char *</code> from <code class="language-plaintext highlighter-rouge">std::string</code> and expect it to live as long as the string lives). In some cases it can become really hard to track and fix.</li>
</ul>

</div>


  <div class="comments">
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
          this.page.url = document.location.href;  // Replace PAGE_URL with your page's canonical URL variable
          this.page.identifier = document.location.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://ibylich-myblog.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>


<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/11/22/lib-ruby-parser.html">
            lib-ruby-parser
            <small>22 Nov 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/01/25/evaluating-ruby-in-ruby.html">
            Evaluating Ruby in Ruby
            <small>25 Jan 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2018/07/18/my-favorite-parts-of-ruby.html">
            My favorite parts of Ruby
            <small>18 Jul 2018</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>
  </body>
</html>
