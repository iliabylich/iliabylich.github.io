<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon-precomposed sizes=192x192 href=/icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel=stylesheet><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Writing bindings upside down"><title>Writing bindings upside down | Ilya Bylich - Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.2b907de83c90cfa7c3d79a41f7775098387ed032abb1f83426627b3438329fdc.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/>Home</a></li><li><a tabindex=-1 class=menu-link href=https://github.com/iliabylich>GitHub</a></li><li><a tabindex=-1 class=menu-link href=https://twitter.com/IlyaBylich>Twitter</a></li><li><a tabindex=-1 class=menu-link href=mailto:ibylich@gmail.com>Email me</a></li><li><a tabindex=-1 class=menu-link href=/index.xml>RSS</a></li></ul></nav><div id=single-header><h1>Writing bindings upside down</h1><div id=single-meta><span class=datesub>Dec 28, 2021</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://iliabylich.github.io/tags/rust/>#rust</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/c/>#c</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/c++/>#c++</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/ruby/>#ruby</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/javascript/>#javascript</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/node/>#node</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/bindings/>#bindings</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/llvm/>#llvm</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/lto/>#lto</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#bindings>Bindings</a></li><li><a href=#traditional-way>Traditional way</a></li><li><a href=#slow-but-more-reliable-solution>Slow but more reliable solution</a></li><li><a href=#a-demo-small-but-representative>A demo, small but representative</a></li><li><a href=#foreign-implementation>&ldquo;Foreign&rdquo; implementation</a></li><li><a href=#example>Example</a></li><li><a href=#implementing-bindings>Implementing bindings</a></li><li><a href=#c-bindings-quickly>C++ bindings, quickly</a></li><li><a href=#ruby-bindings-also-quickly>Ruby bindings, also quickly</a></li><li><a href=#memory-leaks>Memory leaks</a></li><li><a href=#performance>Performance</a></li><li><a href=#the-whole-picture-again>The whole picture, again</a></li></ul></nav></aside><main><h2 id=bindings>Bindings</h2><p>Quite a long time ago I started writing C/C++/Ruby/Node.js/WASM bindings so I could call <a href=https://github.com/lib-ruby-parser/lib-ruby-parser target=_blank rel="noreferrer nofollow">my Rust project</a>
from those languages. It is a Ruby language parser.</p><p>I tried multiple ways and found one that is very (VERY) controversial, but I think it deserves it&rsquo;s own article.</p><h2 id=traditional-way>Traditional way</h2><p>Let&rsquo;s say you have a library in C. Just for simplicity, Rust is not special here.</p><p><p class=imgp><img loading=lazy src=/writing-bindings-upside-down-1.png alt=library-puzzle-piece.png></p></p><p>How can you use it in C++? A very simple solution is to wrap your header file with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// C bindings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><p>then change your includes to be slightly more compatible with C++ (<code>stdio.h</code> -> <code>cstdio</code> etc) and call it a day.</p><ul><li>Pros: very simple.</li><li>Cons: your API has raw pointers, raw array/string structures that expose everything and are error-prone when used.</li></ul><p>How can you use it in Ruby/Node.js? Again, let&rsquo;s start with &ldquo;traditional&rdquo; solution. For Ruby take your C library, for Node.js take C++ library and &ldquo;wrap&rdquo; it using a &ldquo;native&rdquo; extension.</p><p>It is possible to &ldquo;attach&rdquo; any arbitrary data to Ruby/Node.js objects</p><ul><li>Ruby has <a href=https://docs.ruby-lang.org/en/2.4.0/extension_rdoc.html#label-C+struct+to+Ruby+object target=_blank rel="noreferrer nofollow"><code>TypedData_Wrap_Struct</code> function</a></li><li>Node.js has <a href=https://github.com/nodejs/node-addon-api/blob/main/doc/external.md target=_blank rel="noreferrer nofollow"><code>Napi::External</code></a></li></ul><p>In both cases it&rsquo;s possible to get pointer to attached data at any moment, both require you to specify a function that GC calls to free attached data.</p><p>Pros: still quite simple.
Cons: really error-prone, libraries designed this way quite frequently have memory leaks and segfaults.</p><p><p class=imgp><img loading=lazy src=/writing-bindings-upside-down-2.png alt=traditional-bindings.png></p></p><h2 id=slow-but-more-reliable-solution>Slow but more reliable solution</h2><p>Of course it&rsquo;d be unfair to not mention that it&rsquo;s always possible to type-cast structures from low-level language to high-level:</p><ol><li>C -> C++ - by converting C structs to pretty C++ classes with smart pointers and collections</li><li>C -> Ruby - by creating Ruby objects from C structs</li><li>C++ -> Node.js - by creating JavaScript objects from C++ classes</li></ol><ul><li>Pros: this way it&rsquo;s actually less dangerous. You can cover it with unit-tests and check with ASAN/Valgrind/LSAN that you have no segfaults, memory leaks or incorrect memory access.</li><li>Cons: you have to copy a bunch of data and it will hurt performance. Many of your methods have to be rewritten to target language OR you have convert C++/Ruby/JS objects back to C to call original C functions.</li></ul><p>A small note on copying: it is possible to &ldquo;move&rdquo; some data in certain cases and languages:</p><ul><li>Ruby has a family of <code>rb_str_new_*</code> functions, but literally all of them take <code>const char *ptr, size_t len</code>, however, it&rsquo;s possible to create a &ldquo;dummy&rdquo; heap-allocated Ruby <code>String</code> and set <code>ptr</code> and <code>len</code> on it. It is possible only (and only) because internals of all Ruby objects (including <code>String</code>) are fully exposed on C layer.</li><li>Node.js has a <a href=https://github.com/nodejs/node-addon-api/blob/main/doc/string.md target=_blank rel="noreferrer nofollow"><code>Napi::String</code></a>
class for that but it takes either a C++ <code>const std::string&</code> or <code>const char *</code>. From what I know internals are not available, so copying is necessary.</li><li>C++ has a <code>std::string</code> that does not have a &ldquo;take-and-store-what&rsquo;s-given&rdquo; constructor that takes a <code>char *</code> (I would call it a &ldquo;move&rdquo; constructor, but this name has a different meaning in C++ :D). There&rsquo;s a <code>const char *</code> constructor that performs copying. Of course it&rsquo;s possible to create a compiler-dependent type-casting to a class with the same set of fields, move pointer + <code>len</code> + capacity there and convert it back to <code>std::string</code>. It&rsquo;s ugly, but definitely doable.</li></ul><h2 id=a-demo-small-but-representative>A demo, small but representative</h2><p>Let&rsquo;s start. I&rsquo;d like to demonstrate a different solution on a tiny example. Let&rsquo;s write a micro-library that has several Rust structs, something like a function that, let&rsquo;s say, takes a <code>String</code> and returns a <code>Vec</code> of all non-ASCII chars. It&rsquo;s called <code>foo</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    s.chars().filter(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>c.is_ascii()).collect()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_foo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> foo(<span style=color:#e6db74>&#34;abc😋中国def&#34;</span>);
</span></span><span style=display:flex><span>    assert_eq!(chars, vec![<span style=color:#e6db74>&#39;😋&#39;</span>, <span style=color:#e6db74>&#39;中&#39;</span>, <span style=color:#e6db74>&#39;国&#39;</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are two structs that belong to Rust world exclusively: <code>Vec</code> and <code>char</code>.</p><h2 id=foreign-implementation>&ldquo;Foreign&rdquo; implementation</h2><p>Can we expose these two types in C? <code>Vec</code> is defined in Rust standard library and it has <code>#[repr(Rust)]</code>, <code>char</code> is a 4-byte structure with no public layout.</p><p>We could define our own <code>repr(C)</code> structs together with <code>impl From&lt;RustType> for CType</code> and call <code>.into()</code>, but that&rsquo;s not really the goal here.</p><p>Let&rsquo;s think for a moment about C++, Ruby and Node:</p><ul><li>In C++ I&rsquo;d really like to use <code>std::vector</code> for <code>Vec</code> and <code>std::string</code> for <code>char</code>.</li><li>For both Ruby and Node.js I want <code>Array</code> for <code>Vec</code> and <code>String</code> for <code>char</code>.</li></ul><p>What if our library could depend on some contract that requires bindings to provide primitives? The contract will be the same for all bindings, but implementation will be different.</p><p>Rust does not know what is C++ <code>std::vector</code> or Ruby <code>String</code>, but we know it, our bindings know it and by providing a set of foreign utility functions (implemented on the bindings side) we could work with it just like with native <code>std::Vec&lt;T></code>.</p><p><p class=imgp><img loading=lazy src=/writing-bindings-upside-down-3.png alt=library-with-external-primitives.png></p></p><p>Here &ldquo;Primitives&rdquo; will be:</p><ul><li>Rust structures for Rust version of the library</li><li>C structs for C version</li><li>C++ classes for C++ version</li><li>Ruby classes for Ruby version</li></ul><p>&ldquo;Functions to work with primitives&rdquo; will be a set of <code>extern "C"</code> functions that take and return these &ldquo;foreign&rdquo; objects. Rust can call them without any knowledge of these objects.</p><p>By swapping implementations at link time we can get the same algorithm that works with a different set of structures from different languages. &ldquo;Link-time polymorphism&rdquo; seems to be a good name for this concept.</p><h2 id=example>Example</h2><p>I think it makes sense to start with C, this is what I would like to get eventually:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifndef STRUCTS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define STRUCTS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Char
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> bytes[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>} Char;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> CharList
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Char <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> len;
</span></span><span style=display:flex><span>} CharList;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// STRUCTS_H
</span></span></span></code></pre></div><p>Now the question is: how can we return this <code>CharList</code> from our Rust code? We could use <code>bindgen</code> and something-something. No, no and no.</p><p>Instead, let&rsquo;s make Rust think that <code>CharList</code> on its side is some struct of some (AOT-known) size without any meaningful fields. To do that we need to dump sizes of our structs and make them available in C:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;structs.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;CHAR_SIZE=%lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(Char));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;CHAR_LIST_SIZE=%lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(CharList));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We compile it, we run it, and we save its output to a text file called <code>sizes</code>, here&rsquo;s what I have locally</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>CHAR_SIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>CHAR_LIST_SIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>Now our Rust library has to be changed to work in 2 different modes:</p><ul><li><code>native</code> - when Rust structs are used as fields.</li><li><code>external</code> - when only size of structs is known, but fields and their positions are not.</li></ul><p>We a new feature to our <code>Cargo.toml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>features</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>default</span> = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># enables &#34;external&#34; mode, when structs have only size but no fields</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>external</span> = []
</span></span></code></pre></div><p>and we create a build script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// read path of the `sizes` file from the ENV var
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> sizes_filepath <span style=color:#f92672>=</span> env!(<span style=color:#e6db74>&#34;SIZES_FILEPATH&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// read `sizes` file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> sizes <span style=color:#f92672>=</span> std::fs::read_to_string(sizes_filepath)
</span></span><span style=display:flex><span>                  .expect(<span style=color:#e6db74>&#34;SIZES_FILEPATH has to point to a file&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// parse it line by line and re-write to Rust
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> sizes_rs <span style=color:#f92672>=</span> sizes
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> parts <span style=color:#f92672>=</span> line.split(<span style=color:#e6db74>&#34;=&#34;</span>).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> parts[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> parts[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            format!(<span style=color:#e6db74>&#34;pub(crate) const </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>: usize = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>;&#34;</span>, name, value)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        .join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// write it back to sizes.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std::fs::write(<span style=color:#e6db74>&#34;src/sizes.rs&#34;</span>, sizes_rs).unwrap();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(not(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// dummy main for &#34;native&#34; mode when no work is needed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Note: also there should be a <code>rerun-if-changed</code> line, but for the sake of implicitly I ignore dependencies here.</p><p>After running <code>SIZES_FILEPATH=path/to/sizes cargo build --features=external</code> we get <code>src/sizes.rs</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>CHAR_SIZE</span>: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>CHAR_LIST_SIZE</span>: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;
</span></span></code></pre></div><p>Time to use it! First we wrap existing definition of <code>Char</code> and <code>CharList</code> with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(not(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> native {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Char</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>char</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CharList</span> <span style=color:#f92672>=</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(not(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> native::{Char, CharList};
</span></span></code></pre></div><p>(note that we use <code>not(feature = "external")</code> above, which means &ldquo;native&rdquo; mode, they are opposite, and so one feature is enough) and then we add conditionally included <code>external</code> module with <strong>all</strong> structs that we use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> sizes;
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> external {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::sizes::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[repr(C)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Char</span> {
</span></span><span style=display:flex><span>        bytes: [<span style=color:#66d9ef>u8</span>; <span style=color:#66d9ef>CHAR_SIZE</span>],
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[repr(C)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CharList</span> {
</span></span><span style=display:flex><span>        bytes: [<span style=color:#66d9ef>u8</span>; <span style=color:#66d9ef>CHAR_LIST_SIZE</span>],
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(feature = </span><span style=color:#e6db74>&#34;external&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> external::{Char, CharList};
</span></span></code></pre></div><p>Now if we try to return <code>CharList</code> from our <code>foo</code> function we get compilation errors:</p><ul><li>there&rsquo;s no way to construct a <code>Char</code> from <code>char</code></li><li>we can&rsquo;t <code>collect()</code> <code>CharList</code> from <code>Iterator&lt;char></code></li></ul><p>How can we implement it? Let&rsquo;s take a look again at used APIs.</p><ol><li>we iterate over given string (it&rsquo;ll be a <code>const *u8</code> in C API) - we have it</li><li>we check <code>c.is_ascii()</code> - that&rsquo;s also OK</li><li>we need to map <code>char</code> to foreign <code>Char</code> - <strong>this requires a constructor</strong></li><li>we need a way to construct <code>CharList</code> from chars - <strong>this requires methods like <code>CharList::new()</code> and <code>CharList::push()</code></strong></li><li>we have a unit-test that needs <code>CharList::len()</code>, <code>CharList::at()</code>, <code>impl PartialEq for Char</code> (to compare individual chars) and <code>impl std::fmt::Debug for Char</code> (to print left/right-hand side if assertions fails)</li></ol><p>So, here&rsquo;s a list of &ldquo;external&rdquo; (i.e. in the <code>mod external {}</code> block) methods we want to have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(_: <span style=color:#66d9ef>char</span>) -&gt; <span style=color:#a6e22e>Self</span> { todo!() }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> PartialEq <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>eq</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#66d9ef>bool</span> { todo!() }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::fmt::Debug <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result { todo!() }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> CharList {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> { todo!() }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, item: <span style=color:#a6e22e>Char</span>) { todo!() }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> { todo!() }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>at</span>(<span style=color:#f92672>&amp;</span>self, idx: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Char</span> { todo!() }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For now all of them can return <code>todo!()</code>, but we&rsquo;ll implement them later. Time to rewrite our Rust implementation to use these new language-independent functionality:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>CharList</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> char_list <span style=color:#f92672>=</span> CharList::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>char</span> <span style=color:#66d9ef>in</span> s.chars() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span><span style=color:#66d9ef>char</span>.is_ascii() {
</span></span><span style=display:flex><span>            char_list.push(Char::from(<span style=color:#66d9ef>char</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    char_list
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_foo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc😋中国&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> foo(s);
</span></span><span style=display:flex><span>    assert_eq!(chars.len(), <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    assert_eq!(chars.at(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>&amp;</span>Char::from(<span style=color:#e6db74>&#39;😋&#39;</span>));
</span></span><span style=display:flex><span>    assert_eq!(chars.at(<span style=color:#ae81ff>1</span>), <span style=color:#f92672>&amp;</span>Char::from(<span style=color:#e6db74>&#39;中&#39;</span>));
</span></span><span style=display:flex><span>    assert_eq!(chars.at(<span style=color:#ae81ff>2</span>), <span style=color:#f92672>&amp;</span>Char::from(<span style=color:#e6db74>&#39;国&#39;</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That was easy, right? Way less elegant but still easy.</p><h2 id=implementing-bindings>Implementing bindings</h2><p>At this point you might have a guess on what&rsquo;s going to happen next. We are going to define a bunch of external C-ABI functions and blindly call them in all <code>todo!()</code> places. Later these functions will be implemented by the bindings library on C side:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char__new</span>(c1: <span style=color:#66d9ef>u8</span>, c2: <span style=color:#66d9ef>u8</span>, c3: <span style=color:#66d9ef>u8</span>, c4: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#a6e22e>Char</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char__at</span>(this: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Char, idx: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>byte_at</span>(<span style=color:#f92672>&amp;</span>self, idx: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#66d9ef>u8</span> {
</span></span><span style=display:flex><span>        debug_assert!(idx <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char__at(self, idx) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(c: <span style=color:#66d9ef>char</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> buf <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        c.encode_utf8(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> buf);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char__new(buf[<span style=color:#ae81ff>0</span>], buf[<span style=color:#ae81ff>1</span>], buf[<span style=color:#ae81ff>2</span>], buf[<span style=color:#ae81ff>3</span>]) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span>Char<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>char</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(c: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Char</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c1 <span style=color:#f92672>=</span> c.byte_at(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c2 <span style=color:#f92672>=</span> c.byte_at(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c3 <span style=color:#f92672>=</span> c.byte_at(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c4 <span style=color:#f92672>=</span> c.byte_at(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> [c1, c2, c3, c4];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> zero_idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> idx <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>4</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> bytes[idx] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                zero_idx <span style=color:#f92672>=</span> idx;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>bytes[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>zero_idx];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> std::<span style=color:#66d9ef>str</span>::from_utf8(bytes).unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> s.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        debug_assert!(chars.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        chars[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> PartialEq <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>eq</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>4</span>).all(<span style=color:#f92672>|</span>idx<span style=color:#f92672>|</span> self.byte_at(idx) <span style=color:#f92672>==</span> other.byte_at(idx))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::fmt::Debug <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#e6db74>&#34;{}&#34;</span>, <span style=color:#66d9ef>char</span>::from(self))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char_list__new</span>() -&gt; <span style=color:#a6e22e>CharList</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char_list__push</span>(this: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> CharList, item: <span style=color:#a6e22e>Char</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char_list__len</span>(this: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> CharList) -&gt; <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char_list__at</span>(this: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> CharList, idx: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Char;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> CharList {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char_list__new() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, item: <span style=color:#a6e22e>Char</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char_list__push(self, item) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char_list__len(self) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>at</span>(<span style=color:#f92672>&amp;</span>self, idx: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Char</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char_list__at(self, idx).as_ref().unwrap() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>OK, now we have a contract. Rust relies on it, but C so far does not provide anything. If we try to run tests with <code>--features=external</code> we get a bunch of linkage errors, which is 100% expected. Time to implement in on C side.</p><p>This is a &ldquo;shared&rdquo; version that we&rsquo;ll use for C++/Ruby/Node.js bindings</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifndef BINDINGS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BINDINGS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>DEFINITIONS_FILE</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Char_BLOB <span style=color:#a6e22e>char__new</span>(<span style=color:#66d9ef>uint8_t</span> c1, <span style=color:#66d9ef>uint8_t</span> c2, <span style=color:#66d9ef>uint8_t</span> c3, <span style=color:#66d9ef>uint8_t</span> c4);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>char__bytes</span>(<span style=color:#66d9ef>const</span> Char_BLOB <span style=color:#f92672>*</span>self);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CharList_BLOB <span style=color:#a6e22e>char_list__new</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__push</span>(CharList_BLOB <span style=color:#f92672>*</span>self, Char_BLOB item);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> <span style=color:#a6e22e>char_list__len</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self);
</span></span><span style=display:flex><span>    Char_BLOB <span style=color:#a6e22e>char_list__at</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>size_t</span> idx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// BINDINGS_H
</span></span></span></code></pre></div><p>It includes <code>DEFINITIONS_FILE</code> because we want it to be generic (and we&rsquo;ll pass it as a dynamic define via <code>-D</code> flag). Also you might notice that methods take/return <code>&lt;type>_BLOB</code> type, that&rsquo;s because we want to pass C-compatible types. C types are C-compatible, and so we make another file <code>bindings-support.h</code> with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifndef BINDINGS_SUPPORT_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BINDINGS_SUPPORT_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;structs.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Char Char_BLOB;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> CharList CharList_BLOB;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// BINDINGS_SUPPORT_H
</span></span></span></code></pre></div><p>&mldr; to create aliases. For C++ we&rsquo;ll have to convert our classes to something C understands (I&rsquo;ll cover it later).</p><p>Implementation time!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Char_BLOB <span style=color:#a6e22e>char__new</span>(<span style=color:#66d9ef>uint8_t</span> c1, <span style=color:#66d9ef>uint8_t</span> c2, <span style=color:#66d9ef>uint8_t</span> c3, <span style=color:#66d9ef>uint8_t</span> c4)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (Char_BLOB){.bytes <span style=color:#f92672>=</span> {c1, c2, c3, c4}};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> <span style=color:#a6e22e>char__at</span>(<span style=color:#66d9ef>const</span> Char_BLOB <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>uint8_t</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>-&gt;</span>bytes[idx];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CharList_BLOB <span style=color:#a6e22e>char_list__new</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (CharList_BLOB){.ptr <span style=color:#f92672>=</span> NULL, .len <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__push</span>(CharList_BLOB <span style=color:#f92672>*</span>self, Char_BLOB item)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Char <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> self<span style=color:#f92672>-&gt;</span>ptr;
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(Char) <span style=color:#f92672>*</span> (self<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (self<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>memcpy</span>(self<span style=color:#f92672>-&gt;</span>ptr, prev, self<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(Char));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(prev);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>ptr[self<span style=color:#f92672>-&gt;</span>len] <span style=color:#f92672>=</span> item;
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>=</span> self<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>size_t</span> <span style=color:#a6e22e>char_list__len</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Char_BLOB <span style=color:#a6e22e>char_list__at</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>size_t</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>-&gt;</span>ptr[idx];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We compile it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ clang c-bindings/bindings.c -g -c -o c-bindings/all.o
</span></span><span style=display:flex><span>$ ar rc c-bindings/libbindings.a c-bindings/all.o
</span></span></code></pre></div><p>And change our <code>build.rs</code> script to link with it (the purpose of these environment variables is to make external primitives implementation &ldquo;pluggable&rdquo;):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> external_lib_path <span style=color:#f92672>=</span> env!(<span style=color:#e6db74>&#34;EXTERNAL_LIB_PATH&#34;</span>);
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;cargo:rustc-link-search=</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, external_lib_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> external_lib_name <span style=color:#f92672>=</span> env!(<span style=color:#e6db74>&#34;EXTERNAL_LIB_NAME&#34;</span>);
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;cargo:rustc-link-lib=static=</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, external_lib_name);
</span></span></code></pre></div><p>And now we can run tests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cd rust-lib
</span></span><span style=display:flex><span>$ EXTERNAL_LIB_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../c-bindings&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    EXTERNAL_LIB_NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bindings&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    SIZES_FILEPATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../c-bindings/sizes&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    cargo test --features<span style=color:#f92672>=</span>external
</span></span></code></pre></div><p>and we get 1 passing test!</p><h2 id=c-bindings-quickly>C++ bindings, quickly</h2><p>I want this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifndef STRUCTS_HPP
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define STRUCTS_HPP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Char</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> bytes[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>    Char() <span style=color:#f92672>:</span> Char(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>Char</span>(<span style=color:#66d9ef>char</span> c1, <span style=color:#66d9ef>char</span> c2, <span style=color:#66d9ef>char</span> c3, <span style=color:#66d9ef>char</span> c4) <span style=color:#f92672>:</span> bytes{c1, c2, c3, c4} {}
</span></span><span style=display:flex><span>    size_t <span style=color:#a6e22e>size</span>() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        size_t size <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (bytes[<span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>            size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (bytes[<span style=color:#ae81ff>3</span>])
</span></span><span style=display:flex><span>            size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> size;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string as_string() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string s;
</span></span><span style=display:flex><span>        s.reserve(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size(); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            s.push_back(bytes[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> CharList <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Char<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// STRUCTS_HPP
</span></span></span></code></pre></div><p>C functions are the same, but these classes are incompatible with C FFI, so we need to define our blob structs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifndef BINDINGS_SUPPORT_HPP
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BINDINGS_SUPPORT_HPP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;structs.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define DECLARE_BLOB(T)               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    extern &#34;C&#34;                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        struct T##_BLOB               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            uint8_t bytes[sizeof(T)]; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        };                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    union T##_UNION                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        T value;                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        T##_BLOB blob;                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        ~T##_UNION() {}               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        T##_UNION()                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        {                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            new (&amp;value) T();         \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    };                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    T##_BLOB PACK_##T(T value)        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        T##_UNION u;                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        u.value = std::move(value);   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        return u.blob;                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    };                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    T UNPACK_##T(T##_BLOB blob)       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        T##_UNION u;                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        u.blob = blob;                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        return std::move(u.value);    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>DECLARE_BLOB(Char);
</span></span><span style=display:flex><span>DECLARE_BLOB(CharList);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// BINDINGS_SUPPORT_HPP
</span></span></span></code></pre></div><p>Here <code>DECLARE_BLOB</code> macro for given <code>Type</code> defines:</p><ul><li><code>Type_BLOB</code> struct that is C-compatible</li><li><code>Type_UNION</code> union that is a union of <code>Type</code> and <code>Type_BLOB</code></li><li><code>PACK_Type</code> function that converts an instance of <code>Type</code> to <code>Type_BLOB</code> so we can return if <strong>from</strong> <code>extern "C"</code> function</li><li><code>UNPACK_Type</code> function that converts <code>Type_BLOB</code> to <code>Type</code> so we can &ldquo;unpack&rdquo; blob that is passed <strong>to</strong> <code>extern "C"</code> function</li></ul><p>This conversion with <code>union</code> is an equivalent of <code>std::mem::transmute</code> from Rust (C++20 has <code>std::bit_cast</code> for that, but <code>union</code> shows better what happens under the hood). Also we <code>std::move</code> the value to and from <code>union</code> on conversion, this is important (otherwise, copyable types are copied).</p><p>However, it has a requirement for <code>T</code> to be both movable and constructible with no arguments. We could do <code>std::memset(this, 0, sizeof(T))</code>, but some move constructors/assignment operators swap fields of <code>this</code> and given <code>other</code>, and so sometimes it&rsquo;s invalid to call a destructor on an object full of zeroes (of course it totally depends on the structure of the object).</p><p>With these blobs implementing binding functions is trivial:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Char_BLOB <span style=color:#a6e22e>char__new</span>(<span style=color:#66d9ef>uint8_t</span> c1, <span style=color:#66d9ef>uint8_t</span> c2, <span style=color:#66d9ef>uint8_t</span> c3, <span style=color:#66d9ef>uint8_t</span> c4) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> PACK_Char(Char(c1, c2, c3, c4));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> <span style=color:#a6e22e>char__at</span>(<span style=color:#66d9ef>const</span> Char_BLOB <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>uint8_t</span> idx) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> Char <span style=color:#f92672>*</span>s <span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> Char <span style=color:#f92672>*</span>)self;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (idx <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s<span style=color:#f92672>-&gt;</span>bytes[idx];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CharList_BLOB <span style=color:#a6e22e>char_list__new</span>() <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> PACK_CharList(CharList());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__push</span>(CharList_BLOB <span style=color:#f92672>*</span>self, Char_BLOB item) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ((CharList <span style=color:#f92672>*</span>)self)<span style=color:#f92672>-&gt;</span>push_back(UNPACK_Char(item));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    size_t <span style=color:#a6e22e>char_list__len</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ((CharList <span style=color:#f92672>*</span>)self)<span style=color:#f92672>-&gt;</span>size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Char_BLOB <span style=color:#a6e22e>char_list__at</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self, size_t idx) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> PACK_Char(((CharList <span style=color:#f92672>*</span>)self)<span style=color:#f92672>-&gt;</span>at(idx));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We compile and build a static library:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ clang++ -std<span style=color:#f92672>=</span>c++17 cpp-bindings/bindings.cpp -g -c -fPIE -o cpp-bindings/all.o
</span></span><span style=display:flex><span>$ ar rc cpp-bindings/libbindings.a cpp-bindings/all.o
</span></span></code></pre></div><p>One extra step that is specific to C++ libraries - we need to link with C++ runtime, so this extra code goes to <code>Cargo.toml</code> and <code>build.rs</code> respectively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>features</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># enables linking with C++ runtime</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>link-with-cxx-runtime</span> = []
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> cfg!(feature <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;link-with-cxx-runtime&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cfg!(target_os <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;linux&#34;</span>) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;cargo:rustc-link-lib=dylib=stdc++&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;cargo:rustc-link-lib=dylib=c++&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally we can run our tests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>EXTERNAL_LIB_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../cpp-bindings&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  EXTERNAL_LIB_NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bindings&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  SIZES_FILEPATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../cpp-bindings/sizes&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  cargo test --features<span style=color:#f92672>=</span>external,link-with-cxx-runtime
</span></span></code></pre></div><h2 id=ruby-bindings-also-quickly>Ruby bindings, also quickly</h2><p>We want our <code>Char</code> to be a Ruby <code>String</code> and <code>CharList</code> to be an <code>Array</code>, in Ruby C API they are both represented as <code>VALUE</code> (that is technically a pointer to a tagged union (unless it&rsquo;s a small number/<code>true</code>/<code>false</code>/<code>nil</code>, then it&rsquo;s basically the value itself)).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifndef STRUCTS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define STRUCTS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ruby.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> VALUE Char;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> VALUE CharList;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// STRUCTS_H
</span></span></span></code></pre></div><p>and so sizes are these:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>CHAR_SIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>CHAR_LIST_SIZE<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p><code>VALUE</code> is simply an alias to <code>unsigned long</code> on x86_64, so blobs are aliases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifndef BINDINGS_SUPPORT_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BINDINGS_SUPPORT_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;structs.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Char Char_BLOB;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> CharList CharList_BLOB;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// BINDINGS_SUPPORT_H
</span></span></span></code></pre></div><p>Bindings implementation (uses Ruby C API):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;bindings-support.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>Char_BLOB <span style=color:#a6e22e>char__new</span>(<span style=color:#66d9ef>uint8_t</span> c1, <span style=color:#66d9ef>uint8_t</span> c2, <span style=color:#66d9ef>uint8_t</span> c3, <span style=color:#66d9ef>uint8_t</span> c4)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {(<span style=color:#66d9ef>char</span>)c1, (<span style=color:#66d9ef>char</span>)c2, (<span style=color:#66d9ef>char</span>)c3, (<span style=color:#66d9ef>char</span>)c4};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (c3) len<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (c4) len<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rb_utf8_str_new</span>(c, len);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> <span style=color:#a6e22e>char__at</span>(<span style=color:#66d9ef>const</span> Char_BLOB <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>uint8_t</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    VALUE this <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>self;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>StringValuePtr</span>(this)[idx];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CharList_BLOB <span style=color:#a6e22e>char_list__new</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rb_ary_new</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__push</span>(CharList_BLOB <span style=color:#f92672>*</span>self, Char_BLOB item)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rb_ary_push</span>(<span style=color:#f92672>*</span>self, item);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>size_t</span> <span style=color:#a6e22e>char_list__len</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rb_array_len</span>(<span style=color:#f92672>*</span>self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Char_BLOB <span style=color:#a6e22e>char_list__at</span>(<span style=color:#66d9ef>const</span> CharList_BLOB <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>size_t</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rb_ary_entry</span>(<span style=color:#f92672>*</span>self, idx);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looks similar to C++ bindings, right? OK, can we run Rust tests with Ruby primitives? Unfortunately, no. These methods expect Ruby VM to be up and running and embedding Ruby is not something many Ruby developers do.</p><p>Instead, we need to re-compile it to a dynamically-loaded library that (once loaded) registers a <code>foo</code> method that takes a string, passes its <code>const char *</code> pointer to our <code>foo</code> function defined in Rust and returns <code>CharList</code> back to Ruby space.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ruby.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;structs.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>CharList <span style=color:#a6e22e>c_foo</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>s);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>VALUE <span style=color:#a6e22e>rb_foo</span>(VALUE self, VALUE s)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>void</span>)self;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Check_Type</span>(s, T_STRING);
</span></span><span style=display:flex><span>    CharList chars <span style=color:#f92672>=</span> <span style=color:#a6e22e>c_foo</span>(<span style=color:#a6e22e>StringValueCStr</span>(s));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> chars;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Init_foo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rb_define_global_function</span>(<span style=color:#e6db74>&#34;foo&#34;</span>, rb_foo, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>c_foo</code> is defined on Rust side with C linkage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>c_foo</span>(s: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>i8</span>) -&gt; <span style=color:#a6e22e>CharList</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { std::ffi::CStr::from_ptr(s).to_str().unwrap() };
</span></span><span style=display:flex><span>    foo(s)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now if we compile it to <code>.bundle</code> (this is for Mac, on Linux and Windows it&rsquo;s a <code>.so</code> extension)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ clang -Ipath/to/ruby/includes ruby-bindings/init.c -c -o ruby-bindings/init.o
</span></span><span style=display:flex><span>$ clang -Ipath/to/ruby/includes ruby-bindings/bindings.c -c -o ruby-bindings/bindings.o
</span></span><span style=display:flex><span>$ ar rc ruby-bindings/libbindings.a ruby-bindings/bindings.o
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cd rust-lib
</span></span><span style=display:flex><span>$ EXTERNAL_LIB_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../ruby-bindings&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    EXTERNAL_LIB_NAME<span style=color:#f92672>=</span>bindings <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    SIZES_FILEPATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../ruby-bindings/sizes&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    cargo build --features<span style=color:#f92672>=</span>external
</span></span><span style=display:flex><span>$ cd ..
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ clang <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -dynamic <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -bundle <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o ruby-bindings/foo.bundle <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    ruby-bindings/init.o rust-foo/librust-foo-rust.a <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -Wl,-undefined,dynamic_lookup
</span></span></code></pre></div><p>.. we get <code>ruby-bindings/foo.bundle</code> that can be imported from Ruby:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ruby -r./ruby-bindings/foo -e <span style=color:#e6db74>&#39;p foo(&#34;abc😋中国&#34;)&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#e6db74>&#34;😋&#34;</span>, <span style=color:#e6db74>&#34;中&#34;</span>, <span style=color:#e6db74>&#34;国&#34;</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>In fact there are many more options that are passed to <code>clang</code> above, check out <a href=https://github.com/iliabylich/writing-bindings-upside-down target=_blank rel="noreferrer nofollow">the repository</a>
if you want to try it yourself.</p><h2 id=memory-leaks>Memory leaks</h2><p>All versions above have a memory leak that can be easily identified by compiling with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ASAN_OPTIONS<span style=color:#f92672>=</span>detect_leaks<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> CXXFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-fsanitize=address&#34;</span> clang++
</span></span></code></pre></div><p>or (to track it when running Rust tests)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>RUSTFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-Z sanitizer=address&#34;</span> ... cargo test
</span></span></code></pre></div><p>(On Mac make sure to use <code>clang</code> from Homebrew, version that ships with OS does not support ASAN)</p><p>Running tests with this options shows that we have a leak somewhere in</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Direct leak of 96 byte(s) in 1 object(s) allocated from:
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>    #9 0x105905990 in char_list__push bindings.cpp:34
</span></span><span style=display:flex><span>    #10 0x105904c04 in rust_foo::external::CharList::push::hf5bdccdb764b0c62 lib.rs:91
</span></span><span style=display:flex><span>    #11 0x1059043bb in rust_foo::foo::hf9387b4435c6f8b6 lib.rs:108
</span></span><span style=display:flex><span>    #12 0x10590442d in c_foo lib.rs:117
</span></span><span style=display:flex><span>    #13 0x1059006e8 in cpp_foo(char const*) test.cpp:14
</span></span><span style=display:flex><span>    #14 0x105900a10 in main test.cpp:24
</span></span></code></pre></div><p>And the reason is that our <code>CharList</code> is heap-allocated, but it has no destructor on the Rust side. To fix it we need to add 2 more functions to our bindings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char__drop</span>(this: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> Char);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>char_list__drop</span>(this: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> CharList);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> Char {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char__drop(self) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> CharList {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { char_list__drop(self) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Of course, we need to add it to <code>bindings.h</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char__drop</span>(Char_BLOB <span style=color:#f92672>*</span>self);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__drop</span>(CharList_BLOB <span style=color:#f92672>*</span>self);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><p>Here&rsquo;s a C implementation (depending on your implementation <code>char__drop</code> could to something):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char__drop</span>(Char_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// noop, Char has no allocations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__drop</span>(CharList_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (self<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(self<span style=color:#f92672>-&gt;</span>ptr);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>C++ implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char__drop</span>(Char_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// noop, Char has no allocations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__drop</span>(CharList_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ((CharList <span style=color:#f92672>*</span>)self)<span style=color:#f92672>-&gt;~</span>vector();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ruby:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char__drop</span>(Char_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// noop, Ruby has GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>char_list__drop</span>(CharList_BLOB <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// noop, Ruby has GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=performance>Performance</h2><p>How about performance? When we compile with Rust primitives we use LTO and so things from Rust standard library can be optimized together with our code. Luckily, there&rsquo;s a way to do that for external primitives too.</p><p>I would like to demonstrate it on the low level, first let&rsquo;s compile everything to LLVM IR:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ clang-13 -S -emit-llvm c-bindings/bindings.c -o c-bindings/bindings.ll
</span></span><span style=display:flex><span>$ grep -F <span style=color:#e6db74>&#34;char__&#34;</span> c-bindings/bindings.ll
</span></span><span style=display:flex><span>define dso_local i32 @char__new<span style=color:#f92672>(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span style=color:#f92672>)</span> <span style=color:#75715e>#0 {</span>
</span></span><span style=display:flex><span>define dso_local zeroext i8 @char__at<span style=color:#f92672>(</span>%struct.Char* %0, i8 zeroext %1<span style=color:#f92672>)</span> <span style=color:#75715e>#0 {</span>
</span></span><span style=display:flex><span>define dso_local void @char__drop<span style=color:#f92672>(</span>%struct.Char* %0<span style=color:#f92672>)</span> <span style=color:#75715e>#0 {</span>
</span></span></code></pre></div><p>^ that was the file with bindings implementation, C part. It defines all <code>char__</code> functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cd rust-foo
</span></span><span style=display:flex><span>$ rustc --crate-name rust_foo src/lib.rs --crate-type staticlib --emit<span style=color:#f92672>=</span>llvm-ir --cfg <span style=color:#e6db74>&#39;feature=&#34;default&#34;&#39;</span> --cfg <span style=color:#e6db74>&#39;feature=&#34;external&#34;&#39;</span>
</span></span><span style=display:flex><span>$ cd ..
</span></span><span style=display:flex><span>$ grep -F <span style=color:#e6db74>&#34;char__&#34;</span> rust-foo/rust_foo.ll
</span></span><span style=display:flex><span>  %8 <span style=color:#f92672>=</span> call i32 @char__new<span style=color:#f92672>(</span>i8 zeroext %_8, i8 zeroext %_10, i8 zeroext %_12, i8 zeroext %_14<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>declare i32 @char__new<span style=color:#f92672>(</span>i8 zeroext, i8 zeroext, i8 zeroext, i8 zeroext<span style=color:#f92672>)</span> unnamed_addr <span style=color:#75715e>#1</span>
</span></span></code></pre></div><p>^ that was the Rust part. It declares (as external) and calls some of our <code>char__</code> functions.</p><p>Let&rsquo;s link them together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ llvm-link-13 c-bindings/bindings.ll rust-foo/rust_foo.ll -S -o merged.ll
</span></span><span style=display:flex><span>$ grep -F <span style=color:#e6db74>&#34;char__&#34;</span> merged.ll
</span></span><span style=display:flex><span>define dso_local i32 @char__new<span style=color:#f92672>(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span style=color:#f92672>)</span> <span style=color:#75715e>#0 {</span>
</span></span><span style=display:flex><span>define dso_local zeroext i8 @char__at<span style=color:#f92672>(</span>%struct.Char* %0, i8 zeroext %1<span style=color:#f92672>)</span> <span style=color:#75715e>#0 {</span>
</span></span><span style=display:flex><span>define dso_local void @char__drop<span style=color:#f92672>(</span>%struct.Char* %0<span style=color:#f92672>)</span> <span style=color:#75715e>#0 {</span>
</span></span><span style=display:flex><span>  %8 <span style=color:#f92672>=</span> call i32 @char__new<span style=color:#f92672>(</span>i8 zeroext %_8, i8 zeroext %_10, i8 zeroext %_12, i8 zeroext %_14<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>These 2 modules have been merged, time to optimize them together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ opt-13 -O3 merged.ll -S -o optimized.ll
</span></span><span style=display:flex><span>$ grep -F <span style=color:#e6db74>&#34;char__&#34;</span> optimized.ll
</span></span><span style=display:flex><span>define dso_local i32 @char__new<span style=color:#f92672>(</span>i8 zeroext %0, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3<span style=color:#f92672>)</span> local_unnamed_addr <span style=color:#75715e>#0 {</span>
</span></span><span style=display:flex><span>define dso_local zeroext i8 @char__at<span style=color:#f92672>(</span>%struct.Char* nocapture readonly %0, i8 zeroext %1<span style=color:#f92672>)</span> local_unnamed_addr <span style=color:#75715e>#1 {</span>
</span></span><span style=display:flex><span>define dso_local void @char__drop<span style=color:#f92672>(</span>%struct.Char* nocapture %0<span style=color:#f92672>)</span> local_unnamed_addr <span style=color:#75715e>#0 {</span>
</span></span></code></pre></div><p>Now we have only definitions, actual calls have been successfully inlined. Now we can compile it to an object file to see a final result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ llc-13 -O3 -filetype<span style=color:#f92672>=</span>obj optimized.ll -o optimized.o
</span></span><span style=display:flex><span>$ clang-13 test.c optimized.o -O3 -o test-runner
</span></span><span style=display:flex><span>$ objdump -D test-runner | grep <span style=color:#e6db74>&#34;call&#34;</span> | grep <span style=color:#e6db74>&#34;char__&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># no output</span>
</span></span><span style=display:flex><span>$ objdump -D test-runner | grep <span style=color:#e6db74>&#34;call&#34;</span> | grep <span style=color:#e6db74>&#34;char_list&#34;</span>
</span></span><span style=display:flex><span>  406bba: e8 <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>        callq  406cc0 &lt;char_list__drop&gt;
</span></span><span style=display:flex><span>  406d21: e8 fa fe ff ff        callq  406c20 &lt;char_list__new&gt;
</span></span></code></pre></div><p>As you can see all <code>char__new</code> or <code>char__at</code> calls have been inlined, <code>char_list__drop</code> and <code>char_list__new</code> haven&rsquo;t, because of how LLVM decides on what should or should not be inlined. Anyway, it works.</p><p>Of course, there&rsquo;s an easier way to get the same result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ export RUSTFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld&#34;</span>
</span></span><span style=display:flex><span>$ export CFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-flto&#34;</span>
</span></span></code></pre></div><p>^ this should be enough to get the same result. By adding <code>-Clinker-plugin-lto</code> we ask Rust to compile all object files to LLVM IR:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ RUSTFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-Clinker-plugin-lto -Clinker=clang-13 -Clink-arg=-fuse-ld=lld&#34;</span> cargo build --features<span style=color:#f92672>=</span>external
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ mkdir objects
</span></span><span style=display:flex><span>$ cd objects
</span></span><span style=display:flex><span>$ ar x ../target/release/librust_foo.a
</span></span><span style=display:flex><span>$ ls -l
</span></span><span style=display:flex><span><span style=color:#75715e># a ton of object files, that&#39;s what static library is about</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ file *.o
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>... snip ...
</span></span><span style=display:flex><span>popcountti2.o:                                                                              ELF 64-bit LSB relocatable, x86-64, version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>SYSV<span style=color:#f92672>)</span>, with debug_info, not stripped
</span></span><span style=display:flex><span>powixf2.o:                                                                                  ELF 64-bit LSB relocatable, x86-64, version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>SYSV<span style=color:#f92672>)</span>, with debug_info, not stripped
</span></span><span style=display:flex><span>rust_foo-0f1418f7365bf15b.2nf5cb5qlud0f6qs.rcgu.o:                                          LLVM IR bitcode
</span></span><span style=display:flex><span>rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.0.rcgu.o:                                   LLVM IR bitcode
</span></span><span style=display:flex><span>rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.1.rcgu.o:                                   LLVM IR bitcode
</span></span><span style=display:flex><span>rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.2.rcgu.o:                                   LLVM IR bitcode
</span></span><span style=display:flex><span>rust_foo-0f1418f7365bf15b.rust_foo.f999abab-cgu.3.rcgu.o:                                   LLVM IR bitcode
</span></span><span style=display:flex><span>rustc_demangle-7f98f837d3579544.rustc_demangle.5563b4d3-cgu.0.rcgu.o:                       ELF 64-bit LSB relocatable, x86-64, version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>SYSV<span style=color:#f92672>)</span>, with debug_info, not stripped
</span></span><span style=display:flex><span>... snip ...
</span></span></code></pre></div><p>Rust standard library is compiled directly to object files, but our code is <code>LLVM IR bitcode</code>. <strong>This way we can get zero-cost bindings defined externally</strong>.</p><p>Of course, it&rsquo;s not gonna work with Ruby or Node.js, both of them have a giant <code>libruby.so</code> (or <code>libnode.so</code>) that defines all functions and constants that your extension relies on. The extension itself is compiled with <code>-Wl,-undefined,dynamic_lookup</code> and symbol lookup is performed at runtime. I feel like technically it&rsquo;s possible, the entire Ruby/Node.js runtime could be compiled to a static <code>libruby.a</code>/<code>libnode.a</code> that defines all VM objects as external (because that&rsquo;s a singleton that we need to hook into), but all functions can provide their implementation (of course, in LLVM IR format), and so they can be inlined into our bindings implementation. I haven&rsquo;t experimented with it yet, and honestly I&rsquo;m not going to :) If you know anything about existing discussions around it, please, ping me on Twitter.</p><h2 id=the-whole-picture-again>The whole picture, again</h2><p>Demo repository is available <a href=https://github.com/iliabylich/writing-bindings-upside-down target=_blank rel="noreferrer nofollow">here</a></p><p>To sum up:</p><ol><li>Library maintainers can change their library to accept <strong>&ldquo;pluggable&rdquo; external primitives</strong>. If no external primitives provided native version is used.</li><li>Library maintainers can <strong>provide headers</strong> that define what should be provided (i.e. a set of functions that take/return primitives). This is the definition of the contract.</li><li>Authors of bindings <strong>define structure as they want</strong> (i.e. instead of vector they are free to use linked lists of hashmaps)</li><li>Authors of bindings <strong>implement functions defined in headers</strong>. This is the implementation of the contract.</li><li>To get full bindings the library is linked together with bindings. There might be a need to build a wrapper around functions defined in the library, but that&rsquo;s trivial as these functions return objects that are &ldquo;native&rdquo; for bindings.</li></ol><p>Pros:</p><ul><li>To implement bindings you don&rsquo;t wrap every single function, instead you focus on implementing types and contract around them. Moreover, the contract is quite simple and many languages have a rich standard library, so implementing these library-defined functions can be very easy.</li><li>Libraries can provide headers, so it&rsquo;s hard to make a mistake.</li><li>Libraries usually have a decent test suite, it can be used to verify bindings for correctness and memory leaks.</li></ul><p>Cons:</p><ul><li>The library needs quite a lot of changes to support &ldquo;external&rdquo; primitives. That&rsquo;s not an easy task.</li><li>The library needs to ship with a &ldquo;reference implementation&rdquo;, to verify that existing external functions are enough to build everything.</li><li>There are minor differences between standard types in languages, for example C++ has a small string optimization, and small strings are not &ldquo;containers&rdquo;. On the other side Rust strings are true containers, and library developers may expect &ldquo;external&rdquo; string to be a container, too, but on the bindings side <code>std::string</code> from C++ does not fully match the contract (i.e. you can&rsquo;t borrow a <code>char *</code> from <code>std::string</code> and expect it to live as long as the string lives). In some cases it can become really hard to track and fix.</li></ul></main><br><footer><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=e.textContent;navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script></footer></body></html>