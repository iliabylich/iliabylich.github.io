<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon-precomposed sizes=192x192 href=/icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel=stylesheet><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="lib-ruby-parser"><title>lib-ruby-parser | Ilya Bylich - Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.2b907de83c90cfa7c3d79a41f7775098387ed032abb1f83426627b3438329fdc.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/>Home</a></li><li><a tabindex=-1 class=menu-link href=https://github.com/iliabylich>GitHub</a></li><li><a tabindex=-1 class=menu-link href=https://twitter.com/IlyaBylich>Twitter</a></li><li><a tabindex=-1 class=menu-link href=mailto:ibylich@gmail.com>Email me</a></li><li><a tabindex=-1 class=menu-link href=/index.xml>RSS</a></li></ul></nav><div id=single-header><h1>lib-ruby-parser</h1><div id=single-meta><span class=datesub>Nov 23, 2020</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://iliabylich.github.io/tags/ruby/>#ruby</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/parser/>#parser</a>
</span>&nbsp; <span><a href=https://iliabylich.github.io/tags/rust/>#rust</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#future-improvements>Future improvements</a></li><li><a href=#c-bindings>C bindings</a></li><li><a href=#c-bindings-1>C++ bindings</a></li><li><a href=#node-bindings>Node bindings</a></li><li><a href=#wasm>WASM</a></li><li><a href=#final-thoughts>Final thoughts</a></li></ul></nav></aside><main><h2 id=intro>Intro</h2><p>So, I&rsquo;m ready to announce that I have finished working on a new Ruby parser. It&rsquo;s called <code>lib-ruby-parser</code>.</p><p>Key features:</p><ol><li>It&rsquo;s fast. It&rsquo;s written in Rust and it&rsquo;s slightly faster than Ripper. The difference is about 1-2% on my machine.</li><li>It has a beautiful interface. Every single node has its own type that is documented. For example, take a look at <a href=https://docs.rs/lib-ruby-parser/0.7.0/lib_ruby_parser/nodes/struct.CSend.html target=_blank rel="noreferrer nofollow"><code>CSend</code> node</a>
that represents &ldquo;conditional send&rdquo; like <code>foo&.bar</code>. <a href=https://docs.rs/lib-ruby-parser/0.7.0/lib_ruby_parser/nodes/index.html target=_blank rel="noreferrer nofollow">Here&rsquo;s a list of all defined nodes</a>
. Both Ripper and <code>RubyVM::AST</code> have no documentation of their AST format. <code>whitequark/parser</code> <a href=https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md target=_blank rel="noreferrer nofollow">has a great documentation</a>
, but its AST is not &ldquo;static&rdquo;.</li><li>What&rsquo;s &ldquo;static AST&rdquo;? By saying that I mean that if documentation says that &ldquo;N is not-nullable&rdquo; then it&rsquo;s true no matter what. <code>whitequark/parser</code> does a great job, but the nature of dynamic language does not allow it to provide such guarantees. I&rsquo;ll show a few examples later.</li><li>It&rsquo;s precise. Unlike <code>whitequark/parser</code>, its lexer (or tokenizer if it sounds better for you) is based on MRI&rsquo;s <code>parse.y</code>. What does it mean? It means that I was not able to find any difference in tokenizing on 3 million lines of code that I have got by pulling sources of top 300 gems (by total downloads). I&rsquo;ll mention how I track it soon.</li><li>It does not depend on Ruby. In fact, it has absolutely no &ldquo;required&rdquo; dependencies (only a few optional ones). So, it&rsquo;s possible to write bindings for any other language, and I have made them for C/C++/Node.js. Of course, it&rsquo;s possible to have bindings for Ruby (because there are bindings for C and it&rsquo;s easy to reuse them)</li></ol><h2 id=implementation>Implementation</h2><p>Current performance (in release mode, with <code>jemalloc</code>) is ~200000 LOC/s. I think it can even be used for syntax highlighting (and in the browser, too, haha).</p><p>I don&rsquo;t want to dig too far, but some notes could be interesting.</p><p>Rust is a general purpose language that is based on LLVM (&lt;3) and can be compiled directly into machine code. It does not need any VMs and it can be compiled to a ton of targets (or platforms). The code does not use pointers, and there are no <code>unsafe</code> calls that you might hear about.</p><p>Rust does support ADT (algebraic data type) and it has generics, so you can build data structures like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tree</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Some(T, Box<span style=color:#f92672>&lt;</span>Tree<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>, Box<span style=color:#f92672>&lt;</span>Tree<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Beautiful, right?</p><p>I designed <code>Node</code> struct in a very similar way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    Variant1(Variant1),
</span></span><span style=display:flex><span>    Variant2(Variant2),
</span></span><span style=display:flex><span>    Variant3(Variant3),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Variant1</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Variant2</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>If you are familiar with C/C++ it might look similar to tagged union, and was I know that&rsquo;s exactly how they are implemented. Close equivalent in C:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Node
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>    VARIANT1,
</span></span><span style=display:flex><span>    VARIANT2,
</span></span><span style=display:flex><span>  } variant_no;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// variant1 data ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } variant1_data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// variant2 data ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } variant2_data;
</span></span><span style=display:flex><span>  } variant_value;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>As I said, my lexer is based on MRI&rsquo;s <code>parse.y</code>. It&rsquo;s just a set of procedures that I turned into a few structs and interfaces.</p><p>But as some of you know, MRI&rsquo;s parser is compiled using <code>bison</code> (or <code>yacc</code> if you care about licenses). Bison is an LALR(1) parser generator, short summary:</p><ol><li>you write a <code>.y</code> file using bison&rsquo;s DSL, with some interpolations in your programming language</li><li>this file defines rules on how you want your language constructions to be reduced (or combined)</li><li>then you convert it to <code>.{ext}</code> file where <code>ext</code> is what your language uses. done</li></ol><p>Unfortunately, bison supports only C/C++/Java/D.</p><p>First I looked at what&rsquo;s available in the world of Rust. The most popular LALR parser generator is called <a href=https://github.com/lalrpop/lalrpop target=_blank rel="noreferrer nofollow"><code>lalrpop</code></a>
and I was very about it at the very beginning, I think has a very, very beautiful API:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> Term: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span>n:<span style=color:#a6e22e>Num</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=&gt;</span> n,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>&lt;</span>t:<span style=color:#a6e22e>Term</span><span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;)&#34;</span> <span style=color:#f92672>=&gt;</span> t,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Num: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>s:<span style=color:#a6e22e>r</span><span style=color:#e6db74>&#34;[0-9]+&#34;</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>i32</span>::from_str(s).unwrap();
</span></span></code></pre></div><p>Plus, it&rsquo;s written in Rust, so to compile a grammar that is based on it you don&rsquo;t anything except Rust (that you need anyway to compile something written in Rust, right?).</p><p>Unfortunately, I have got a few reasons to abandon this idea:</p><ol><li><p>No mid-rules (that are used A LOT in MRI) like</p><p><code>foo: bar { /* do something */ } baz { /* reduce */ }</code></p><p>I guess it&rsquo;s possible to emulate them by introducing rules like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>bar_with_mid_rule: bar { /* do something */ }
</span></span><span style=display:flex><span>foo: bar_with_mid_rule baz { /* reduce */ }
</span></span></code></pre></div><p>but then I have no idea how such grammar can be maintained.</p></li><li><p>Compilation speed. I have got ~20% of Ruby grammar backported and noticed a huge performance degradation.</p></li><li><p>No stack introspection (and IIRC no &ldquo;debug&rdquo; mode at all). By saying &ldquo;stack&rdquo; here I mean parser stack, that&rsquo;s a feature of LR parsers. You can check how it looks like by running <code>ruby -ye '42'</code> locally</p></li><li><p>The grammar written with <code>lalrpop</code> has a different format comparing to bison, and so maintaining it (like backporting new changed from MRI) seems to be a nightmare.</p></li></ol><p>But then I realized that Bison has a feature called &ldquo;custom skeleton&rdquo;. It&rsquo;s like a custom Bison template that you can use to convert <code>.y</code> to your format, and it &ldquo;takes&rdquo; all the data (like token/transition tables) as an argument when called.</p><p>So I wrote my own skeleton for Rust and wrapped it into a <a href=https://github.com/iliabylich/rust-bison-skeleton target=_blank rel="noreferrer nofollow">Rust library</a>
. It uses m4 format that is a macro language. Here&rsquo;s <a href=https://github.com/iliabylich/rust-bison-skeleton/blob/master/rust-bison-skeleton/bison/lalr1-rust.m4 target=_blank rel="noreferrer nofollow">the main file</a>
and <a href=https://github.com/iliabylich/rust-bison-skeleton/blob/master/tests/src/calc.y target=_blank rel="noreferrer nofollow">an example</a>
of how it can be used.</p><p>And then it took me about a week to backport the entire parser. The stack of it is a wrapper around <code>Vec&lt;Value></code> where <code>Value</code> is an enum type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>    Stolen,
</span></span><span style=display:flex><span>    Uninitialized,
</span></span><span style=display:flex><span>    None,
</span></span><span style=display:flex><span>    Token(Token),
</span></span><span style=display:flex><span>    TokenList(TokenList),
</span></span><span style=display:flex><span>    Node(Node),
</span></span><span style=display:flex><span>    NodeList(NodeList),
</span></span><span style=display:flex><span>    Bool(<span style=color:#66d9ef>bool</span>),
</span></span><span style=display:flex><span>    MaybeStrTerm(MaybeStrTerm),
</span></span><span style=display:flex><span>    Num(Num),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* For custom superclass rule */</span>
</span></span><span style=display:flex><span>    Superclass(Superclass),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... variants for other custom rules, there are ~25 of them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Initially result of each &ldquo;reduce&rdquo; action (that is stored in <code>yyval</code> variable) is set to <code>Value::Uninitialized</code>, reading <code>$&lt;Node>5</code> in your action is compiled into something like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>match</span> yystack.steal_value_at(<span style=color:#ae81ff>5</span>) {
</span></span><span style=display:flex><span>  Value::Node(node) <span style=color:#f92672>=&gt;</span> node,
</span></span><span style=display:flex><span>  other <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;not a node: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, other)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Doing <code>$$ = ...</code> is compiled into <code>yyval = ...</code>.</p><p>Why does reading &ldquo;steal&rdquo; the value from the stack? Because you can do <code>$$ = $&lt;Node>1</code> and push an element of the vector to the same vector. At the same time you can do something like <code>$$ = combine($&lt;Node>1, $&lt;Node>1)</code> where you want both arguments to be mutable. You can&rsquo;t do it in Rust.</p><p>This is why when you read any stack value you actually steal it by replacing what&rsquo;s in the stack with <code>Value::Stolen</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Stack {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>steal_value_at</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, i: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> self.stack.len();
</span></span><span style=display:flex><span>        std::mem::replace(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.stack[len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> i], Value::Stolen)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Value::Stolen</code> is just a placeholder value that indicates (when you see it) that your code previously has accessed the same stack entry. It&rsquo;s necessary to have it (or in general some kind of a default value that is set by <code>std::mem::take/replace</code>) to &ldquo;fix&rdquo; ownership model.</p><p>So then it was done and I started profiling it. At the very beginning it was incredibly slow, but I knew it, I had way too many <code>.clone()</code> calls in my code (in Rust that&rsquo;s a deep clone that is quite expensive in some cases). I added <code>jemalloc</code> and started profiling (<code>pprof-rs</code> &lt;3), I removed most clones and got ~160-170 thousand LOC/s.</p><p>Great, but I wanted more. ~20% of time in my benchmark was spent on this <code>std::mem::replace</code> call that swaps non-overlapping bytes. Initially I thought that I can&rsquo;t improve it (that&rsquo;s the fastest way to take the value AND to put a placeholder instead of it). At some point when I was writing C++ bindings I noticed that <code>sizeof(Node)</code> is 120 bytes (<code>Node</code> here is a C++ <code>Node</code> class) and it literally opened my eyes.</p><p>I&rsquo;ll write it in C, take a look at this structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Node
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> { <span style=color:#75715e>/* variants */</span> } variant;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> Args args;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> Def def;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> IfTernary if_ternary,
</span></span><span style=display:flex><span>        <span style=color:#75715e>// .. all other variant values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } variant_value;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> IfTernary
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>cond;
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>if_true;
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>if_false;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// .. a few more Range field, snip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>(Let&rsquo;s pretend that it can be compiled without forward declarations). This C <code>Node</code> is very, very similar to its Rust analogue. What&rsquo;s the size of this <code>Node</code>?</p><p>The size of <code>struct</code> is a sum of all of its nodes (let&rsquo;s simplify it and forget about memory alignment), the size of <code>union</code> is a maximum values its variant sizes.</p><p>Some specific node structures have multiple fields inside that are pointers (8 bytes on x86-64), and so the size of the generic <code>Node</code> is huge too.</p><p>Let&rsquo;s &ldquo;swap&rdquo; pointers and unions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Node
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> { <span style=color:#75715e>/* variants */</span> } variant;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> Args <span style=color:#f92672>*</span>args;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> Def <span style=color:#f92672>*</span>def;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IfTernary</span> (if_ternary,
</span></span><span style=display:flex><span>        <span style=color:#75715e>// .. all other variant values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } variant_value;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> IfTernary
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Node cond;
</span></span><span style=display:flex><span>    Node if_true;
</span></span><span style=display:flex><span>    Node if_false;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// .. a few more Range field, snip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>See? Now the size of the <code>union</code> is always <code>sizeof(void*)</code> and so <code>Node</code> is much smaller.</p><p>Why does it matter? Because <code>Vec&lt;T></code> in Rust is a wrapper for <code>*T</code> array. It&rsquo;s a contiguous and &ldquo;flat&rdquo; region of memory where all elements are &ldquo;inlined&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>|</span>item1<span style=color:#f92672>|</span>item2<span style=color:#f92672>|</span>item3<span style=color:#f92672>|</span>item4<span style=color:#f92672>|</span>...
</span></span></code></pre></div><p>and every item takes <code>sizeof(T)</code> memory. This is why doing <code>std::mem::replace(t1, t2)</code> can swap at most <code>sizeof(T)</code> bytes and this is why I want <code>T</code> to be as small as possible.</p><p>After turning my Rust model into</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    Args(Box<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    IfTernary(Box<span style=color:#f92672>&lt;</span>IfTernary<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// ...
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IfTernary</span> {
</span></span><span style=display:flex><span>    cond: <span style=color:#a6e22e>Node</span>,
</span></span><span style=display:flex><span>    if_true: <span style=color:#a6e22e>Node</span>,
</span></span><span style=display:flex><span>    if_false: <span style=color:#a6e22e>Node</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// other variants
</span></span></span></code></pre></div><p>I have got the same performance as Ripper.</p><h2 id=future-improvements>Future improvements</h2><p>I keep thinking about turning <code>lib-ruby-parser</code> into zero copy parser and I&rsquo;m believe it&rsquo;s very possible.</p><p>Currently all &ldquo;values&rdquo; that copy from source code (like numeric/string literals, token values) are copied into tokens and AST nodes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&#34;42&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tokens:
</span></span><span style=display:flex><span>    Token { name: &#34;tINTEGER&#34;, value: &#34;42&#34;, loc: 0...2 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nodes:
</span></span><span style=display:flex><span>    Int { value: &#34;42&#34;, expression_l: 0..2 }
</span></span></code></pre></div><p><code>lib-ruby-parser</code> constructs these <code>"42"</code> strings twice by copying a part of the input. Of course, for this particular case it&rsquo;s possible to store only ranges like <code>start...end</code>, but there are exceptions where values of tokens and AST nodes are not equal to input sub-strings (like escape sequences, <code>"\n"</code> or <code>"\u1234"</code>).</p><p>Even this way it&rsquo;s possible to introduce the following type system:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Value</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    SubstringOfInput(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u8</span>]),
</span></span><span style=display:flex><span>    ManuallyConstructed(Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The first variant is a reference, the latter is owned. Total value (of both token and AST node) could be just a vector of such enums, and if you parse a string <code>"foo\n"</code> you&rsquo;ll get</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>tokens:
</span></span><span style=display:flex><span>    Token {
</span></span><span style=display:flex><span>        name: &#34;tSTRING_CONTENT&#34;,
</span></span><span style=display:flex><span>        value: vec![
</span></span><span style=display:flex><span>            Value::SubstringOfInput(&amp;input[1..3]),
</span></span><span style=display:flex><span>            Value::ManuallyConstructed(vec![b&#39;\n&#39;])
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        loc: 1..5
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>However, then <code>input</code> must live as long as tokens and AST, and it sounds a bit problematic.</p><p>One option that I see is adding <code>Rc&lt;Input></code> to such values and store a range in <code>SubstringOfInput</code> enum variant. That&rsquo;s basically a <code>shared_ptr</code> from C++ world that wraps a raw pointer (like <code>T*</code>) + (pointer to) a number of existing &ldquo;clones&rdquo; of this pointer. Every time you copy it the shared number is incremented, destructor decreases it and once it&rsquo;s zero it also deletes <code>T</code>. It&rsquo;s quite cheap in terms of performance (something like <code>*n += 1</code> in constructor, <code>*n -= 1; drop(ptr) if n == 0;</code> in destructor)</p><h2 id=c-bindings>C bindings</h2><p>GitHub repository - <a href=https://github.com/lib-ruby-parser/c-bindings target=_blank rel="noreferrer nofollow">https://github.com/lib-ruby-parser/c-bindings</a></p><p>It took me a while to fix all segfaults, memory leaks and invalid memory access patterns (I&rsquo;m not a C developer). <code>Valgrind</code> and <code>asan</code> are incredibly useful tools, I can&rsquo;t even imagine how much time it would take to write bindings without these guys.</p><p>The API is very similar, there&rsquo;s an additional layer between C and Rust that converts output of <code>lib-ruby-parser</code> into C structures.</p><p>It uses a combination of <code>enum</code> and <code>union</code> to represent a <code>Node</code>.</p><h2 id=c-bindings-1>C++ bindings</h2><p><a href=https://github.com/lib-ruby-parser/cpp-bindings target=_blank rel="noreferrer nofollow">https://github.com/lib-ruby-parser/cpp-bindings</a></p><p>I personally like C++ much more than C. Smart pointers, containers, generics, but still worse for me than Rust. Upcoming standards are going to introduce even more features like modules and concepts, but, no.</p><p>The same story again, <code>valgrind</code>/<code>asan</code>, an extra layer that converts <code>Rust</code> objects to <code>C++</code> classes.</p><p>Also, my <code>valgrind</code> on Mac could not detect calling <code>free</code> on <code>C++</code> object (that&rsquo;s invalid, should be <code>delete</code> from C++), and so I had to setup a docker container locally to find and fix it.</p><p>It uses modern <code>std::variant&lt;Nodes...></code> to represent a <code>Node</code>.</p><h2 id=node-bindings>Node bindings</h2><p>As a proof of concept I also created bindings for Node.js - <a href=https://github.com/lib-ruby-parser/node-bindings target=_blank rel="noreferrer nofollow">https://github.com/lib-ruby-parser/node-bindings</a>
.</p><p>I was actually impressed (in a good way) how elegant is the API of <code>node-addon-api</code>. I worked with V8 C++ API about a 10 months ago in Electron and back in the day it was quite verbose and painful. Also, I remember an interesting feature of <code>TryCatch</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DoSomething</span>() {
</span></span><span style=display:flex><span>    TryCatch trycatch;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something that potentially does `throw err`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (trycatch.HasCaught()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// process trycatch.Exception() value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I personally think that this class abuses constructors/destructors in C++:</p><ul><li>constructor of <code>TryCatch</code> registers <code>this</code> in some global context (like <code>GetCurrentHandleScope().SetThrowHandler(this)</code></li><li>any code that throws a JavaScript error sets it on this <code>TryCatch</code> handler</li><li>it&rsquo;s possible to access an exception object from any place</li><li>destructor of <code>TryCatch</code> drops it</li></ul><p>I admit that it&rsquo;s smart, but it sounds way too implicit to me. I&rsquo;d like this interface to perform a register in a more explicit way (by calling <code>register/unregsiter</code> for example).</p><p>And I like that <code>node-addon-api</code> handles it <a href=https://github.com/nodejs/node-addon-api/blob/master/doc/error_handling.md#handling-a-n-api-c-exception target=_blank rel="noreferrer nofollow">even better</a>
by sticking to C++ exceptions.</p><p>Node.js bindings are based on C++ bindings from the previous section and they use a custom JavaScript class for each node type. Yes, there&rsquo;s also an extra layer that converts C++ objects to JavaScript.</p><h2 id=wasm>WASM</h2><p>Rust can be compiled to WebAssembly, here&rsquo;s a demo - <a href=https://lib-ruby-parser.github.io/wasm-bindings target=_blank rel="noreferrer nofollow">https://lib-ruby-parser.github.io/wasm-bindings</a>
.</p><p>It worked out of the box with one minor change. I had to mark <code>onigurama</code> dependency as optional and disable it for WASM build. Oh, I love how Rust can turn dependency into a feature that is optional and enabled/disabled by default as you configure it.</p><h2 id=final-thoughts>Final thoughts</h2><p>This is one of the biggest open-source projects that I have ever made. It can be used from Rust/C/C++/Node.js/browser. It&rsquo;s fast (but remember, it can get even faster), it&rsquo;s precise and it&rsquo;s very strongly typed.</p><p>Also, if you need a custom setup (like custom C++ classes or maybe a completely different API) there&rsquo;s a <a href=https://github.com/lib-ruby-parser/nodes target=_blank rel="noreferrer nofollow">meta-repository</a>
with all nodes information. You can use it to build your own bindings (or maybe new bindings for other languages), it has a <code>nodes</code> function that returns a <code>Vec&lt;Node></code> (<code>Node</code> here is just a &ldquo;configuration&rdquo; of a single <code>Node</code> variant from Rust - <a href=https://github.com/lib-ruby-parser/nodes/blob/master/src/node.rs#L6 target=_blank rel="noreferrer nofollow">source</a>
)</p><p>Bindings still have a room for improvements (for example, there&rsquo;s no way to pass custom <code>ParserOptions</code> to the parser), and current version of <code>lib-ruby-parser</code> is <code>0.7.0</code>.</p><p>However, I think it&rsquo;s ready. It&rsquo;s stable and I&rsquo;m not going to introduce any major changes anymore. I&rsquo;m going to cut <code>3.0.0</code> once Ruby 3 is released. Don&rsquo;t hesitate to drop me a message if it works well for you.</p></main><br><footer><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=e.textContent;navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script></footer></body></html>