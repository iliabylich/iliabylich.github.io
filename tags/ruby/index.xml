<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ruby on Ilya Bylich - Blog</title><link>https://iliabylich.github.io/tags/ruby/</link><description>Recent content in Ruby on Ilya Bylich - Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 28 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://iliabylich.github.io/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing bindings upside down</title><link>https://iliabylich.github.io/2021-12-28-writing-bindings-upside-down/</link><pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2021-12-28-writing-bindings-upside-down/</guid><description>Bindings Quite a long time ago I started writing C/C++/Ruby/Node.js/WASM bindings so I could call my Rust project from those languages. It is a Ruby language parser.
I tried multiple ways and found one that is very (VERY) controversial, but I think it deserves it&amp;rsquo;s own article.
Traditional way Let&amp;rsquo;s say you have a library in C. Just for simplicity, Rust is not special here.
How can you use it in C++?</description></item><item><title>lib-ruby-parser</title><link>https://iliabylich.github.io/2020-11-23-lib-ruby-parser/</link><pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2020-11-23-lib-ruby-parser/</guid><description>Intro So, I&amp;rsquo;m ready to announce that I have finished working on a new Ruby parser. It&amp;rsquo;s called lib-ruby-parser.
Key features:
It&amp;rsquo;s fast. It&amp;rsquo;s written in Rust and it&amp;rsquo;s slightly faster than Ripper. The difference is about 1-2% on my machine. It has a beautiful interface. Every single node has its own type that is documented. For example, take a look at CSend node that represents &amp;ldquo;conditional send&amp;rdquo; like foo&amp;amp;.bar. Here&amp;rsquo;s a list of all defined nodes .</description></item><item><title>Evaluating Ruby in Ruby</title><link>https://iliabylich.github.io/2020-01-26-evaluating-ruby-in-ruby/</link><pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2020-01-26-evaluating-ruby-in-ruby/</guid><description>TL;DR This article is about instruction sequences and evaluating them using pure Ruby.
The repository is available here .
Is it a Ruby implementation?
No. It&amp;rsquo;s just a runner of instructions. It is similar to MRI&amp;rsquo;s virtual machine, but it lacks many features and it&amp;rsquo;s 100 times slower.
Can I use it in my applications?
Of course, no. Well, if you want.
Does it work at all?
Yes, and it even passes most language specs from RubySpec test suite.</description></item><item><title>My favorite parts of Ruby</title><link>https://iliabylich.github.io/2018-07-19-my-favorite-parts-of-ruby/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2018-07-19-my-favorite-parts-of-ruby/</guid><description>Before we start Disclaimer #1 first of all I&amp;rsquo;d like to say that I really like Ruby. I write a ton of Ruby code every single day and I prefer it over other languages. Please, do not take it seriously, Ruby is nice, and this post is mostly a joke.
Disclaimer #2 I&amp;rsquo;m not going to cover popular things like flip-flops (thanks God they are deprecated in 2.6.0).
I was thinking for a while which item should go first, but finally I had to give up.</description></item><item><title>Ruby Marshalling from A to Z</title><link>https://iliabylich.github.io/2016-01-26-ruby-marshalling-from-a-to-z/</link><pubDate>Tue, 26 Jan 2016 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2016-01-26-ruby-marshalling-from-a-to-z/</guid><description>What is Marshalling Marshalling is a serialization process when you convert an object to a binary string. Ruby has a standard class Marshal that does all the job for serialization and deserialization. To serialize an object, use Marshal.dump, to deserialize - Marshal.load or Marshal.restore.
marshalled = Marshal.dump([1, 2, &amp;#39;string&amp;#39;, Object.new]) # =&amp;gt; &amp;#34;\x04\b[\ti\x06i\aI\&amp;#34;\vstring\x06:\x06ETo:\vObject\x00&amp;#34; Marshal.load(marshalled) # =&amp;gt; [1, 2, &amp;#34;string&amp;#34;, #&amp;lt;Object:0x00000002643000&amp;gt;] This article explains the format of marshalling and shows how to write a pure Ruby marshalling library compatible with the standard Ruby implementation.</description></item><item><title>HandlerSocket + Ruby</title><link>https://iliabylich.github.io/2015-11-10-handlersocket-with-ruby/</link><pubDate>Tue, 10 Nov 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-11-10-handlersocket-with-ruby/</guid><description>What is HandlerSocket (HS) a plugin for MySQL which allows you to read/write to MySQL and gives you a separate connection to MySQL and does not allow you to run SQL queries but allows to run simple CRUD queries only using indexes HandlerSocket query language is very simple (I&amp;rsquo;d even say it&amp;rsquo;s primitive), but it&amp;rsquo;s much faster than MySQL&amp;rsquo;s one. Though, of course, there are some limitations. Interested?
Installation You already have it if you are using Percona Server or MariaDB.</description></item><item><title>Saving execution context for later debugging</title><link>https://iliabylich.github.io/2015-08-21-saving-execution-context-for-later-debugging/</link><pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-08-21-saving-execution-context-for-later-debugging/</guid><description>The problem Consider the following situation: you have got an exception in production. Of course, all of us are good developers, but you know, sometimes *it just happens. What do you usually do to get some information about the error? You just grab the request parameters to test it locally, right? Then I might have a better solution for you: dump your memory once an error happens and restore the dump later to debug it.</description></item><item><title>Wrapping JavaScript library with Opal</title><link>https://iliabylich.github.io/2015-07-23-wrapping-javascript-library-with-opal/</link><pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-07-23-wrapping-javascript-library-with-opal/</guid><description>Introduction The task that is solved here is not real, but it&amp;rsquo;s still a good example of (probably?) real work with Opal. I could choose some complex enough JavaScript library and write a simple wrapper using Opal, but there&amp;rsquo;s no fun. Instead, let&amp;rsquo;s write a wrapper for existing rich client-side application (it may show you how to wrap your existing application logic). Well, wrapper for something like a client-side scheduler may sound boring, so I have chosen a JavaScript-based browser game called BrowserQuest written by Mozilla, and I&amp;rsquo;ll show you how to write a bot for it using Opal.</description></item><item><title>Capybara and asynchronous stuff</title><link>https://iliabylich.github.io/2015-07-01-capybara-and-asynchronous-stuff/</link><pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-07-01-capybara-and-asynchronous-stuff/</guid><description>What is Capybara, Poltergeist and PhantomJS? In this part I will try to cover the following aspects:
Running asynchronous code in a web driver Making the call synchronous Wrapping it into some common solution Advanced example - working with IndexedDB from Capybara PhantomJS First of all, we need to know what is PhantomJS. I would say it&amp;rsquo;s a &amp;rsquo;tool that acts like a browser but can be controlled from outside using simple command interface&amp;rsquo;.</description></item><item><title>Apipie - amazing tool for documenting your Rails API</title><link>https://iliabylich.github.io/2015-06-08-apipie-amazing-tool-for-documenting-your-rails-api/</link><pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-06-08-apipie-amazing-tool-for-documenting-your-rails-api/</guid><description>Apipie This article is about Apipie gem which provides a DSL for documenting your API. I will try to cover features that I personally use on my project.
Comparing to other tools for generating API documentation (yardoc, sdoc) I would say that the main thing that you gain with Apipie is that your documentation is a real ruby code, so you can write computations, concerns etc.
Here is a simple example of how it looks in code:</description></item><item><title>What is Ruby DSL</title><link>https://iliabylich.github.io/2015-05-26-what-is-ruby-dsl/</link><pubDate>Tue, 26 May 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-05-26-what-is-ruby-dsl/</guid><description>What is Ruby DSL? As you already know, DSL means domain-specific language. It&amp;rsquo;s like a language in a language. Here are some examples that we use every day:
class User attr_reader :name end class Profile &amp;lt; ActiveRecord::Base has_many :posts end class ApiController &amp;lt; ActionController::Base before_action :authenticate end But all these examples use rails-provided DSL, how about your own? First of all, you should know that all these methods (attr_reader, has_many and before_action) are actually class-methods of Module, ActiveRecord::Base and ActionController::Base.</description></item><item><title>Experimental MySQL HTTP API and Ruby</title><link>https://iliabylich.github.io/2015-05-14-experimental-mysql-http-api-and-ruby/</link><pubDate>Thu, 14 May 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-05-14-experimental-mysql-http-api-and-ruby/</guid><description>HTTP API Yes, MySQL has an HTTP API which is:
an experimental feature it ships as a native plugin only for 5.7 version Basically, it allows you to work with your database in the following ways:
as an SQL endpoint as a CRUD endpoint as a JSON document endpoint SQL endpoint It gives an ability to run queries like
GET http://host:port/sql/:database/:query For example
GET http://localhost:8080/sql/testdb/SELECT+1 is a synonym of SQL&amp;rsquo;s SELECT 1.</description></item><item><title>ExceptionManager gem</title><link>https://iliabylich.github.io/2015-04-14-exception-manager-gem/</link><pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate><guid>https://iliabylich.github.io/2015-04-14-exception-manager-gem/</guid><description>What is this? ExceptionManager is a gem for getting extra information from your exception.
Source code: https://github.com/iliabylich/exception_manager With this gem every time when you get an exception, it&amp;rsquo;s possible to grab subject of exception (the instance of class where raise happened), locals - local variables, subject_instance_variables and subject_class_variables
Examples:
require &amp;#39;exception_manager&amp;#39; ExceptionManager.enable! class TestClassThatRaisesException @@class_variable = :class_value def test_error(*args) @instance_variable = :instance_value raise &amp;#39;Test error&amp;#39; end end begin TestClassThatRaisesException.new.test_error(1, 2, 3) rescue =&amp;gt; e puts &amp;#34;Subject: #{e.</description></item></channel></rss>