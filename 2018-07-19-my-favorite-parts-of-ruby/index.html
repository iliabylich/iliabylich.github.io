<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon-precomposed sizes=192x192 href=/icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="My favorite parts of Ruby"><title>My favorite parts of Ruby | Ilya Bylich - Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.bc9c53f4c8c502891338c2b605412b41da61bca150c6a77869811fc296d3098c.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/>Home</a></li><li><a tabindex=-1 class=menu-link href=https://github.com/iliabylich>GitHub</a></li><li><a tabindex=-1 class=menu-link href=https://twitter.com/IlyaBylich>Twitter</a></li><li><a tabindex=-1 class=menu-link href=mailto:ibylich@gmail.com>Email me</a></li><li><a tabindex=-1 class=menu-link href=/index.xml>RSS</a></li></ul></nav><div id=single-header><h1>My favorite parts of Ruby</h1><div id=single-meta><span class=datesub>Jul 19, 2018</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://iliabylich.github.io/tags/ruby/>#ruby</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#before-we-start>Before we start</a></li><li><a href=#regexp-o-flag>Regexp &lsquo;o&rsquo; flag</a></li><li><a href=#invalid-encoding>Invalid encoding</a></li><li><a href=#nested-heredocs>Nested HEREdocs</a></li><li><a href=#setters-and-return-values>Setters and return values</a></li><li><a href=#passing-blocks-to-the--method>Passing blocks to the [] method</a></li><li><a href=#global-variables>Global variables</a></li><li><a href=#instance-variables-without--prefix>Instance variables without @ prefix</a></li><li><a href=#implicit-coercing>Implicit coercing</a></li><li><a href=#implicit-to_a>Implicit <code>to_a</code></a></li><li><a href=#heredoc-identifiers-and-newlines>HEREdoc identifiers and newlines</a></li><li><a href=#1if-true><code>1if true</code></a></li><li><a href=#defined><code>defined?</code></a></li><li><a href=#return-in-the-classmodule-body><code>return</code> in the class/module body</a></li><li><a href=#meta-characters>Meta-characters</a></li><li><a href=#invisible-rest-argument>Invisible rest argument</a></li><li><a href=#dynamicity-of-optarg-default-values>Dynamicity of <code>optarg</code> default values</a></li><li><a href=#shadow-arguments>Shadow arguments</a></li><li><a href=#dynamicity-of-rescue>Dynamicity of rescue</a></li><li><a href=#positionalkeyword-arguments>Positional/keyword arguments</a></li><li><a href=#final-words>Final words</a></li></ul></nav></aside><main><h2 id=before-we-start>Before we start</h2><p><strong>Disclaimer #1</strong> first of all I&rsquo;d like to say that I really like Ruby. I write a ton of Ruby code every single day and I prefer it over other languages. Please, do not take it seriously, Ruby is nice, and this post is mostly a joke.</p><p><strong>Disclaimer #2</strong> I&rsquo;m not going to cover popular things like flip-flops (thanks God they are deprecated in 2.6.0).</p><p>I was thinking for a while which item should go first, but finally I had to give up. I think all items are funny.</p><h2 id=regexp-o-flag>Regexp &lsquo;o&rsquo; flag</h2><p>I don&rsquo;t even know if there&rsquo;s anyone in the world using it. <code>o</code> flag is a very, very magical thing that &ldquo;freezes&rdquo; a regexp after parsing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>.</span>upto(<span style=color:#ae81ff>5</span>) { <span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> puts <span style=color:#e6db74>/</span><span style=color:#e6db74>#{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>/o</span><span style=color:#f92672>.</span>source }
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>.</span>times<span style=color:#f92672>.</span>map { <span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> <span style=color:#e6db74>/</span><span style=color:#e6db74>#{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>/o</span><span style=color:#f92672>.</span>object_id }
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>70135960411140</span>, <span style=color:#ae81ff>70135960411140</span>, <span style=color:#ae81ff>70135960411140</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>That&rsquo;s a special syntax to define an inline regexp as a constant. It is a constant because its value is constant (<code>object_id</code> returns the same value). I think the main purpose of such flag is to reduce objects allocation, and I believe it was not initially designed for such cases. If you are too lazy to extract a static regexp to a constant, simply add an <code>o</code> flag.</p><h2 id=invalid-encoding>Invalid encoding</h2><p>Well, I have to confess, sometimes I hate Ruby for various reasons, this feature is one of them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># encoding: utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xff</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>puts s<span style=color:#f92672>.</span>encoding
</span></span><span style=display:flex><span>puts s<span style=color:#f92672>.</span>valid_encoding?
</span></span><span style=display:flex><span>puts s<span style=color:#f92672>.</span>bytes
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ruby test.rb
</span></span><span style=display:flex><span>ruby 2.5.1p57 <span style=color:#f92672>(</span>2018-03-29 revision 63029<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>x86_64-darwin17<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>UTF-8
</span></span><span style=display:flex><span>false
</span></span><span style=display:flex><span><span style=color:#ae81ff>255</span>
</span></span></code></pre></div><p>In this case string is not a &ldquo;real&rdquo; string. This bytes sequence is simply invalid for UTF-8 (in UTF-8 any codepoint > 127 works as a flag that indicates that the char is multi-byte and the next char (or chars) defines a real value), but Ruby allows it. It&rsquo;s not even a String, it&rsquo;s just a container of bytes. And for some reason Ruby allows you to pack an arbitrary sequence of bytes into a string, and if you want to ask &ldquo;Is it valid?&rdquo; you have a (I think) conceptually wrong <code>String#valid_encoding?</code> method. Maybe the right way to solve it would be to:</p><ol><li>reject such strings during parsing (and throw <code>SyntaxError</code>)</li><li>raise an error when someone tries to put wrong bytes sequence to the string</li><li>remove <code>String#valid_encoding?</code> method</li></ol><h2 id=nested-heredocs>Nested HEREdocs</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>p <span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;A</span><span style=color:#e6db74>#{</span>b<span style=color:#e6db74>}</span><span style=color:#e6db74>C&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;A</span><span style=color:#e6db74>#{</span>b<span style=color:#e6db74>}</span><span style=color:#e6db74>C&#34;</span>
</span></span><span style=display:flex><span>A<span style=color:#75715e>#{b}C</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>str
</span></span><span style=display:flex><span>A<span style=color:#75715e>#{b}C</span>
</span></span></code></pre></div><p>I&rsquo;m quite sure that there are no syntax highlighters that can <strong>properly</strong> handle this code. At the moment of writing GitHub is unable to do that. Try evaluating this code in IRB.</p><h2 id=setters-and-return-values>Setters and return values</h2><p>As you most probably know in Ruby setters can&rsquo;t have return values. They always return their arguments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span><span style=color:#f92672>=</span>(a)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>self<span style=color:#f92672>.</span>m <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;return me&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; &#34;return me&#34;</span>
</span></span></code></pre></div><p>Yes, you can make a return by calling a setter method using <code>Kernel#send</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> send(<span style=color:#e6db74>:m</span><span style=color:#f92672>=</span>, <span style=color:#e6db74>&#39;return me&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>So, the general rule is like &ldquo;if you call a setter method without :send you can&rsquo;t make a return&rdquo;. Wrong!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>[]=</span>(a); <span style=color:#ae81ff>42</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>[]= <span style=color:#e6db74>&#39;return me&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>I can&rsquo;t imagine any reason to use such syntax, most probably it should be deprecated.</p><h2 id=passing-blocks-to-the--method>Passing blocks to the [] method</h2><p>Imagine the following piece of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>[]</span>(idx, <span style=color:#f92672>&amp;</span>block)
</span></span><span style=display:flex><span>  puts idx <span style=color:#f92672>+</span> block<span style=color:#f92672>.</span>call
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>self<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span> { <span style=color:#ae81ff>2</span> }
</span></span></code></pre></div><p>Looks valid, right? We pass a positional argument <code>1</code> and a block that returns <code>2</code> to the method called <code>[]</code>. The method should print <code>3</code>. Let&rsquo;s run it with Ruby 2.5:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ruby -v test.rb
</span></span><span style=display:flex><span>2.5.1p57 <span style=color:#f92672>(</span>2018-03-29 revision 63029<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>x86_64-darwin17<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p><code>1 + 2 == 3</code>, everything is fine. Let&rsquo;s try 2.4:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ruby -v test.rb
</span></span><span style=display:flex><span>ruby 2.4.4p296 <span style=color:#f92672>(</span>2018-03-28 revision 63013<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>x86_64-darwin17<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>test.rb:5: syntax error, unexpected <span style=color:#f92672>{</span> arg, expecting end-of-input
</span></span><span style=display:flex><span>self<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>{</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         ^
</span></span></code></pre></div><p>Yes, this syntax was introduced in Ruby 2.5. Did you hear any announcements about it?</p><p><strong>Spoiler: there are no tests for this syntax in ruby/ruby repository. Guess why?</strong></p><h2 id=global-variables>Global variables</h2><p>Let&rsquo;s take a simple code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>].</span>join
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;123&#34;</span>
</span></span></code></pre></div><p>Do you know anything about &ldquo;pure&rdquo; functions (or pure methods in this case)? Ideally methods should only use <code>self</code> and provided arguments. Relying on any global state is bad because you are not the only one who can mutate it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> $, <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Ruby&#39;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>].</span>join
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;1Ruby2Ruby3&#34;</span>
</span></span></code></pre></div><p><code>String#join</code> uses a global variable as a default value for the separator. Literally <code>def join(sep = $,)</code>.</p><p>By the way, maybe I should put the following code to my current project before leaving it. How much time is needed to find it?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>if</span> rand <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>.</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  $, <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>102</span>, <span style=color:#ae81ff>105</span>, <span style=color:#ae81ff>110</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>109</span>, <span style=color:#ae81ff>101</span><span style=color:#f92672>].</span>pack(<span style=color:#e6db74>&#39;c*&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>After doing <code>require 'english'</code> you get two aliases for this global variable: <code>$OUTPUT_FIELD_SEPARATOR</code> and <code>$OFS</code>, that&rsquo;s the real name of this global variable.</p><h2 id=instance-variables-without--prefix>Instance variables without @ prefix</h2><p>Spoiler: you may think that it&rsquo;s impossible because the parser rejects such code. But in fact, Ruby allows it and there are even some specs for this - <a href=https://github.com/ruby/spec/blob/master/optional/capi/object_spec.rb#L803 target=_blank rel="noreferrer nofollow">RubySpec</a>
. I don&rsquo;t know much about Ruby internals, but at least one class uses instance variables without <code>@</code>, it&rsquo;s called <code>Range</code>. <code>(0..3)</code> has 3 instance variables:</p><ul><li><code>excl</code> = false</li><li><code>begin</code> = 0</li><li><code>end</code> = 3</li></ul><p>&ldquo;Any proves?&rdquo; - let&rsquo;s marshal it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>Marshal</span><span style=color:#f92672>.</span>dump(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x04\b</span><span style=color:#e6db74>o:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Range</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>exclF:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>begini</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>endi</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>This string contains a version (4.8), an indicator of the object (<code>o</code>), a symbol <code>:Range</code>, a hash of instance variables <code>{ excl: false, begin: 0, end: 3 }</code>.</p><p>Let&rsquo;s change a class name a bit (but keep the same length to not break anything):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>Marshal</span><span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x04\b</span><span style=color:#e6db74>o:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Hello</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>exclF:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>begini</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>endi</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                             <span style=color:#f92672>^^^^^</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#75715e>#&lt;Hello:0x00007fece707a9c8&gt;</span>
</span></span></code></pre></div><p>Now we can change, for example, <code>excl</code> to <code>@one</code> (again, to keep the length the same):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>Marshal</span><span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x04\b</span><span style=color:#e6db74>o:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Hello</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>@oneF:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>begini</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>endi</span><span style=color:#ae81ff>\b</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                                       <span style=color:#f92672>^^^^</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#75715e>#&lt;Hello:0x00007fece70533a0 @one=false&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> _<span style=color:#f92672>.</span>instance_variables
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span><span style=color:#e6db74>:@one</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>The conclusion is simple: <code>excl</code> is an instance variable, but <code>Kernel#instance_variables</code> hides it.</p><p><code>Kernel#instance_variable_get / set</code> and Ruby Lexer are the places that validate instance variable names. Low-level C calls don&rsquo;t do it and in general when you write a C extension you may easily get an instance variable without <code>@</code> char.</p><p>You can read my article about marshalling to get a full overview of its internals.</p><h2 id=implicit-coercing>Implicit coercing</h2><p>As you may know there are two types of coercing in Ruby: explicit and implicit.</p><p>Explicit is when you call methods like <code>to_a</code>, <code>to_h</code>, <code>to_s</code>. When the object is not an Array/Hash/String, but can become it.</p><p>Implicit is when Ruby calls methods like <code>to_ary</code>, <code>to_hash</code>, <code>to_str</code> for you. When the object <strong>acts</strong> as an Array/Hash/String and converting it to the corresponding class must happen automatically.</p><p>There are a lot of methods in the core library that are documented as &ldquo;taking a String as an argument&rdquo; but in fact they accept any objects that can be implicitly converted to a String.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>Object</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>o</span><span style=color:#f92672>.</span><span style=color:#a6e22e>to_str</span>; <span style=color:#e6db74>&#34;hello&#34;</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;string&#34;</span> <span style=color:#f92672>+</span> o
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;stringhello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;hello&#34;</span><span style=color:#f92672>.</span>casecmp(o)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;testhello&#34;</span><span style=color:#f92672>.</span>chomp(o)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;test&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;hellostr&#34;</span><span style=color:#f92672>.</span>delete_prefix(o)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;str&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;hello world&#34;</span><span style=color:#f92672>.</span>start_with?(o)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>There are more methods like this, and not only for String.</p><p>Also, there&rsquo;s a way to implicitly convert an abstract Object to</p><ul><li>Array (using <code>*</code>)</li><li>Hash (using <code>**</code>)</li><li>Proc (using <code>&</code>)</li></ul><p>Sometimes it can be ridiculous:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>to_ary</span>; <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>to_hash</span>; { <span style=color:#e6db74>a</span>: <span style=color:#ae81ff>1</span> }; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>to_proc</span>; proc { <span style=color:#ae81ff>42</span> }; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>(<span style=color:#f92672>*</span>rest, <span style=color:#f92672>**</span>kwargs, <span style=color:#f92672>&amp;</span>block)
</span></span><span style=display:flex><span>  rest<span style=color:#f92672>.</span>length <span style=color:#f92672>+</span> kwargs<span style=color:#f92672>.</span>length <span style=color:#f92672>+</span> block<span style=color:#f92672>.</span>call
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>user <span style=color:#f92672>=</span> <span style=color:#66d9ef>User</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>m(<span style=color:#f92672>*</span>user, <span style=color:#f92672>**</span>user, <span style=color:#f92672>&amp;</span>user)
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; 44</span>
</span></span></code></pre></div><p>I&rsquo;m not sure that this feature is required. But remember, that&rsquo;s only my opinion.</p><p>Explicit coercing is explicit and forces you to call <code>to_a/to_h/to_s</code> manually. Probably it would be better to restrict <code>*/**/&</code> operators to accept only <code>Array/Hash/Proc</code> objects (and to be as strict as possible).</p><h2 id=implicit-to_a>Implicit <code>to_a</code></h2><p>Previous section says that Ruby never invokes methods for explicit coercing on its own. There&rsquo;s one exception: <code>to_a</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>Object</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>o</span><span style=color:#f92672>.</span><span style=color:#a6e22e>to_a</span>;   <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>o</span><span style=color:#f92672>.</span><span style=color:#a6e22e>to_ary</span>; <span style=color:#f92672>[</span><span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span><span style=color:#f92672>]</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a, b, c <span style=color:#f92672>=</span> o
</span></span><span style=display:flex><span>p <span style=color:#f92672>[</span>a, b, c<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [4, 5, 6]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># so, it calls to_ary, that&#39;s an implicit coercing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a, b, c <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>o
</span></span><span style=display:flex><span>p <span style=color:#f92672>[</span>a, b, c<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [1, 2, 3]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># it calls to_a !! an explicit coercing gets called by Ruby</span>
</span></span></code></pre></div><p>For some reason the concept of implicit/explicit coercing does not work for this case.</p><h2 id=heredoc-identifiers-and-newlines>HEREdoc identifiers and newlines</h2><p>The section about nested HEREdocs shows a HEREdoc identifier that has an interpolation inside. Also, it&rsquo;s possible to use <code>"\n"</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>p <span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;HERE
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>content
</span></span><span style=display:flex><span><span style=color:#66d9ef>HERE</span>
</span></span></code></pre></div><p>it prints <code>"content\n"</code>. For some reason newline is not allowed in the middle of the HEREdoc identifier (and don&rsquo;t get me wrong, I think that newlines should be rejected, no matter in the middle or in the end).</p><h2 id=1if-true><code>1if true</code></h2><p>Yes, that&rsquo;s a valid syntax. Ruby has very special rules for white-spaces and newlines. <code>1i</code> is a special syntax for complex numbers, but <code>1if true</code> is <code>1 if true</code>. There&rsquo;s also a <code>1r</code> syntax for rational numbers, and yes, <code>1rescue nil</code> is <code>1 rescue nil</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>rescue</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>But what about <code>1ri</code>?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>rif <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>SyntaxError</span>: (syntax error, unexpected tIDENTIFIER, expecting <span style=color:#66d9ef>end</span><span style=color:#f92672>-</span>of<span style=color:#f92672>-</span>input)
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>rif <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>^~~</span>
</span></span></code></pre></div><p>Sweet. Bonus:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#ae81ff>1</span><span style=color:#66d9ef>return</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SyntaxError</span> : (syntax error, unexpected keyword_return, expecting keyword_end)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#ae81ff>1</span><span style=color:#66d9ef>return</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>^~~~~~</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#ae81ff>1</span><span style=color:#66d9ef>retry</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>SyntaxError</span>: (syntax error, unexpected keyword_retry, expecting keyword_end)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#ae81ff>1</span><span style=color:#66d9ef>retry</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>^~~~~</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; (<span style=color:#ae81ff>1</span><span style=color:#66d9ef>redo</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>SyntaxError</span>: syntax error, unexpected keyword_redo, expecting keyword_end)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#ae81ff>1</span><span style=color:#66d9ef>redo</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>^~~~</span>
</span></span></code></pre></div><p>Looks like there are special rules for keyword modifiers.</p><h2 id=defined><code>defined?</code></h2><p>I think this is the most controversial keyword in Ruby. It takes literally everything as an argument.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(self)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;self&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;nil&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;false&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;assignment&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> a
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; defined?(a)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;local-variable&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(<span style=color:#66d9ef>begin</span>; <span style=color:#ae81ff>1</span>; <span style=color:#ae81ff>2</span>; <span style=color:#ae81ff>3</span>; <span style=color:#66d9ef>end</span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;expression&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(self<span style=color:#f92672>.</span>m)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#66d9ef>end</span>; defined?(self<span style=color:#f92672>.</span>m)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;method&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>module</span> M; <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; <span style=color:#66d9ef>end</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>include</span> M
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>; defined?(<span style=color:#66d9ef>super</span>); <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> m
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;super&#34;</span>
</span></span></code></pre></div><p>It also can return <code>yield</code>, <code>constant</code>, <code>class variable</code>, <code>instance-variable</code> and <code>global-variable</code>. By the way, where&rsquo;s the dash in the <code>class variable</code>?</p><p>That&rsquo;s a strong violation of a single responsibility principle. This keyword can handle EVERYTHING!</p><p>Moreover, it handles all kinds of exceptions inside:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Object</span><span style=color:#f92672>.</span>new
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> defined?(
</span></span><span style=display:flex><span>  a<span style=color:#f92672>.</span>b<span style=color:#f92672>.</span>c<span style=color:#f92672>.</span>d <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>MissingConstant</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>yield</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>super</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>nil</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  eval(<span style=color:#e6db74>&#34;!@#$%^&#34;</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  require(<span style=color:#e6db74>&#39;missing_file&#39;</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><p>That&rsquo;s too much for a single keyword.</p><h2 id=return-in-the-classmodule-body><code>return</code> in the class/module body</h2><p>You can&rsquo;t call <code>return</code> from a module/class body:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>; <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SyntaxError</span> (<span style=color:#66d9ef>Invalid</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>in</span> class<span style=color:#f92672>/</span><span style=color:#66d9ef>module</span> body)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>; <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>^~~~~~</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>module</span> A; <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SyntaxError</span> (<span style=color:#66d9ef>Invalid</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>in</span> class<span style=color:#f92672>/</span><span style=color:#66d9ef>module</span> body)
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> A; <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>^~~~~~</span>
</span></span></code></pre></div><p>It throws a <code>SyntaxError</code>, i.e. even if the code is unreachable, you still can&rsquo;t write it, it&rsquo;s simply invalid.</p><p>But you can use <code>return</code> in a singleton class body:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#f92672>&lt;&lt;</span> self; <span style=color:#66d9ef>return</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>LocalJumpError</span>: unexpected <span style=color:#66d9ef>return</span>
</span></span></code></pre></div><p>Now that&rsquo;s a <code>LocalJumpError</code>, so this code can be interpreted if nobody touches it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#f92672>&lt;&lt;</span> self; <span style=color:#66d9ef>return</span>; <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><h2 id=meta-characters>Meta-characters</h2><p>Again, this is something that probably could be removed from Ruby, I don&rsquo;t know anyone using it.</p><p>Meta-character is a special sequence of characters that gets interpreted as a single character. Most probably you know one of them - <code>\uDDDD</code>. But there are more:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\u1234&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;ሴ&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\377</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xFF</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xFF</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xFF</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\C-</span><span style=color:#ae81ff>\a</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\a</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\ca&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;\u0001&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\M-a&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xE1</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\C-\M-f&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x86</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\M-\cf&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x86</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\c\M-f&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x86</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>That&rsquo;s absolutely insane! Moreover, Ruby starting from 2.6 ignores spaces (and tabs) around codepoints in the <code>\u{}</code> syntax:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;\u{    123   456   }&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;ģі&#34;</span>
</span></span></code></pre></div><h2 id=invisible-rest-argument>Invisible rest argument</h2><p>MRI has a special rule for <code>Proc</code> class: it expands a single array argument:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> proc { <span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> <span style=color:#f92672>[</span>a, b<span style=color:#f92672>]</span> }<span style=color:#f92672>.</span>call(<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>&mldr; but only if it the proc takes more than one argument. And if the arity is 1 it works as you&rsquo;d expect:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> proc { <span style=color:#f92672>|</span>a<span style=color:#f92672>|</span> <span style=color:#f92672>[</span>a<span style=color:#f92672>]</span> }<span style=color:#f92672>.</span>call(<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>And here&rsquo;s an edge case: it&rsquo;s possible to put a trailing comma after arguments list:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> proc { <span style=color:#f92672>|</span>a,<span style=color:#f92672>|</span> <span style=color:#f92672>[</span>a<span style=color:#f92672>]</span> }<span style=color:#f92672>.</span>call(<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>&mldr; and MRI still expands an array. So how many arguments does this proc have?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> proc{<span style=color:#f92672>|</span>a,<span style=color:#f92672>|</span>}<span style=color:#f92672>.</span>arity
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>What&rsquo;s going on?</p><p>The answer is simple: there&rsquo;s an invisible rest argument after trailing comma. The real interface of this proc is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>proc { <span style=color:#f92672>|</span>a, <span style=color:#f92672>*|</span> }
</span></span></code></pre></div><p>MRI generates it for you and then hides it.</p><p>If you are interested in implementation details take a look at <a href=https://github.com/ruby/ruby/blob/trunk/parse.y#L3007-L3015 target=_blank rel="noreferrer nofollow">parse.y</a>
- there&rsquo;s a special field <code>excessed_comma</code> that works as a flag.</p><p>Also, you can clearly see in the Ripper&rsquo;s output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> require <span style=color:#e6db74>&#39;ripper&#39;</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>Ripper</span><span style=color:#f92672>.</span>sexp(<span style=color:#e6db74>&#39;proc{|a|}&#39;</span>)<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>][</span><span style=color:#ae81ff>0</span><span style=color:#f92672>][</span><span style=color:#ae81ff>2</span><span style=color:#f92672>][</span><span style=color:#ae81ff>1</span><span style=color:#f92672>][</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span><span style=color:#e6db74>:params</span>, <span style=color:#f92672>[[</span><span style=color:#e6db74>:@ident</span>, <span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span><span style=color:#f92672>]]]</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>Ripper</span><span style=color:#f92672>.</span>sexp(<span style=color:#e6db74>&#39;proc{|a,|}&#39;</span>)<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>][</span><span style=color:#ae81ff>0</span><span style=color:#f92672>][</span><span style=color:#ae81ff>2</span><span style=color:#f92672>][</span><span style=color:#ae81ff>1</span><span style=color:#f92672>][</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span><span style=color:#e6db74>:params</span>, <span style=color:#f92672>[[</span><span style=color:#e6db74>:@ident</span>, <span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#f92672>[</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span><span style=color:#f92672>]]]</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Do you see the difference?</p><h2 id=dynamicity-of-optarg-default-values>Dynamicity of <code>optarg</code> default values</h2><p>In Ruby optional arguments are very, very powerful. You can pass pretty much anything as a default value of the argument in the method signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>(a <span style=color:#f92672>=</span> (puts <span style=color:#e6db74>&#39;no a&#39;</span>)); a; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> m(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> m
</span></span><span style=display:flex><span>no a
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><p>I don&rsquo;t like it in general. I would say it&rsquo;s too powerful, you can abuse this feature and do some really crazy stuff. For example like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>(a <span style=color:#f92672>=</span> (<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>nil</span>))
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>What does this method return when you call it without any arguments? Yep, it returns <code>1</code>.</p><p>The reason why it works this way is that MRI inlines optional arguments initialization to the method body, so for VM this code actually looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>(a <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>  a <span style=color:#f92672>||=</span> (<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>You can even go further and redefine a method in its arguments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>factorial</span>(
</span></span><span style=display:flex><span>  n,
</span></span><span style=display:flex><span>  redefinition <span style=color:#f92672>=</span> <span style=color:#e6db74>&lt;&lt;-RUBY,
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    define_method(__method__) <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      _ <span style=color:#f92672>=</span> (<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>; <span style=color:#66d9ef>nil</span>),
</span></span><span style=display:flex><span>      _ <span style=color:#f92672>=</span> eval(redefinition),
</span></span><span style=display:flex><span>      _ <span style=color:#f92672>=</span> (<span style=color:#66d9ef>return</span> n <span style=color:#f92672>*</span> (n <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>; send(__method__)); <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>RUBY</span>
</span></span><span style=display:flex><span>  _ <span style=color:#f92672>=</span> eval(redefinition),
</span></span><span style=display:flex><span>  _ <span style=color:#f92672>=</span> (<span style=color:#66d9ef>return</span> send(__method__); <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e># &lt;&lt;EMPTY BODY&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p factorial(<span style=color:#ae81ff>5</span>)
</span></span></code></pre></div><p>Yes, this method has no body but is still capable of calculating factorial.</p><h2 id=shadow-arguments>Shadow arguments</h2><p>I think only people that work with parsing tools are aware of this feature. That&rsquo;s a special kind of argument that &ldquo;shadows&rdquo; outer variable. The syntax is <code>|;shadowarg|</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; proc { n }<span style=color:#f92672>.</span>call
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>pry<span style=color:#f92672>&gt;</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; proc { <span style=color:#f92672>|</span>;n<span style=color:#f92672>|</span> n }<span style=color:#f92672>.</span>call
</span></span><span style=display:flex><span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><p>Basically, it&rsquo;s nice to have an ability to use own isolated set of local variables in your block and be sure that you don&rsquo;t change an outer scope. But again, does anyone use it? And also it reminds me a <code>var</code> keyword from the JavaScript.</p><h2 id=dynamicity-of-rescue>Dynamicity of rescue</h2><p>Take a look at the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>raise</span> <span style=color:#e6db74>&#39;error message&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>rescue</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>RuntimeError</span>
</span></span><span style=display:flex><span>  puts <span style=color:#e6db74>&#39;caught an error&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Looks correct from the first glance, right? And it even prints <code>caught an error</code>, but in fact it has an invalid code construction. It is valid from the parser perspective, but I think you don&rsquo;t want to write such code, it redefines a constant <code>RuntimeError</code>.</p><p>Ruby has a very tricky mechanism of converting getters to setters. It can convert</p><ul><li><code>local variable get</code> to <code>local variable set</code> (most popular usage of <code>rescue</code> handler)</li><li><code>instance variable get</code> to <code>instance variable set</code></li><li><code>const get</code> to <code>const set</code></li><li><code>getter method</code> to <code>setter method</code></li><li>and many more like global/class variables</li></ul><p>So if you have <code>object = OpenStruct.new</code> and you catch an error using <code>rescue => object.field</code> you&rsquo;ll get <code>object.field = &lt;thrown error></code> called under the hood.</p><p>That&rsquo;s definitely very, very flexible but does anyone need it? I&rsquo;d better reject all cases above except local variables.</p><p>I have seen the first snippet in the real codebase and it was quite difficult to understand why the spec that asserts something like <code>expect { code construction }.to raise_error(RuntimeError)</code> does not work.</p><h2 id=positionalkeyword-arguments>Positional/keyword arguments</h2><p>I used to think that positional and keyword arguments act like two completely separate groups of arguments. If the last argument is a Hash and you pass it to the method call it</p><ul><li>populates all keyword arguments</li><li>raises an error if some keyword arguments are missing</li><li>sets default values to missing optional keyword arguments</li></ul><p>But I was wrong. One argument value can populate both positional <strong>and</strong> keyword argument at the same item:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>m</span>(a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>b</span>: <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>a, b<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p m(<span style=color:#e6db74>b</span>: <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;b&#39;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># =&gt; [{&#34;b&#34;=&gt;3}, 2]</span>
</span></span></code></pre></div><p>I feel like it&rsquo;s a bug:</p><ol><li>There&rsquo;s only one argument provided</li><li>And some of its keys are not symbols</li><li>So MRI should not use it for keyword arguments initialization</li><li>And <code>a</code> must be <code>{ b: 2, 'b' => 3 }</code></li><li>And so <code>b</code> must be just <code>1</code> (default value)</li></ol><h2 id=final-words>Final words</h2><p>This story is not about bad parts of Ruby or anything like that. Don&rsquo;t feel bad because of this - I&rsquo;m really sorry. I was trying to cover some rarely used features and explain as much as I can.</p></main><br><footer><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const n=e.textContent;navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script></footer></body></html>