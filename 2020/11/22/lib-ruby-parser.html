<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      lib-ruby-parser &middot; Ilya Bylich
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="192x192" href="/public/apple-touch-icon-192-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EBV7BR668S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EBV7BR668S');
</script>

</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Ilya Bylich
        </a>
      </h1>
      <p class="lead">I'm a Ruby/Rust developer, sometimes I write long technical stories</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      <a class="sidebar-nav-item" href="https://github.com/iliabylich">GitHub</a>
      <a class="sidebar-nav-item" href="https://twitter.com/IlyaBylich">Twitter</a>
      <a class="sidebar-nav-item" href="mailto:ibylich@gmail.com">Email me</a>
      <a class="sidebar-nav-item" href="https://iliabylich.github.io/feed.xml">RSS</a>

      <span class="sidebar-nav-item">
  <label for="current-theme">Theme</label>
  <select id="current-theme">
    <option>08</option>
    <option>09</option>
    <option>0a</option>
    <option>0b</option>
    <option>0c</option>
    <option>0d</option>
    <option>0f</option>
  </select>

  <script type="text/javascript">
    class Theme {
      static DEFAULT = "0b";

      static getCurrent() {
        return localStorage.getItem("current-theme") || Theme.DEFAULT;
      }

      static setCurrent(theme) {
        localStorage.setItem("current-theme", theme);
        document.body.className = `theme-base-${theme}`;
      }
    }

    const themeSelector = document.getElementById("current-theme");
    Theme.setCurrent(Theme.getCurrent());
    themeSelector.value = Theme.getCurrent();

    themeSelector.onchange = (e) => {
      const theme = e.target.value;
      Theme.setCurrent(theme);
    }
  </script>
</span>

    </nav>

    <p>&copy; 2023. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">lib-ruby-parser</h1>
  <span class="post-date">22 Nov 2020</span>

  <div class="reading-time" title="Estimated read time">
  This article will take 12 minutes to read
  <br />
  (or maybe less, the algorithm treats code as text)
</div>


  <div id="table-of-contents">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#intro">Intro</a></li>
<li class="toc-entry toc-h2"><a href="#implementation">Implementation</a></li>
<li class="toc-entry toc-h2"><a href="#future-improvements">Future improvements</a></li>
<li class="toc-entry toc-h2"><a href="#c-bindings">C bindings</a></li>
<li class="toc-entry toc-h2"><a href="#c-bindings-1">C++ bindings</a></li>
<li class="toc-entry toc-h2"><a href="#node-bindings">Node bindings</a></li>
<li class="toc-entry toc-h2"><a href="#wasm">WASM</a></li>
<li class="toc-entry toc-h2"><a href="#final-thoughts">Final thoughts</a></li>
</ul>
  </div>

  <h2 id="intro">Intro</h2>

<p>So, I’m ready to announce that I have finished working on a new Ruby parser. It’s called <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code>.</p>

<p>Key features:</p>

<ol>
  <li>It’s fast. It’s written in Rust and it’s slightly faster than Ripper. The difference is about 1-2% on my machine.</li>
  <li>It has a beautiful interface. Every single node has its own type that is documented. For example, take a look at <a href="https://docs.rs/lib-ruby-parser/0.7.0/lib_ruby_parser/nodes/struct.CSend.html"><code class="language-plaintext highlighter-rouge">CSend</code> node</a> that represents “conditional send” like <code class="language-plaintext highlighter-rouge">foo&amp;.bar</code>. <a href="https://docs.rs/lib-ruby-parser/0.7.0/lib_ruby_parser/nodes/index.html">Here’s a list of all defined nodes</a>. Both Ripper and <code class="language-plaintext highlighter-rouge">RubyVM::AST</code> have no documentation of their AST format. <code class="language-plaintext highlighter-rouge">whitequark/parser</code> <a href="https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md">has a great documentation</a>, but its AST is not “static”.</li>
  <li>What’s “static AST”? By saying that I mean that if documentation says that “N is not-nullable” then it’s true no matter what. <code class="language-plaintext highlighter-rouge">whitequark/parser</code> does a great job, but the nature of dynamic language does not allow it to provide such guarantees. I’ll show a few examples later.</li>
  <li>It’s precise. Unlike <code class="language-plaintext highlighter-rouge">whitequark/parser</code>, its lexer (or tokenizer if it sounds better for you) is based on MRI’s <code class="language-plaintext highlighter-rouge">parse.y</code>. What does it mean? It means that I was not able to find any difference in tokenizing on 3 million lines of code that I have got by pulling sources of top 300 gems (by total downloads). I’ll mention how I track it soon.</li>
  <li>It does not depend on Ruby. In fact, it has absolutely no “required” dependencies (only a few optional ones). So, it’s possible to write bindings for any other language, and I have made them for C/C++/Node.js. Of course, it’s possible to have bindings for Ruby (because there are bindings for C and it’s easy to reuse them)</li>
</ol>

<h2 id="implementation">Implementation</h2>

<p>Current performance (in release mode, with <code class="language-plaintext highlighter-rouge">jemalloc</code>) is ~200000 LOC/s. I think it can even be used for syntax highlighting (and in the browser, too, haha).</p>

<p>I don’t want to dig too far, but some notes could be interesting.</p>

<p>Rust is a general purpose language that is based on LLVM (&lt;3) and can be compiled directly into machine code. It does not need any VMs and it can be compiled to a ton of targets (or platforms). The code does not use pointers, and there are no <code class="language-plaintext highlighter-rouge">unsafe</code> calls that you might hear about.</p>

<p>Rust does support ADT (algebraic data type) and it has generics, so you can build data structures like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Empty</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Beautiful, right?</p>

<p>I designed <code class="language-plaintext highlighter-rouge">Node</code> struct in a very similar way:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="nf">Variant1</span><span class="p">(</span><span class="n">Variant1</span><span class="p">),</span>
    <span class="nf">Variant2</span><span class="p">(</span><span class="n">Variant2</span><span class="p">),</span>
    <span class="nf">Variant3</span><span class="p">(</span><span class="n">Variant3</span><span class="p">),</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Variant1</span> <span class="p">{</span>
    <span class="c1">// fields</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Variant2</span> <span class="p">{</span>
    <span class="c1">// fields</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>If you are familiar with C/C++ it might look similar to tagged union, and was I know that’s exactly how they are implemented. Close equivalent in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">VARIANT1</span><span class="p">,</span>
    <span class="n">VARIANT2</span><span class="p">,</span>
  <span class="p">}</span> <span class="n">variant_no</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="c1">// variant1 data ...</span>
    <span class="p">}</span> <span class="n">variant1_data</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
      <span class="c1">// variant2 data ...</span>
    <span class="p">}</span> <span class="n">variant2_data</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">variant_value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>As I said, my lexer is based on MRI’s <code class="language-plaintext highlighter-rouge">parse.y</code>. It’s just a set of procedures that I turned into a few structs and interfaces.</p>

<p>But as some of you know, MRI’s parser is compiled using <code class="language-plaintext highlighter-rouge">bison</code> (or <code class="language-plaintext highlighter-rouge">yacc</code> if you care about licenses). Bison is an LALR(1) parser generator, short summary:</p>

<ol>
  <li>you write a <code class="language-plaintext highlighter-rouge">.y</code> file using bison’s DSL, with some interpolations in your programming language</li>
  <li>this file defines rules on how you want your language constructions to be reduced (or combined)</li>
  <li>then you convert it to <code class="language-plaintext highlighter-rouge">.{ext}</code> file where <code class="language-plaintext highlighter-rouge">ext</code> is what your language uses. done</li>
</ol>

<p>Unfortunately, bison supports only C/C++/Java/D.</p>

<p>First I looked at what’s available in the world of Rust. The most popular LALR parser generator is called <a href="https://github.com/lalrpop/lalrpop"><code class="language-plaintext highlighter-rouge">lalrpop</code></a> and I was very about it at the very beginning, I think has a very, very beautiful API:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="n">Term</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">&lt;</span><span class="n">n</span><span class="p">:</span><span class="nb">Num</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="p">,</span>
    <span class="s">"("</span> <span class="o">&lt;</span><span class="n">t</span><span class="p">:</span><span class="n">Term</span><span class="o">&gt;</span> <span class="s">")"</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="p">,</span>
<span class="p">};</span>

<span class="nb">Num</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">s</span><span class="p">:</span><span class="s">r"[0-9]+"</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="nn">i32</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<p>Plus, it’s written in Rust, so to compile a grammar that is based on it you don’t anything except Rust (that you need anyway to compile something written in Rust, right?).</p>

<p>Unfortunately, I have got a few reasons to abandon this idea:</p>

<ol>
  <li>
    <p>No mid-rules (that are used A LOT in MRI) like</p>

    <p><code class="language-plaintext highlighter-rouge">foo: bar { /* do something */ } baz { /* reduce */ }</code></p>

    <p>I guess it’s possible to emulate them by introducing rules like</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bar_with_mid_rule: bar { /* do something */ }
 foo: bar_with_mid_rule baz { /* reduce */ }
</code></pre></div>    </div>

    <p>but then I have no idea how such grammar can be maintained.</p>
  </li>
  <li>Compilation speed. I have got ~20% of Ruby grammar backported and noticed a huge performance degradation.</li>
  <li>No stack introspection (and IIRC no “debug” mode at all). By saying “stack” here I mean parser stack, that’s a feature of LR parsers. You can check how it looks like by running <code class="language-plaintext highlighter-rouge">ruby -ye '42'</code> locally</li>
  <li>The grammar written with <code class="language-plaintext highlighter-rouge">lalrpop</code> has a different format comparing to bison, and so maintaining it (like backporting new changed from MRI) seems to be a nightmare.</li>
</ol>

<p>But then I realized that Bison has a feature called “custom skeleton”. It’s like a custom Bison template that you can use to convert <code class="language-plaintext highlighter-rouge">.y</code> to your format, and it “takes” all the data (like token/transition tables) as an argument when called.</p>

<p>So I wrote my own skeleton for Rust and wrapped it into a <a href="https://github.com/iliabylich/rust-bison-skeleton">Rust library</a>. It uses m4 format that is a macro language. Here’s <a href="https://github.com/iliabylich/rust-bison-skeleton/blob/master/rust-bison-skeleton/bison/lalr1-rust.m4">the main file</a> and <a href="https://github.com/iliabylich/rust-bison-skeleton/blob/master/tests/src/calc.y">an example</a> of how it can be used.</p>

<p>And then it took me about a week to backport the entire parser. The stack of it is a wrapper around <code class="language-plaintext highlighter-rouge">Vec&lt;Value&gt;</code> where <code class="language-plaintext highlighter-rouge">Value</code> is an enum type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Value</span> <span class="p">{</span>
    <span class="n">Stolen</span><span class="p">,</span>
    <span class="n">Uninitialized</span><span class="p">,</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Token</span><span class="p">(</span><span class="n">Token</span><span class="p">),</span>
    <span class="nf">TokenList</span><span class="p">(</span><span class="n">TokenList</span><span class="p">),</span>
    <span class="nf">Node</span><span class="p">(</span><span class="n">Node</span><span class="p">),</span>
    <span class="nf">NodeList</span><span class="p">(</span><span class="n">NodeList</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
    <span class="nf">MaybeStrTerm</span><span class="p">(</span><span class="n">MaybeStrTerm</span><span class="p">),</span>
    <span class="nf">Num</span><span class="p">(</span><span class="nb">Num</span><span class="p">),</span>

    <span class="cm">/* For custom superclass rule */</span>
    <span class="nf">Superclass</span><span class="p">(</span><span class="n">Superclass</span><span class="p">),</span>

    <span class="c1">// ... variants for other custom rules, there are ~25 of them</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Initially result of each “reduce” action (that is stored in <code class="language-plaintext highlighter-rouge">yyval</code> variable) is set to <code class="language-plaintext highlighter-rouge">Value::Uninitialized</code>, reading <code class="language-plaintext highlighter-rouge">$&lt;Node&gt;5</code> in your action is compiled into something like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="n">yystack</span><span class="nf">.steal_value_at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
  <span class="nn">Value</span><span class="p">::</span><span class="nf">Node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">node</span><span class="p">,</span>
  <span class="n">other</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"not a node: {:?}"</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Doing <code class="language-plaintext highlighter-rouge">$$ = ...</code> is compiled into <code class="language-plaintext highlighter-rouge">yyval = ...</code>.</p>

<p>Why does reading “steal” the value from the stack? Because you can do <code class="language-plaintext highlighter-rouge">$$ = $&lt;Node&gt;1</code> and push an element of the vector to the same vector. At the same time you can do something like <code class="language-plaintext highlighter-rouge">$$ = combine($&lt;Node&gt;1, $&lt;Node&gt;1)</code> where you want both arguments to be mutable. You can’t do it in Rust.</p>

<p>This is why when you read any stack value you actually steal it by replacing what’s in the stack with <code class="language-plaintext highlighter-rouge">Value::Stolen</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Stack</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">fn</span> <span class="nf">steal_value_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.stack</span><span class="nf">.len</span><span class="p">();</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.stack</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="nn">Value</span><span class="p">::</span><span class="n">Stolen</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Value::Stolen</code> is just a placeholder value that indicates (when you see it) that your code previously has accessed the same stack entry. It’s necessary to have it (or in general some kind of a default value that is set by <code class="language-plaintext highlighter-rouge">std::mem::take/replace</code>) to “fix” ownership model.</p>

<p>So then it was done and I started profiling it. At the very beginning it was incredibly slow, but I knew it, I had way too many <code class="language-plaintext highlighter-rouge">.clone()</code> calls in my code (in Rust that’s a deep clone that is quite expensive in some cases). I added <code class="language-plaintext highlighter-rouge">jemalloc</code> and started profiling (<code class="language-plaintext highlighter-rouge">pprof-rs</code> &lt;3), I removed most clones and got ~160-170 thousand LOC/s.</p>

<p>Great, but I wanted more. ~20% of time in my benchmark was spent on this <code class="language-plaintext highlighter-rouge">std::mem::replace</code> call that swaps non-overlapping bytes. Initially I thought that I can’t improve it (that’s the fastest way to take the value AND to put a placeholder instead of it). At some point when I was writing C++ bindings I noticed that <code class="language-plaintext highlighter-rouge">sizeof(Node)</code> is 120 bytes (<code class="language-plaintext highlighter-rouge">Node</code> here is a C++ <code class="language-plaintext highlighter-rouge">Node</code> class) and it literally opened my eyes.</p>

<p>I’ll write it in C, take a look at this structure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="cm">/* variants */</span> <span class="p">}</span> <span class="n">variant</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Args</span> <span class="n">args</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">Def</span> <span class="n">def</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">IfTernary</span> <span class="n">if_ternary</span><span class="p">,</span>
        <span class="c1">// .. all other variant values</span>
    <span class="p">}</span> <span class="n">variant_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">IfTernary</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">cond</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">if_true</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">if_false</span><span class="p">;</span>
    <span class="c1">// .. a few more Range field, snip</span>
<span class="p">};</span>
</code></pre></div></div>

<p>(Let’s pretend that it can be compiled without forward declarations). This C <code class="language-plaintext highlighter-rouge">Node</code> is very, very similar to its Rust analogue. What’s the size of this <code class="language-plaintext highlighter-rouge">Node</code>?</p>

<p>The size of <code class="language-plaintext highlighter-rouge">struct</code> is a sum of all of its nodes (let’s simplify it and forget about memory alignment), the size of <code class="language-plaintext highlighter-rouge">union</code> is a maximum values its variant sizes.</p>

<p>Some specific node structures have multiple fields inside that are pointers (8 bytes on x86-64), and so the size of the generic <code class="language-plaintext highlighter-rouge">Node</code> is huge too.</p>

<p>Let’s “swap” pointers and unions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="cm">/* variants */</span> <span class="p">}</span> <span class="n">variant</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">Def</span> <span class="o">*</span><span class="n">def</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">IfTernary</span> <span class="p">(</span><span class="n">if_ternary</span><span class="p">,</span>
        <span class="c1">// .. all other variant values</span>
    <span class="p">}</span> <span class="n">variant_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">IfTernary</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="n">cond</span><span class="p">;</span>
    <span class="n">Node</span> <span class="n">if_true</span><span class="p">;</span>
    <span class="n">Node</span> <span class="n">if_false</span><span class="p">;</span>
    <span class="c1">// .. a few more Range field, snip</span>
<span class="p">};</span>
</code></pre></div></div>

<p>See? Now the size of the <code class="language-plaintext highlighter-rouge">union</code> is always <code class="language-plaintext highlighter-rouge">sizeof(void*)</code> and so <code class="language-plaintext highlighter-rouge">Node</code> is much smaller.</p>

<p>Why does it matter? Because <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> in Rust is a wrapper for <code class="language-plaintext highlighter-rouge">*T</code> array. It’s a contiguous and “flat” region of memory where all elements are “inlined”:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|</span><span class="n">item1</span><span class="o">|</span><span class="n">item2</span><span class="o">|</span><span class="n">item3</span><span class="o">|</span><span class="n">item4</span><span class="o">|</span><span class="p">...</span>
</code></pre></div></div>

<p>and every item takes <code class="language-plaintext highlighter-rouge">sizeof(T)</code> memory. This is why doing <code class="language-plaintext highlighter-rouge">std::mem::replace(t1, t2)</code> can swap at most <code class="language-plaintext highlighter-rouge">sizeof(T)</code> bytes and this is why I want <code class="language-plaintext highlighter-rouge">T</code> to be as small as possible.</p>

<p>After turning my Rust model into</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="nf">Args</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">IfTernary</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">IfTernary</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="cd">/// ...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">IfTernary</span> <span class="p">{</span>
    <span class="n">cond</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">if_true</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">if_false</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// other variants</span>
</code></pre></div></div>

<p>I have got the same performance as Ripper.</p>

<h2 id="future-improvements">Future improvements</h2>

<p>I keep thinking about turning <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> into zero copy parser and I’m believe it’s very possible.</p>

<p>Currently all “values” that copy from source code (like numeric/string literals, token values) are copied into tokens and AST nodes:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"42"

tokens:
    Token { name: "tINTEGER", value: "42", loc: 0...2 }

nodes:
    Int { value: "42", expression_l: 0..2 }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> constructs these <code class="language-plaintext highlighter-rouge">"42"</code> strings twice by copying a part of the input. Of course, for this particular case it’s possible to store only ranges like <code class="language-plaintext highlighter-rouge">start...end</code>, but there are exceptions where values of tokens and AST nodes are not equal to input sub-strings (like escape sequences, <code class="language-plaintext highlighter-rouge">"\n"</code> or <code class="language-plaintext highlighter-rouge">"\u1234"</code>).</p>

<p>Even this way it’s possible to introduce the following type system:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Value</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">SubstringOfInput</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]),</span>
    <span class="nf">ManuallyConstructed</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first variant is a reference, the latter is owned. Total value (of both token and AST node) could be just a vector of such enums, and if you parse a string <code class="language-plaintext highlighter-rouge">"foo\n"</code> you’ll get</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tokens:
    Token {
        name: "tSTRING_CONTENT",
        value: vec![
            Value::SubstringOfInput(&amp;input[1..3]),
            Value::ManuallyConstructed(vec![b'\n'])
        ],
        loc: 1..5
    }
</code></pre></div></div>

<p>However, then <code class="language-plaintext highlighter-rouge">input</code> must live as long as tokens and AST, and it sounds a bit problematic.</p>

<p>One option that I see is adding <code class="language-plaintext highlighter-rouge">Rc&lt;Input&gt;</code> to such values and store a range in <code class="language-plaintext highlighter-rouge">SubstringOfInput</code> enum variant. That’s basically a <code class="language-plaintext highlighter-rouge">shared_ptr</code> from C++ world that wraps a raw pointer (like <code class="language-plaintext highlighter-rouge">T*</code>) + (pointer to) a number of existing “clones” of this pointer. Every time you copy it the shared number is incremented, destructor decreases it and once it’s zero it also deletes <code class="language-plaintext highlighter-rouge">T</code>. It’s quite cheap in terms of performance (something like <code class="language-plaintext highlighter-rouge">*n += 1</code> in constructor, <code class="language-plaintext highlighter-rouge">*n -= 1; drop(ptr) if n == 0;</code> in destructor)</p>

<h2 id="c-bindings">C bindings</h2>

<p>GitHub repository - <a href="https://github.com/lib-ruby-parser/c-bindings">https://github.com/lib-ruby-parser/c-bindings</a></p>

<p>It took me a while to fix all segfaults, memory leaks and invalid memory access patterns (I’m not a C developer). <code class="language-plaintext highlighter-rouge">Valgrind</code> and <code class="language-plaintext highlighter-rouge">asan</code> are incredibly useful tools, I can’t even imagine how much time it would take to write bindings without these guys.</p>

<p>The API is very similar, there’s an additional layer between C and Rust that converts output of <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> into C structures.</p>

<p>It uses a combination of <code class="language-plaintext highlighter-rouge">enum</code> and <code class="language-plaintext highlighter-rouge">union</code> to represent a <code class="language-plaintext highlighter-rouge">Node</code>.</p>

<h2 id="c-bindings-1">C++ bindings</h2>

<p><a href="https://github.com/lib-ruby-parser/cpp-bindings">https://github.com/lib-ruby-parser/cpp-bindings</a></p>

<p>I personally like C++ much more than C. Smart pointers, containers, generics, but still worse for me than Rust. Upcoming standards are going to introduce even more features like modules and concepts, but, no.</p>

<p>The same story again, <code class="language-plaintext highlighter-rouge">valgrind</code>/<code class="language-plaintext highlighter-rouge">asan</code>, an extra layer that converts <code class="language-plaintext highlighter-rouge">Rust</code> objects to <code class="language-plaintext highlighter-rouge">C++</code> classes.</p>

<p>Also, my <code class="language-plaintext highlighter-rouge">valgrind</code> on Mac could not detect calling <code class="language-plaintext highlighter-rouge">free</code> on <code class="language-plaintext highlighter-rouge">C++</code> object (that’s invalid, should be <code class="language-plaintext highlighter-rouge">delete</code> from C++), and so I had to setup a docker container locally to find and fix it.</p>

<p>It uses modern <code class="language-plaintext highlighter-rouge">std::variant&lt;Nodes...&gt;</code> to represent a <code class="language-plaintext highlighter-rouge">Node</code>.</p>

<h2 id="node-bindings">Node bindings</h2>

<p>As a proof of concept I also created bindings for Node.js - <a href="https://github.com/lib-ruby-parser/node-bindings">https://github.com/lib-ruby-parser/node-bindings</a>.</p>

<p>I was actually impressed (in a good way) how elegant is the API of <code class="language-plaintext highlighter-rouge">node-addon-api</code>. I worked with V8 C++ API about a 10 months ago in Electron and back in the day it was quite verbose and painful. Also, I remember an interesting feature of <code class="language-plaintext highlighter-rouge">TryCatch</code> class:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TryCatch</span> <span class="n">trycatch</span><span class="p">;</span>
    <span class="c1">// do something that potentially does `throw err`</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">trycatch</span><span class="p">.</span><span class="n">HasCaught</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// process trycatch.Exception() value</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I personally think that this class abuses constructors/destructors in C++:</p>

<ul>
  <li>constructor of <code class="language-plaintext highlighter-rouge">TryCatch</code> registers <code class="language-plaintext highlighter-rouge">this</code> in some global context  (like <code class="language-plaintext highlighter-rouge">GetCurrentHandleScope().SetThrowHandler(this)</code></li>
  <li>any code that throws a JavaScript error sets it on this <code class="language-plaintext highlighter-rouge">TryCatch</code> handler</li>
  <li>it’s possible to access an exception object from any place</li>
  <li>destructor of <code class="language-plaintext highlighter-rouge">TryCatch</code> drops it</li>
</ul>

<p>I admit that it’s smart, but it sounds way too implicit to me. I’d like this interface to perform a register in a more explicit way (by calling <code class="language-plaintext highlighter-rouge">register/unregsiter</code> for example).</p>

<p>And I like that <code class="language-plaintext highlighter-rouge">node-addon-api</code> handles it <a href="https://github.com/nodejs/node-addon-api/blob/master/doc/error_handling.md#handling-a-n-api-c-exception">even better</a> by sticking to C++ exceptions.</p>

<p>Node.js bindings are based on C++ bindings from the previous section and they use a custom JavaScript class for each node type. Yes, there’s also an extra layer that converts C++ objects to JavaScript.</p>

<h2 id="wasm">WASM</h2>

<p>Rust can be compiled to WebAssembly, here’s a demo - <a href="https://lib-ruby-parser.github.io/wasm-bindings">https://lib-ruby-parser.github.io/wasm-bindings</a>.</p>

<p>It worked out of the box with one minor change. I had to mark <code class="language-plaintext highlighter-rouge">onigurama</code> dependency as optional and disable it for WASM build. Oh, I love how Rust can turn dependency into a feature that is optional and enabled/disabled by default as you configure it.</p>

<h2 id="final-thoughts">Final thoughts</h2>

<p>This is one of the biggest open-source projects that I have ever made. It can be used from Rust/C/C++/Node.js/browser. It’s fast (but remember, it can get even faster), it’s precise and it’s very strongly typed.</p>

<p>Also, if you need a custom setup (like custom C++ classes or maybe a completely different API) there’s a <a href="https://github.com/lib-ruby-parser/nodes">meta-repository</a> with all nodes information. You can use it to build your own bindings (or maybe new bindings for other languages), it has a <code class="language-plaintext highlighter-rouge">nodes</code> function that returns a <code class="language-plaintext highlighter-rouge">Vec&lt;Node&gt;</code> (<code class="language-plaintext highlighter-rouge">Node</code> here is just a “configuration” of a single <code class="language-plaintext highlighter-rouge">Node</code> variant from Rust - <a href="https://github.com/lib-ruby-parser/nodes/blob/master/src/node.rs#L6">source</a>)</p>

<p>Bindings still have a room for improvements (for example, there’s no way to pass custom <code class="language-plaintext highlighter-rouge">ParserOptions</code> to the parser), and current version of <code class="language-plaintext highlighter-rouge">lib-ruby-parser</code> is <code class="language-plaintext highlighter-rouge">0.7.0</code>.</p>

<p>However, I think it’s ready. It’s stable and I’m not going to introduce any major changes anymore. I’m going to cut <code class="language-plaintext highlighter-rouge">3.0.0</code> once Ruby 3 is released. Don’t hesitate to drop me a message if it works well for you.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
    <li>
      <h3>
        <a href="/2021/12/27/writing-bindings-upside-down.html">
          Writing bindings upside down
          <small>27 Dec 2021</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/2020/01/25/evaluating-ruby-in-ruby.html">
          Evaluating Ruby in Ruby
          <small>25 Jan 2020</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/2018/07/18/my-favorite-parts-of-ruby.html">
          My favorite parts of Ruby
          <small>18 Jul 2018</small>
        </a>
      </h3>
    </li>
    
  </ul>
</div>


<iframe src="https://ilyabyli.ch/commentary/index?post_id=lib-ruby-parser" frameborder="0" scrolling="no" width="100%">
</iframe>

<script type="text/javascript">
  window.addEventListener("message", ({ data }) => {
    if (data.type === "resize") {
      document.querySelector("iframe").style.height = `${data.height}px`;
    }
  })
</script>


    </div>
  </body>
</html>
