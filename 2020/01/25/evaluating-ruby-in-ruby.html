<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Evaluating Ruby in Ruby &middot; Ilya Bylich
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="192x192" href="/public/apple-touch-icon-192-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EBV7BR668S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EBV7BR668S');
</script>

</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Ilya Bylich
        </a>
      </h1>
      <p class="lead">I'm a Ruby/Rust developer, sometimes I write long technical stories</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      <a class="sidebar-nav-item" href="https://github.com/iliabylich">GitHub</a>
      <a class="sidebar-nav-item" href="https://twitter.com/IlyaBylich">Twitter</a>
      <a class="sidebar-nav-item" href="mailto:ibylich@gmail.com">Email me</a>
      <a class="sidebar-nav-item" href="https://iliabylich.github.io/feed.xml">RSS</a>

      <span class="sidebar-nav-item">
  <label for="current-theme">Theme</label>
  <select id="current-theme">
    <option>08</option>
    <option>09</option>
    <option>0a</option>
    <option>0b</option>
    <option>0c</option>
    <option>0d</option>
    <option>0f</option>
  </select>

  <script type="text/javascript">
    class Theme {
      static DEFAULT = "0b";

      static getCurrent() {
        return localStorage.getItem("current-theme") || Theme.DEFAULT;
      }

      static setCurrent(theme) {
        localStorage.setItem("current-theme", theme);
        document.body.className = `theme-base-${theme}`;
      }
    }

    const themeSelector = document.getElementById("current-theme");
    Theme.setCurrent(Theme.getCurrent());
    themeSelector.value = Theme.getCurrent();

    themeSelector.onchange = (e) => {
      const theme = e.target.value;
      Theme.setCurrent(theme);
    }
  </script>
</span>

    </nav>

    <p>&copy; 2023. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Evaluating Ruby in Ruby</h1>
  <span class="post-date">25 Jan 2020</span>

  <div class="reading-time" title="Estimated read time">
  This article will take 62 minutes to read
  <br />
  (or maybe less, the algorithm treats code as text)
</div>


  <div id="table-of-contents">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#evaluating-ruby-in-ruby">Evaluating Ruby in Ruby</a>
<ul>
<li class="toc-entry toc-h3"><a href="#tldr">TL;DR</a></li>
<li class="toc-entry toc-h3"><a href="#how-ruby-evaluates-your-code">How Ruby evaluates your code.</a></li>
<li class="toc-entry toc-h3"><a href="#the-structure-of-the-instruction-sequence-iseq">The structure of the instruction sequence (ISeq)</a></li>
<li class="toc-entry toc-h3"><a href="#building-a-poc">Building a PoC</a></li>
<li class="toc-entry toc-h3"><a href="#self">Self</a></li>
<li class="toc-entry toc-h3"><a href="#frames">Frames</a></li>
<li class="toc-entry toc-h3"><a href="#wrapping-the-iseq">Wrapping the ISeq</a></li>
<li class="toc-entry toc-h3"><a href="#frame-stack">Frame stack</a></li>
<li class="toc-entry toc-h3"><a href="#writing-the-evaluator">Writing the evaluator</a></li>
<li class="toc-entry toc-h3"><a href="#instructions">Instructions</a>
<ul>
<li class="toc-entry toc-h5"><a href="#putself-putobject-putnil-putstring-putiseq">putself, putobject, putnil, putstring, putiseq</a></li>
<li class="toc-entry toc-h5"><a href="#optimized-instructions-like-opt_plus">optimized instructions like opt_plus</a></li>
<li class="toc-entry toc-h5"><a href="#opt_send_without_block-or-send-if-specialized-instructions-are-disabled">opt_send_without_block (or send if specialized instructions are disabled)</a></li>
<li class="toc-entry toc-h5"><a href="#method-definition">method definition</a></li>
<li class="toc-entry toc-h5"><a href="#local-variables">local variables</a></li>
<li class="toc-entry toc-h5"><a href="#method-arguments">method arguments</a></li>
<li class="toc-entry toc-h5"><a href="#constants">constants</a></li>
<li class="toc-entry toc-h5"><a href="#instanceclass-variables">Instance/Class variables</a></li>
<li class="toc-entry toc-h5"><a href="#literals">Literals</a></li>
<li class="toc-entry toc-h5"><a href="#splats">Splats</a></li>
<li class="toc-entry toc-h5"><a href="#conditions-ifunless">conditions (if/unless)</a></li>
<li class="toc-entry toc-h5"><a href="#string-interpolationconcatenation">String interpolation/concatenation</a></li>
<li class="toc-entry toc-h5"><a href="#blocks">Blocks</a></li>
<li class="toc-entry toc-h5"><a href="#lambdas">Lambdas</a></li>
<li class="toc-entry toc-h5"><a href="#calling-a-block">Calling a block</a></li>
<li class="toc-entry toc-h5"><a href="#super">Super</a></li>
<li class="toc-entry toc-h5"><a href="#global-variables">Global variables</a></li>
<li class="toc-entry toc-h5"><a href="#defined-keyword">defined? keyword</a></li>
<li class="toc-entry toc-h5"><a href="#range-literals">Range literals</a></li>
<li class="toc-entry toc-h5"><a href="#long-jumps">Long jumps</a></li>
<li class="toc-entry toc-h5"><a href="#longjmp-in-mri">longjmp in MRI</a></li>
<li class="toc-entry toc-h5"><a href="#rescueensure">rescue/ensure</a></li>
<li class="toc-entry toc-h5"><a href="#throwcatch-methods">throw/catch methods</a></li>
<li class="toc-entry toc-h5"><a href="#utility-instructions">Utility instructions</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#final-words">Final words</a></li>
</ul>
</li>
</ul>
  </div>

  <h1 id="evaluating-ruby-in-ruby">Evaluating Ruby in Ruby</h1>

<h3 id="tldr">TL;DR</h3>

<p>This article is about instruction sequences and evaluating them using pure Ruby.</p>

<p>The repository is available <a href="https://github.com/iliabylich/my.rb">here</a>.</p>

<blockquote>
  <p>Is it a Ruby implementation?</p>
</blockquote>

<p>No. It’s just a runner of instructions. It is similar to MRI’s virtual machine, but it lacks many features and it’s 100 times slower.</p>

<blockquote>
  <p>Can I use it in my applications?</p>
</blockquote>

<p>Of course, no. Well, if you want.</p>

<blockquote>
  <p>Does it work at all?</p>
</blockquote>

<p>Yes, and it even passes most language specs from RubySpec test suite.</p>

<h3 id="how-ruby-evaluates-your-code">How Ruby evaluates your code.</h3>

<p>Well, I think I should start with explaining basics. There is a plenty of articles about it, so I’ll be short:</p>

<ol>
  <li>First, Ruby parses your code into AST (<code class="language-plaintext highlighter-rouge">parse.y</code>)</li>
  <li>Then, it compiles it into instruction sequence (<code class="language-plaintext highlighter-rouge">compile.c</code>)</li>
  <li>And every time when you let’s say call a method it evaluates these instructions. (<code class="language-plaintext highlighter-rouge">insn.def</code>, <code class="language-plaintext highlighter-rouge">vm_eval.c</code>, <code class="language-plaintext highlighter-rouge">vm_insnhelper.c</code>)</li>
</ol>

<p>Long time ago there was no YARV and Ruby used to evaluate AST.</p>

<p><code class="language-plaintext highlighter-rouge">1+2</code> is just a small syntax tree with a <code class="language-plaintext highlighter-rouge">send</code> node in the root and two children: <code class="language-plaintext highlighter-rouge">int(1)</code> and <code class="language-plaintext highlighter-rouge">int(2)</code>. To evaluate it you need to “traverse” it by walking down recursively. Primitive nodes are getting substituted with values (integers 1 and 2 respectively), <code class="language-plaintext highlighter-rouge">send</code> node calls <code class="language-plaintext highlighter-rouge">+</code> on pre-reduced children and returns <code class="language-plaintext highlighter-rouge">3</code>.</p>

<p>On the other side, YARV is a stack-based Virtual Machine (VM) that evaluates an assembly-like language that consist of more than 100 predefined instructions that store their input/output values on the VM’s stack.</p>

<p>These instructions have arguments, some of them are primitive values, some are inlined Ruby objects, some are flags.</p>

<p>You can view these instructions by running Ruby with <code class="language-plaintext highlighter-rouge">--dump=insns</code> flag:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="o">--</span><span class="n">dump</span><span class="o">=</span><span class="n">insns</span> <span class="o">-</span><span class="n">e</span> <span class="s1">'puts 2 + 3'</span>
<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
<span class="mo">0000</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0001</span> <span class="n">putobject</span>                    <span class="mi">2</span>
<span class="mo">0003</span> <span class="n">putobject</span>                    <span class="mi">3</span>
<span class="mo">0005</span> <span class="n">opt_plus</span>                     <span class="o">&lt;</span><span class="n">callinfo!mid</span><span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">callcache</span><span class="o">&gt;</span>
<span class="mo">000</span><span class="mi">8</span> <span class="n">opt_send_without_block</span>       <span class="o">&lt;</span><span class="n">callinfo!mid</span><span class="ss">:puts</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">callcache</span><span class="o">&gt;</span>
<span class="mo">0011</span> <span class="n">leave</span>
</code></pre></div></div>

<p>As you can see, there are 5 instructions:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">putself</code> - pushes <code class="language-plaintext highlighter-rouge">self</code> at the top of the stack</li>
  <li><code class="language-plaintext highlighter-rouge">putobject</code> - pushes given object (numbers 2 an 3)</li>
  <li><code class="language-plaintext highlighter-rouge">opt_plus</code> - optimized instruction for <code class="language-plaintext highlighter-rouge">+</code> method</li>
  <li><code class="language-plaintext highlighter-rouge">opt_send_without_block</code> - optimized instruction for a generic method call without block</li>
  <li><code class="language-plaintext highlighter-rouge">leave</code> - an equivalent of <code class="language-plaintext highlighter-rouge">return</code></li>
</ol>

<h3 id="the-structure-of-the-instruction-sequence-iseq">The structure of the instruction sequence (ISeq)</h3>

<p>Let’s start with the example above.</p>

<p>MRI has an API to compile an arbitrary code into instructions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"2+3"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">[</span><span class="s2">"YARVInstructionSequence/SimpleDataFormat"</span><span class="p">,</span>
 <span class="mi">2</span><span class="p">,</span>
 <span class="mi">6</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="p">{</span><span class="ss">:arg_size</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
  <span class="ss">:local_size</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
  <span class="ss">:stack_max</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span>
  <span class="ss">:node_id</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span>
  <span class="ss">:code_location</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="ss">:top</span><span class="p">,</span>
 <span class="p">[],</span>
 <span class="p">{},</span>
 <span class="p">[],</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:opt_plus</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">16</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]</span>
</code></pre></div></div>

<p>Our code gets compiled into an array where:</p>

<ul>
  <li>The first element returns the type of the instruction sequence</li>
  <li>Then comes <code class="language-plaintext highlighter-rouge">MAJOR</code>/<code class="language-plaintext highlighter-rouge">MINOR</code>/<code class="language-plaintext highlighter-rouge">PATCH</code> parts of the Ruby version that was used to compile it</li>
  <li>Then comes the hash with a meta information about this iseq</li>
  <li>Then comes relative/full/some other file name. It is possible to override them similar to passing <code class="language-plaintext highlighter-rouge">file/line</code> arguments to <code class="language-plaintext highlighter-rouge">{class,module}_eval</code> (<code class="language-plaintext highlighter-rouge">Object.module_eval("[__FILE__, __LINE__]", '(file)', 42)</code>)</li>
  <li>Then comes the line where the code begins (1 by default)</li>
  <li>Then comes the type of the iseq (<code class="language-plaintext highlighter-rouge">:top</code> here means the code was parsed and compiled as a top-level block of code)</li>
  <li>Then we have a few empty arrays and hashes (we will return to them later)</li>
  <li>And the last item is an array of instructions</li>
</ul>

<p>Each instruction is either:</p>

<ul>
  <li>a number</li>
  <li>a special symbol</li>
  <li>or an array</li>
</ul>

<p>Only arrays are “real” instructions, numbers and symbols are special debug entries that are used internally by the VM. In our case a number followed by the <code class="language-plaintext highlighter-rouge">:RUBY_EVENT_LINE</code> is a mark that MRI uses to know what is the number of the line that is currently being interpreted (for example, all backtrace entries include these numbers)</p>

<h3 id="building-a-poc">Building a PoC</h3>

<p>How can we evaluate instructions above? Well, we definitely need a stack:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$stack</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<p>Then, we need to iterate over instructions (the last item of the iseq) and evaluate them one by one. We could write a giant <code class="language-plaintext highlighter-rouge">case-when</code>, but I promise that it won’t fit on 10 screens. Let’s use some meta-programming and dynamic dispatching:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span>
  <span class="nb">name</span><span class="p">,</span> <span class="o">*</span><span class="n">payload</span> <span class="o">=</span> <span class="n">insn</span>
  <span class="nb">send</span><span class="p">(</span><span class="ss">:"execute_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="ss">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This way we need to write a method per instruction type, let’s start with <code class="language-plaintext highlighter-rouge">putobject</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_putobject</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="vg">$stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_opt_plus</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="vg">$stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="vg">$stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="vg">$stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_leave</span>
  <span class="c1"># nothing here so far</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This code is enough to get <code class="language-plaintext highlighter-rouge">5</code> in the stack once it’s executed. Here’s the runner:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iseq</span> <span class="o">=</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"2+3"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="n">insns</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">[</span><span class="mi">13</span><span class="p">].</span><span class="nf">grep</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span> <span class="c1"># ignore numbers and symbols for now</span>
<span class="n">insns</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">insn</span><span class="o">|</span> <span class="n">execute_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="p">}</span>
<span class="n">pp</span> <span class="vg">$stack</span>
</code></pre></div></div>

<p>You should see <code class="language-plaintext highlighter-rouge">[5]</code>.</p>

<p>All instructions above simply pull some values from the stack, do some computations and push the result back.</p>

<h3 id="self">Self</h3>

<p>Let’s think about <code class="language-plaintext highlighter-rouge">self</code> for a minute:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"self"</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span> <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span> <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">self</code> is stored somewhere internally, and even more, it’s dynamic:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="nb">self</span>
<span class="k">class</span> <span class="nc">X</span>
  <span class="nb">puts</span> <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The first <code class="language-plaintext highlighter-rouge">puts self</code> prints <code class="language-plaintext highlighter-rouge">main</code>, while the second one prints <code class="language-plaintext highlighter-rouge">X</code>.</p>

<p>Here comes the concept of frames.</p>

<h3 id="frames">Frames</h3>

<p>Frame is an object inside the virtual machine that represents a closure. Or a <code class="language-plaintext highlighter-rouge">binding</code>. It’s an isolated “world” with its own set of locals, its own <code class="language-plaintext highlighter-rouge">self</code>, its own <code class="language-plaintext highlighter-rouge">file</code>/<code class="language-plaintext highlighter-rouge">line</code> information, it’s own <code class="language-plaintext highlighter-rouge">rescue</code> and <code class="language-plaintext highlighter-rouge">ensure</code> handlers etc.</p>

<p>Frame also has a type:</p>

<ol>
  <li>it can be a <code class="language-plaintext highlighter-rouge">top</code> frame that wraps all the code in your file. All variables set in the global scope of your file belong to the top frame. Each parsed and evaluated file creates its own top frame.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">method</code> frame. All methods create it. One method frame per one method call.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">block</code> frame. All blocks and lambdas create it. One block frame per one block call.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">class</code> frame, however it does not mean that instantiating a class creates it. The whole <code class="language-plaintext highlighter-rouge">class X; ... end</code> does it. Later when you do <code class="language-plaintext highlighter-rouge">X.new</code> Ruby does not create any <code class="language-plaintext highlighter-rouge">class</code> frames. This frame represents a class definition.</li>
  <li>it can be a <code class="language-plaintext highlighter-rouge">rescue</code> frame that represents a code inside <code class="language-plaintext highlighter-rouge">rescue =&gt; e; &lt;...&gt;; end</code> block</li>
  <li>it can be an <code class="language-plaintext highlighter-rouge">ensure</code> frame (well, I’m sure you get it)</li>
  <li>there are also <code class="language-plaintext highlighter-rouge">module</code> (for a module body), <code class="language-plaintext highlighter-rouge">sclass</code> (for a singleton class) and a very unique <code class="language-plaintext highlighter-rouge">eval</code> frame.</li>
</ol>

<p>And they are stored internally as a stack.</p>

<p>When you invoke <code class="language-plaintext highlighter-rouge">caller</code> method you see this stack (or some information based on it). Each entry in the error backtrace is based on the state of this stack when the error is thrown.</p>

<p>OK, let’s write some code to extend our VM:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrameClass</span>
  <span class="no">COMMON_FRAME_ATTRIBUTES</span> <span class="o">=</span> <span class="sx">%i[
    _self
    nesting
    locals
    file
    line
    name
  ]</span><span class="p">.</span><span class="nf">freeze</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="o">*</span><span class="no">COMMON_FRAME_ATTRIBUTES</span><span class="p">,</span>
      <span class="o">*</span><span class="n">arguments</span><span class="p">,</span>
      <span class="ss">keyword_init: </span><span class="kp">true</span>
    <span class="p">)</span> <span class="k">do</span>
      <span class="nb">class_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>

      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">:,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">allocate</span>

        <span class="n">instance</span><span class="p">.</span><span class="nf">file</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">file</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">line</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">line</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">name</span>
        <span class="n">instance</span><span class="p">.</span><span class="nf">locals</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:initialize</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

        <span class="n">instance</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I like builders and I don’t like inheritance (the fact that frames share some common attributes does not mean that they should be inherited from an <code class="language-plaintext highlighter-rouge">AbstractFrame</code> class; also I don’t like abstract classes, they are dead by definition)</p>

<p>Here’s the first version of the <code class="language-plaintext highlighter-rouge">TopFrame</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">TopFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">**</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="no">TOPLEVEL_BINDING</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'self'</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="p">[</span><span class="no">Object</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty_name</span>
    <span class="s2">"TOP </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s walk through the code:</p>

<ol>
  <li>each frame has a common set of attributes:</li>
  <li><code class="language-plaintext highlighter-rouge">_self</code> - what <code class="language-plaintext highlighter-rouge">self</code> returns inside the frame</li>
  <li><code class="language-plaintext highlighter-rouge">nesting</code> - what <code class="language-plaintext highlighter-rouge">Module.nesting</code> returns (used for the relative constant lookup)</li>
  <li><code class="language-plaintext highlighter-rouge">locals</code> - a set of local variables</li>
  <li><code class="language-plaintext highlighter-rouge">file</code> and <code class="language-plaintext highlighter-rouge">line</code> - currently running <code class="language-plaintext highlighter-rouge">__FILE__:__LINE__</code></li>
  <li><code class="language-plaintext highlighter-rouge">name</code> - a human-readable name of the frame, we will use it mostly for debugging</li>
  <li><code class="language-plaintext highlighter-rouge">FrameClass</code> is a builder that is capable of building a custom <code class="language-plaintext highlighter-rouge">Frame</code> class (similar to <code class="language-plaintext highlighter-rouge">Struct</code> class)</li>
  <li><code class="language-plaintext highlighter-rouge">FrameClass.new</code> takes:</li>
  <li>a list of custom frame-class-specific attributes</li>
  <li>and a block that is evaluated in a context of the created frame class</li>
</ol>

<p>So, the <code class="language-plaintext highlighter-rouge">TopFrame</code> class is a <code class="language-plaintext highlighter-rouge">Struct</code>-like class that:</p>

<ol>
  <li>has a constructor that takes <strong>only</strong> common attributes (because we haven’t specified any in <code class="language-plaintext highlighter-rouge">FrameClass.new</code>)</li>
  <li>has a custom behavior in the constructor that sets <code class="language-plaintext highlighter-rouge">_self</code> and <code class="language-plaintext highlighter-rouge">nesting</code></li>
  <li>has a custom <code class="language-plaintext highlighter-rouge">pretty_name</code> instance method</li>
</ol>

<p>We will create as many classes as we need to cover all kinds of frames (I will return to it later, I promise)</p>

<h3 id="wrapping-the-iseq">Wrapping the ISeq</h3>

<p>I don’t like working with plain arrays, and as I mentioned above there’s a ton of useful information in the instruction sequence that we get from <code class="language-plaintext highlighter-rouge">RubyVM::InstructionSequence.compile("code").to_a</code>.</p>

<p>Let’s create a wrapper that knows the meaning of array items:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ISeq</span>
  <span class="nb">attr_reader</span> <span class="ss">:insns</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ruby_iseq</span><span class="p">)</span>
    <span class="vi">@ruby_iseq</span> <span class="o">=</span> <span class="n">ruby_iseq</span>
    <span class="vi">@insns</span> <span class="o">=</span> <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">13</span><span class="p">].</span><span class="nf">dup</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">file</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">line</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">kind</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">lvar_names</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">args_info</span>
    <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Instance methods are self-descriptive, but just in case:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">file</code>/<code class="language-plaintext highlighter-rouge">line</code> return file/line where the iseq has been created</li>
  <li><code class="language-plaintext highlighter-rouge">kind</code> returns a Symbol that we will later use to distinguish frames (<code class="language-plaintext highlighter-rouge">:top</code> for a <code class="language-plaintext highlighter-rouge">TopFrame</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">insns</code> returns a list of instructions</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> is an internal name of the frame that is used in stacktraces (for <code class="language-plaintext highlighter-rouge">class X; end</code> it returns <code class="language-plaintext highlighter-rouge">&lt;class:X&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">lvar_names</code> is an array of all local variable names that are used in the frame</li>
  <li><code class="language-plaintext highlighter-rouge">args_info</code> is a special Hash with a meta-information about arguments (empty for all frames except methods)</li>
</ol>

<h3 id="frame-stack">Frame stack</h3>

<p>Frames are organized as a stack internally, every time when we enter a frame Ruby pushes it on a stack. When the frame ends (i.e. when its list of instruction ends or there’s a special <code class="language-plaintext highlighter-rouge">[:leave]</code> instruction) it pops it.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrameStack</span>
  <span class="nb">attr_reader</span> <span class="ss">:stack</span>

  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@stack</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">frame</span><span class="o">|</span> <span class="k">yield</span> <span class="n">frame</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="vi">@stack</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span>
    <span class="n">frame</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">push_top</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
    <span class="n">push</span> <span class="no">TopFrame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pop</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">top</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">last</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">size</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">empty?</span>
    <span class="vi">@stack</span><span class="p">.</span><span class="nf">empty?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Each entry in the stack is a frame that we entered at some point, so we can quickly build a <code class="language-plaintext highlighter-rouge">caller</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BacktraceEntry</span> <span class="o">&lt;</span> <span class="no">String</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">super</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">frame</span><span class="p">.</span><span class="nf">file</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">frame</span><span class="p">.</span><span class="nf">line</span><span class="si">}</span><span class="s2">:in `</span><span class="si">#{</span><span class="n">frame</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">stack</span> <span class="o">=</span> <span class="no">FrameStack</span><span class="p">.</span><span class="nf">new</span>
<span class="n">code</span> <span class="o">=</span> <span class="s1">'2 + 3'</span>
<span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s1">'test.rb'</span><span class="p">,</span> <span class="s1">'/path/to/test.rb'</span><span class="p">,</span> <span class="mi">42</span><span class="p">).</span><span class="nf">to_a</span><span class="p">)</span>

<span class="n">stack</span><span class="p">.</span><span class="nf">push_top</span><span class="p">(</span><span class="ss">iseq: </span><span class="n">iseq</span><span class="p">)</span>
<span class="nb">caller</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">frame</span><span class="o">|</span> <span class="no">BacktraceEntry</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="p">}.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">puts</span> <span class="nb">caller</span>
<span class="c1"># =&gt; "/path/to/test.rb:42: in `&lt;compiled&gt;'"</span>
</code></pre></div></div>

<h3 id="writing-the-evaluator">Writing the evaluator</h3>

<p>Let’s write it in a “script style” (it is simplified for a good reason, real code is much more complicated):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile_file</span><span class="p">(</span><span class="s1">'path/to/file.rb'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">)</span>
<span class="n">frame_stack</span> <span class="o">=</span> <span class="no">FrameStack</span><span class="p">.</span><span class="nf">new</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">frame_stack</span><span class="p">.</span><span class="nf">push_top</span><span class="p">(</span><span class="ss">iseq: </span><span class="n">iseq</span><span class="p">)</span>

<span class="k">until</span> <span class="n">frame_stack</span><span class="p">.</span><span class="nf">empty?</span>
  <span class="n">current_frame</span> <span class="o">=</span> <span class="n">frame_stack</span><span class="p">.</span><span class="nf">top</span>
  <span class="k">if</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="k">break</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">insns</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="n">frame_stack</span><span class="p">.</span><span class="nf">pop_frame</span>
    <span class="k">next</span>
  <span class="k">end</span>

  <span class="n">current_insn</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">insns</span><span class="p">.</span><span class="nf">shift</span>
  <span class="n">execute_insn</span><span class="p">(</span><span class="n">current_insn</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Generally speaking, the code above is the core of the VM. Once it’s executed both <code class="language-plaintext highlighter-rouge">frame_stack</code> and <code class="language-plaintext highlighter-rouge">stack</code> must be empty. I added a bunch of consistency checks in my implementation, but for the sake of simplicity I’m going to omit them here.</p>

<h3 id="instructions">Instructions</h3>

<p>I’ll try to be short here, there are about 100 instructions in Ruby, and some of them look similar.</p>

<h5 id="putself-putobject-putnil-putstring-putiseq"><code class="language-plaintext highlighter-rouge">putself</code>, <code class="language-plaintext highlighter-rouge">putobject</code>, <code class="language-plaintext highlighter-rouge">putnil</code>, <code class="language-plaintext highlighter-rouge">putstring</code>, <code class="language-plaintext highlighter-rouge">putiseq</code></h5>

<p>All of these guys push a simple object at the top of the stack. <code class="language-plaintext highlighter-rouge">putnil</code> pushes a known global <code class="language-plaintext highlighter-rouge">nil</code> object, others have an argument that is used in <code class="language-plaintext highlighter-rouge">stack.push(argument)</code></p>

<h5 id="optimized-instructions-like-opt_plus">optimized instructions like <code class="language-plaintext highlighter-rouge">opt_plus</code></h5>

<p>Ruby has a mode (that is turned on by default) that optimizes some frequently used method calls, like <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">.size</code>. It is possible to turn them off by manipulating <code class="language-plaintext highlighter-rouge">RubyVM::InstructionSequence.compile_option</code> (if you set <code class="language-plaintext highlighter-rouge">:specialized_instruction</code> to <code class="language-plaintext highlighter-rouge">false</code> you’ll get a normal method call instead of the specialized instruction).</p>

<p>All of them do one specific thing, here’s an example of the <code class="language-plaintext highlighter-rouge">opt_size</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_opt_size</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">pop</span><span class="p">.</span><span class="nf">size</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Of course we do it this way because we cannot optimize it. MRI does a different thing:</p>

<ol>
  <li>if there’s a string/array/hash on top of the stack</li>
  <li>and <code class="language-plaintext highlighter-rouge">String#size</code> (or <code class="language-plaintext highlighter-rouge">Array#size</code> if it’s an array) is not redefined</li>
  <li>then it <strong>directly</strong> calls a C method <code class="language-plaintext highlighter-rouge">rb_str_length</code> (or <code class="language-plaintext highlighter-rouge">RARRAY_LEN</code> if it’s an array)</li>
  <li>otherwise (if it’s an object of some other type or a method has been redefined) it calls a method through the regular method dispatch mechanism (which is obviously slower)</li>
</ol>

<p>We could do the same sequence of steps, but we can’t invoke a C method, and so calling a check + <code class="language-plaintext highlighter-rouge">.size</code> afterwards is even slower. It’s better for us to fall to the slow branch from the beginning.</p>

<p>You can print all available specialized instructions by running</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">RubyVM</span><span class="o">::</span><span class="no">INSTRUCTION_NAMES</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="sr">/\Aopt_/</span><span class="p">)</span>
</code></pre></div></div>

<p>On Ruby 2.6.4 there are 34 of them.</p>

<h5 id="opt_send_without_block-or-send-if-specialized-instructions-are-disabled"><code class="language-plaintext highlighter-rouge">opt_send_without_block</code> (or <code class="language-plaintext highlighter-rouge">send</code> if specialized instructions are disabled)</h5>

<p>This is an instruction that is used to invoke methods. <code class="language-plaintext highlighter-rouge">puts 123</code> looks like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="ss">:opt_send_without_block</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:puts</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">]</span>
</code></pre></div></div>

<p>It has 2 arguments:</p>

<ol>
  <li>a hash with options</li>
  <li><code class="language-plaintext highlighter-rouge">mid</code> - a method ID (method name)</li>
  <li><code class="language-plaintext highlighter-rouge">flag</code> - a bitmask with a metadata about the invocation</li>
  <li><code class="language-plaintext highlighter-rouge">orig_argc</code> - a number of arguments passed to a method call</li>
  <li>a boolean flag that is called <code class="language-plaintext highlighter-rouge">CALL_DATA</code> in C. I have no idea what it does</li>
</ol>

<p>Here’s the rough implementation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_opt_send_without_block</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:mid</span><span class="p">]</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So here we</p>

<ol>
  <li>take a method from the <code class="language-plaintext highlighter-rouge">options</code> hash (<code class="language-plaintext highlighter-rouge">mid</code>)</li>
  <li>then we pop N arguments from the stack (<code class="language-plaintext highlighter-rouge">args</code>)</li>
  <li>then we pop the receiver of the method (<code class="language-plaintext highlighter-rouge">recv</code>)</li>
  <li>then call <code class="language-plaintext highlighter-rouge">recv.send(mid, *args)</code> (in our case it’s <code class="language-plaintext highlighter-rouge">self.send(:puts, *[123])</code></li>
  <li>and then we push the result back to the stack</li>
</ol>

<h5 id="method-definition">method definition</h5>

<p>I intentionally started with method calls because Ruby defines methods via method calls. Yes.</p>

<p>Ruby has a special singleton object called <code class="language-plaintext highlighter-rouge">Frozen Core</code>. When you define a method via <code class="language-plaintext highlighter-rouge">def m; end</code> Ruby invokes <code class="language-plaintext highlighter-rouge">frozen_core.send("core#define_method", method_iseq)</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="o">--</span><span class="n">dump</span><span class="o">=</span><span class="n">insns</span> <span class="o">-</span><span class="n">e</span> <span class="s1">'def m; end'</span>
<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
<span class="mo">0000</span> <span class="n">putspecialobject</span>             <span class="mi">1</span>                                   <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0002</span> <span class="n">putobject</span>                    <span class="ss">:m</span>
<span class="mo">0004</span> <span class="n">putiseq</span>                      <span class="n">m</span>
<span class="mo">0006</span> <span class="n">opt_send_without_block</span>       <span class="o">&lt;</span><span class="n">callinfo!mid</span><span class="ss">:core</span><span class="c1">#define_method, argc:2, ARGS_SIMPLE&gt;, &lt;callcache&gt;</span>
<span class="mo">000</span><span class="mi">9</span> <span class="n">leave</span>
</code></pre></div></div>

<p>The object itself is defined <a href="https://github.com/ruby/ruby/blob/beae6cbf0fd8b6619e5212552de98022d4c4d4d4/vm.c#L2983-L2996">here</a>.</p>

<p>Of course, we don’t have access to the Frozen Core. But we have an instruction that pushes it at the top of the stack. We can create our own <code class="language-plaintext highlighter-rouge">FrozenCore = Object.new.freeze</code> and check if <code class="language-plaintext highlighter-rouge">recv</code> is equal to this frozen core.</p>

<p>As you may notice there are also <code class="language-plaintext highlighter-rouge">putobject :m</code> and <code class="language-plaintext highlighter-rouge">putiseq</code> instructions. And <code class="language-plaintext highlighter-rouge">argc</code> of the method call is 2. Hmmm.</p>

<p><code class="language-plaintext highlighter-rouge">core#define_method</code> takes two arguments:</p>

<ol>
  <li>a method name that is pushed by a <code class="language-plaintext highlighter-rouge">putobject</code> instruction</li>
  <li>and an iseq that is … pushed by the <code class="language-plaintext highlighter-rouge">putiseq</code> instruction. Yes, instruction is an argument for another instruction.</li>
</ol>

<p>Here’s the code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">recv</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="no">FrozenCore</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mid</span> <span class="o">==</span> <span class="ss">:'core#define_method'</span>
  <span class="n">method_name</span><span class="p">,</span> <span class="n">body_iseq</span> <span class="o">=</span> <span class="o">*</span><span class="n">args</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">__define_method</span><span class="p">(</span><span class="ss">method_name: </span><span class="n">method_name</span><span class="p">,</span> <span class="ss">body_iseq: </span><span class="n">body_iseq</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here’s how <code class="language-plaintext highlighter-rouge">__define_method</code> looks:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">:,</span> <span class="n">body_iseq</span><span class="p">:)</span>
  <span class="n">parent_nesting</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">nesting</span>
  <span class="n">define_on</span> <span class="o">=</span> <span class="no">MethodDefinitionScope</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span>

  <span class="n">define_on</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
    <span class="n">execute</span><span class="p">(</span><span class="n">body_iseq</span><span class="p">,</span> <span class="ss">_self: </span><span class="nb">self</span><span class="p">,</span> <span class="ss">method_args: </span><span class="n">method_args</span><span class="p">,</span> <span class="ss">block: </span><span class="n">block</span><span class="p">,</span> <span class="ss">parent_nesting: </span><span class="n">parent_nesting</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">method_name</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When we enter a method in Ruby it inherits <code class="language-plaintext highlighter-rouge">Module.nesting</code> of a frame that defines it. This is why we also copy <code class="language-plaintext highlighter-rouge">current_frame.nesting</code> to a method frame.</p>

<p><code class="language-plaintext highlighter-rouge">define_on = MethodDefinitionScope.new(current_frame)</code> is also quite simple:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MethodDefinitionScope</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="k">when</span> <span class="no">Class</span><span class="p">,</span> <span class="no">Module</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="k">when</span> <span class="no">TOPLEVEL_BINDING</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s1">'self'</span><span class="p">)</span>
      <span class="no">Object</span>
    <span class="k">else</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">singleton_class</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>If we define a method in a global scope it is defined on the <code class="language-plaintext highlighter-rouge">Object</code> class.</li>
  <li>If we define a method inside a class/module context - well, class/module is where the method will be defined.</li>
  <li>If we define a method inside some other context (inside <code class="language-plaintext highlighter-rouge">instance_eval</code> for example) - the method is defined on the singleton class of the object.</li>
</ul>

<p>These code constructions are equivalent:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span>
<span class="c1"># and</span>
<span class="no">Object</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">class</span> <span class="nc">X</span><span class="p">;</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span> <span class="k">end</span>
<span class="c1"># and</span>
<span class="no">X</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">o</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="n">o</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="p">{</span> <span class="k">def</span> <span class="nf">m</span><span class="p">;</span> <span class="k">end</span> <span class="p">}</span>
<span class="c1"># and</span>
<span class="n">o</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Then comes this part:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">define_on</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
  <span class="n">execute</span><span class="p">(</span><span class="n">body_iseq</span><span class="p">,</span> <span class="ss">_self: </span><span class="nb">self</span><span class="p">,</span> <span class="ss">method_args: </span><span class="n">method_args</span><span class="p">,</span> <span class="ss">block: </span><span class="n">block</span><span class="p">,</span> <span class="ss">parent_nesting: </span><span class="n">parent_nesting</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We define a method that takes any arguments (it breaks <code class="language-plaintext highlighter-rouge">Method#parameters</code>, but let’s ignore it) and an optional block and executes the ISeq of the method body in a context of <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>I admit that it’s a very hacky trick, but it allows us to dynamically assign <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>Plus, we pass all other things that can (and in most cases will) be used in a method body:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">method_args</code> - what was given to a particular invocation of our method</li>
  <li><code class="language-plaintext highlighter-rouge">block</code> - a block given to a method call</li>
  <li><code class="language-plaintext highlighter-rouge">parent_nesting</code> - <code class="language-plaintext highlighter-rouge">Module.nesting</code> in the outer scope. We have to store in the beginning of the method definition because it may change before the method gets called.</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">execute(iseq, **options)</code> is a tiny wrapper that pushes the frame into the <code class="language-plaintext highlighter-rouge">frame_stack</code> depending on the <code class="language-plaintext highlighter-rouge">kind</code> of the given iseq:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">)</span>
  <span class="n">push_frame</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">evaluate_last_frame</span>
  <span class="n">pop_frame</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">push_frame</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">iseq</span><span class="p">.</span><span class="nf">kind</span>
  <span class="k">when</span> <span class="ss">:top</span>
    <span class="vi">@frame_stack</span><span class="p">.</span><span class="nf">push_top</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span>
    <span class="p">)</span>
  <span class="k">when</span> <span class="ss">:method</span>
    <span class="vi">@frame_stack</span><span class="p">.</span><span class="nf">push_method</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">parent_nesting: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:parent_nesting</span><span class="p">],</span>
      <span class="ss">_self: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:_self</span><span class="p">],</span>
      <span class="ss">arg_values: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:method_args</span><span class="p">],</span>
      <span class="ss">block: </span><span class="n">payload</span><span class="p">[</span><span class="ss">:block</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"Unknown iseq kind </span><span class="si">#{</span><span class="n">iseq</span><span class="p">.</span><span class="nf">kind</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="local-variables">local variables</h5>

<p>there are 2 most-commonly used instructions to get/set locals:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getlocal</code></li>
  <li><code class="language-plaintext highlighter-rouge">setlocal</code></li>
</ul>

<p>Both take two arguments:</p>

<ul>
  <li>an offset of the frame where the variable is stored</li>
  <li>an ID of the variable</li>
</ul>

<p>Here’s an example</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a = 10; b = 20; a; b'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>We push <code class="language-plaintext highlighter-rouge">10</code> to the stack, then we pop it and assign to a variable with ID = 4 in the current frame (<code class="language-plaintext highlighter-rouge">setlocal_WC_0</code> here is a specialized instruction that is <code class="language-plaintext highlighter-rouge">setlocal 0, 4</code> when the optimization is turned off).</p>

<p>Here’s the code to maintain locals:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'set'</span>

<span class="c1"># A simple struct that represents a single local variable;</span>
<span class="c1"># has a name, an ID and a value (or no value)</span>
<span class="no">Local</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:id</span><span class="p">,</span> <span class="ss">:value</span><span class="p">,</span> <span class="ss">keyword_init: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">get</span>
    <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># A wrapper around "Set" that holds all locals for some frame;</span>
<span class="c1"># Absolutely each frame has its own instance of "Locals"</span>
<span class="k">class</span> <span class="nc">Locals</span>
  <span class="no">UNDEFINED</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">def</span> <span class="nc">UNDEFINED</span><span class="o">.</span><span class="nf">inspect</span><span class="p">;</span> <span class="s1">'UNDEFINED'</span><span class="p">;</span> <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">initial_names</span><span class="p">)</span>
    <span class="vi">@set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">.</span><span class="nf">new</span>

    <span class="n">initial_names</span><span class="p">.</span><span class="nf">reverse_each</span><span class="p">.</span><span class="nf">with_index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
      <span class="c1"># implicit args (like a virtual attribute that holds mlhs value) have numeric names</span>
      <span class="n">arg_name</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">arg_name</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
      <span class="n">declare</span><span class="p">(</span><span class="ss">name: </span><span class="n">arg_name</span><span class="p">,</span> <span class="ss">id: </span><span class="n">idx</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="no">Locals</span><span class="o">::</span><span class="no">UNDEFINED</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">declared?</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="o">!</span><span class="n">find_if_declared</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">id: </span><span class="nb">id</span><span class="p">).</span><span class="nf">nil?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">declare</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="n">local</span> <span class="o">=</span> <span class="no">Local</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">id: </span><span class="nb">id</span><span class="p">,</span> <span class="ss">value: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="vi">@set</span> <span class="o">&lt;&lt;</span> <span class="n">local</span>
    <span class="n">local</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">find_if_declared</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">name</span>
      <span class="vi">@set</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">var</span><span class="o">|</span> <span class="n">var</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="nb">name</span> <span class="p">}</span>
    <span class="k">elsif</span> <span class="nb">id</span>
      <span class="vi">@set</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">var</span><span class="o">|</span> <span class="n">var</span><span class="p">.</span><span class="nf">id</span> <span class="o">==</span> <span class="nb">id</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"At least one of name:/id: is required"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">find_if_declared</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">id: </span><span class="nb">id</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s2">"No local name=</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">/id=</span><span class="si">#{</span><span class="nb">id</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty</span>
    <span class="vi">@set</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">local</span><span class="o">|</span> <span class="p">[</span><span class="s2">"</span><span class="si">#{</span><span class="n">local</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="n">local</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">)"</span><span class="p">,</span> <span class="n">local</span><span class="p">.</span><span class="nf">value</span><span class="p">]</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">|</span> <span class="nb">name</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">to_h</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">locals</code> inside a frame is just a set. It is possible to declare a local, to check if it’s declared and to get it.</p>

<p>Here’s the implementation of <code class="language-plaintext highlighter-rouge">getlocal</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getlocal</span><span class="p">(</span><span class="n">local_var_id</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="nf">parent_frame</span> <span class="p">}</span>
  <span class="n">local</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">id: </span><span class="n">local_var_id</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">local</span><span class="p">.</span><span class="nf">get</span>
  <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="no">Locals</span><span class="o">::</span><span class="no">UNDEFINED</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
  <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We jump out <code class="language-plaintext highlighter-rouge">n</code> times to get the Nth frame, we find a local, we return <code class="language-plaintext highlighter-rouge">nil</code> if it’s <code class="language-plaintext highlighter-rouge">undefined</code> and we push the value back to the stack (so the result can be used by a subsequent instruction)</p>

<p>Here’s the implementation of <code class="language-plaintext highlighter-rouge">setlocal</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_setlocal</span><span class="p">(</span><span class="n">local_var_id</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="nf">parent_frame</span> <span class="p">}</span>
  <span class="n">local</span> <span class="o">=</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">existing_local</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">locals</span><span class="p">.</span><span class="nf">find_if_declared</span><span class="p">(</span><span class="ss">id: </span><span class="n">local_var_id</span><span class="p">))</span>
      <span class="n">existing_local</span>
    <span class="k">elsif</span> <span class="n">frame</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="n">current_frame</span><span class="p">)</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">locals</span><span class="p">.</span><span class="nf">declare</span><span class="p">(</span><span class="ss">id: </span><span class="n">local_var_id</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s1">'locals are malformed'</span>
    <span class="k">end</span>

  <span class="n">local</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This one is a bit more complicated:</p>

<ol>
  <li>first, we <code class="language-plaintext highlighter-rouge">pop</code> the value from the stack (it was pushed by a previous instruction <code class="language-plaintext highlighter-rouge">putobject 10</code>)</li>
  <li>then we find Nth frame</li>
  <li>then we get a local from this frame</li>
  <li>if it’s there we use it; if not - we declare it in the current frame</li>
  <li>and then we set the value</li>
</ol>

<h5 id="method-arguments">method arguments</h5>

<p>Every method has a list of arguments. Yes, sometimes it’s empty, but even in such case we do an arity check. In general arguments initialization is a part of every method call.</p>

<p>This part of Ruby is really complicated, because we have 12 argument types:</p>

<ul>
  <li>required positional argument - <code class="language-plaintext highlighter-rouge">def m(x)</code></li>
  <li>optional positional argument - <code class="language-plaintext highlighter-rouge">def m(x = 42)</code></li>
  <li>rest argument - <code class="language-plaintext highlighter-rouge">def m(*x)</code></li>
  <li>post argument - <code class="language-plaintext highlighter-rouge">def m(*, x = 1)</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlhs</code> argument (can be used as a post argument too) - <code class="language-plaintext highlighter-rouge">def m( (x, *y, z) )</code></li>
  <li>required keyword argument - <code class="language-plaintext highlighter-rouge">def m(x:)</code></li>
  <li>optional keyword argument - <code class="language-plaintext highlighter-rouge">def m(x: 42)</code></li>
  <li>rest keyword argument - <code class="language-plaintext highlighter-rouge">def m(**x)</code></li>
  <li>block argument - <code class="language-plaintext highlighter-rouge">def m(&amp;x)</code></li>
  <li>shadow argument - <code class="language-plaintext highlighter-rouge">proc { |;x| }</code> (I did not implement it because I never used it)</li>
  <li><code class="language-plaintext highlighter-rouge">nil</code> keyword argument (since 2.7) - <code class="language-plaintext highlighter-rouge">def m(**nil)</code></li>
  <li>arguments forwarding (also since 2.7) - <code class="language-plaintext highlighter-rouge">def m(...)</code></li>
</ul>

<p>First, let’s take a look at the iseq to see what we have:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'def m(a, b = 42, *c, d); end'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="s2">"YARVInstructionSequence/SimpleDataFormat"</span><span class="p">,</span>
 <span class="mi">2</span><span class="p">,</span>
 <span class="mi">6</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="p">{</span><span class="ss">:arg_size</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span>
  <span class="ss">:local_size</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span>
  <span class="ss">:stack_max</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:node_id</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span>
  <span class="ss">:code_location</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">]},</span>
 <span class="s2">"m"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
 <span class="mi">1</span><span class="p">,</span>
 <span class="ss">:method</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="ss">:c</span><span class="p">,</span> <span class="ss">:d</span><span class="p">],</span>
 <span class="p">{</span><span class="ss">:opt</span><span class="o">=&gt;</span><span class="p">[</span><span class="ss">:label_0</span><span class="p">,</span> <span class="ss">:label_4</span><span class="p">],</span>
  <span class="ss">:lead_num</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:post_num</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
  <span class="ss">:post_start</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">,</span>
  <span class="ss">:rest_start</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">},</span>
 <span class="p">[],</span>
 <span class="p">[</span><span class="ss">:label_0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
  <span class="ss">:label_4</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
  <span class="ss">:RUBY_EVENT_RETURN</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]</span>
</code></pre></div></div>

<p>There are two entries that we are interested in:</p>

<ol>
  <li>a list of argument names (well, it’s a list of all variables, but it works for our case)</li>
  <li>a hash with arguments information</li>
</ol>

<p>Let’s prepare and group it first, it’s hard to work with such format:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CategorizedArguments</span>
  <span class="nb">attr_reader</span> <span class="ss">:req</span><span class="p">,</span> <span class="ss">:opt</span><span class="p">,</span> <span class="ss">:rest</span><span class="p">,</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:kw</span><span class="p">,</span> <span class="ss">:kwrest</span><span class="p">,</span> <span class="ss">:block</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">arg_names</span><span class="p">,</span> <span class="n">args_info</span><span class="p">)</span>
    <span class="vi">@req</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="vi">@opt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="vi">@rest</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="vi">@post</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">parse!</span><span class="p">(</span><span class="n">arg_names</span><span class="p">.</span><span class="nf">dup</span><span class="p">,</span> <span class="n">args_info</span><span class="p">.</span><span class="nf">dup</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse!</span><span class="p">(</span><span class="n">arg_names</span><span class="p">,</span> <span class="n">args_info</span><span class="p">)</span>
    <span class="p">(</span><span class="n">args_info</span><span class="p">[</span><span class="ss">:lead_num</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">req</span> <span class="o">&lt;&lt;</span> <span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">opt_info</span> <span class="o">=</span> <span class="n">args_info</span><span class="p">[</span><span class="ss">:opt</span><span class="p">].</span><span class="nf">dup</span> <span class="o">||</span> <span class="p">[]</span>
    <span class="n">opt_info</span><span class="p">.</span><span class="nf">shift</span>
    <span class="n">opt_info</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">label</span><span class="o">|</span>
      <span class="n">opt</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">),</span> <span class="n">label</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">args_info</span><span class="p">[</span><span class="ss">:rest_start</span><span class="p">]</span>
      <span class="vi">@rest</span> <span class="o">=</span> <span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="p">(</span><span class="n">args_info</span><span class="p">[</span><span class="ss">:post_num</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">post</span> <span class="o">&lt;&lt;</span> <span class="n">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">take_arg</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)</span>
    <span class="n">arg_name_or_idx</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">.</span><span class="nf">shift</span>

    <span class="k">if</span> <span class="n">arg_name_or_idx</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
      <span class="n">arg_name_or_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>

    <span class="n">arg_name_or_idx</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I intentionally skip keyword arguments here, but they are not that much different from other types of arguments. The only noticeable difference is that optional keyword arguments have “inlined” default values if they are simple enough (like plain strings or numbers, but not expressions like <code class="language-plaintext highlighter-rouge">2+2</code>). If you are interested you can go to the repository and check this file.</p>

<p>Then, we should parse arguments and assign them into local variables <strong>when we push a method frame</strong> (so they are available once we start executing instructions of a method body):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MethodArguments</span>
  <span class="nb">attr_reader</span> <span class="ss">:args</span><span class="p">,</span> <span class="ss">:values</span><span class="p">,</span> <span class="ss">:locals</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">iseq</span><span class="p">:,</span> <span class="n">values</span><span class="p">:,</span> <span class="n">locals</span><span class="p">:)</span>
    <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">dup</span>
    <span class="vi">@locals</span> <span class="o">=</span> <span class="n">locals</span>
    <span class="vi">@iseq</span> <span class="o">=</span> <span class="n">iseq</span>

    <span class="vi">@args</span> <span class="o">=</span> <span class="no">CategorizedArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="n">iseq</span><span class="p">.</span><span class="nf">lvar_names</span><span class="p">,</span>
      <span class="n">iseq</span><span class="p">.</span><span class="nf">args_info</span>
    <span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="kp">false</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">req</span><span class="p">.</span><span class="nf">count</span> <span class="o">+</span> <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">count</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'wrong number of arguments (too few)'</span>
    <span class="k">end</span>

    <span class="c1"># Required positional args</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">req</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">empty?</span>
        <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'wrong number of arguments (too few)'</span>
      <span class="k">end</span>

      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">shift</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Optional positional args</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">opt</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span><span class="o">|</span>
      <span class="k">break</span> <span class="k">if</span> <span class="n">values</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">count</span>

      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">shift</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

      <span class="no">VM</span><span class="p">.</span><span class="nf">jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Rest positional argument</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">name</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="nf">rest</span><span class="p">)</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">first</span><span class="p">([</span><span class="n">values</span><span class="p">.</span><span class="nf">length</span> <span class="o">-</span> <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">max</span><span class="p">)</span>
      <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">last</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">length</span><span class="p">)</span>

      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Required post positional arguments</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">post</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">empty?</span>
        <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'Broken arguments, cannot extract required argument'</span>
      <span class="k">end</span>

      <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">shift</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Make sure there are no arguments left</span>
    <span class="k">if</span> <span class="n">arity_check</span> <span class="o">&amp;&amp;</span> <span class="n">values</span><span class="p">.</span><span class="nf">any?</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'wrong number of arguments (too many)'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">values</code> is what we get in a method call in <code class="language-plaintext highlighter-rouge">*method_args</code>, <code class="language-plaintext highlighter-rouge">locals</code> is equal to <code class="language-plaintext highlighter-rouge">MethodFrame#locals</code> that is set to <code class="language-plaintext highlighter-rouge">Locals.new</code> by default.</p>

<p>Let’s write <code class="language-plaintext highlighter-rouge">MethodFrame</code> class!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MethodFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">attr_reader</span> <span class="ss">:arg_values</span>

  <span class="nb">attr_reader</span> <span class="ss">:block</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">parent_nesting</span><span class="p">:,</span> <span class="n">_self</span><span class="p">:,</span> <span class="n">arg_values</span><span class="p">:,</span> <span class="n">block</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_nesting</span>

    <span class="vi">@block</span> <span class="o">=</span> <span class="n">block</span>

    <span class="no">MethodArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">values: </span><span class="n">arg_values</span><span class="p">,</span>
      <span class="ss">locals: </span><span class="n">locals</span><span class="p">,</span>
      <span class="ss">block: </span><span class="n">iseq</span><span class="p">.</span><span class="nf">args_info</span><span class="p">[</span><span class="ss">:block_start</span><span class="p">]</span> <span class="p">?</span> <span class="n">block</span> <span class="p">:</span> <span class="kp">nil</span>
    <span class="p">).</span><span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty_name</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">_self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">#</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Method frame is just a regular frame that extracts arguments during its initialization.</p>

<h5 id="constants">constants</h5>

<p>A regular constant assignment (like <code class="language-plaintext highlighter-rouge">A = 1</code>) is based on a scope (<code class="language-plaintext highlighter-rouge">Module.nesting</code> for relative lookup) and two instructions:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">setconstant</code></li>
  <li><code class="language-plaintext highlighter-rouge">getconstant</code></li>
</ol>

<p>Both have a single argument - a constant name. But how does Ruby distinguish relative and absolute constant lookup? I mean, what’s the difference between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">::A</code>?</p>

<p>Ruby uses a special instruction to set a “constant scope” that:</p>

<ul>
  <li>for relative lookup
    <ul>
      <li>in the optimized mode does <code class="language-plaintext highlighter-rouge">opt_getinlinecache</code> before <code class="language-plaintext highlighter-rouge">get/setconstant</code></li>
      <li>in the non-optimized mode does <code class="language-plaintext highlighter-rouge">pushnil</code> (that works as a flag)</li>
    </ul>
  </li>
  <li>for absolute lookup Ruby computes it via a sequence of instructions</li>
</ul>

<p>Let’s take a look at the non-optimized mode (because we can’t optimize it anyway):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'A; ::B; Kernel::D'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:A</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:pop</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="no">Object</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:B</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:pop</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:Kernel</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:D</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">A</code> constant performs a relative lookup, so <code class="language-plaintext highlighter-rouge">putnil</code> is used.</p>

<p><code class="language-plaintext highlighter-rouge">::B</code> constant performs a global lookup on the <code class="language-plaintext highlighter-rouge">Object</code> that is a known object, and so it’s inlined in the <code class="language-plaintext highlighter-rouge">putobject</code> instruction.</p>

<p><code class="language-plaintext highlighter-rouge">Kernel::D</code> first searches for <code class="language-plaintext highlighter-rouge">Kernel</code> constant locally, then it uses it as a “scope” for a constant <code class="language-plaintext highlighter-rouge">D</code>.</p>

<p>Quite easy, right? Not so fast. Ruby uses <code class="language-plaintext highlighter-rouge">Module.nesting</code> to perform a bottom-top search. This is why it’s so important to maintain <code class="language-plaintext highlighter-rouge">nesting</code> value in frames. Thus, the lookup is performed on <code class="language-plaintext highlighter-rouge">current_scope.nesting</code> <strong>in reverse order</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getconstant</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">search_in</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="n">current_scope</span><span class="p">.</span><span class="nf">nesting</span><span class="p">.</span><span class="nf">reverse</span> <span class="p">:</span> <span class="p">[</span><span class="n">scope</span><span class="p">]</span>

  <span class="n">search_in</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">mod</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">.</span><span class="nf">const_defined?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">const</span> <span class="o">=</span> <span class="n">mod</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="n">push</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="no">NameError</span><span class="p">,</span> <span class="s2">"uninitialized constant </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If the scope is given (via <code class="language-plaintext highlighter-rouge">push</code> in a previous instruction) we use it. Otherwise we have a relative lookup and so we must use <code class="language-plaintext highlighter-rouge">current_scope.nesting.reverse</code>.</p>

<p><code class="language-plaintext highlighter-rouge">setconstant</code> is a bit simpler, because it always defines a constant on a scope set by a previous instruction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'A = 10; ::B = 20; Kernel::D = 30'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putspecialobject</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setconstant</span><span class="p">,</span> <span class="ss">:A</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="no">Object</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setconstant</span><span class="p">,</span> <span class="ss">:B</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:Kernel</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setconstant</span><span class="p">,</span> <span class="ss">:D</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">putspecialobject</code> is an instruction that is (when called with 3) pushes a “current” scope.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">putspecialobject</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">kind</span>
  <span class="k">when</span> <span class="mi">3</span>
    <span class="n">push</span><span class="p">(</span><span class="n">current_frame</span><span class="p">.</span><span class="nf">nesting</span><span class="p">.</span><span class="nf">last</span><span class="p">)</span> <span class="c1"># push "current" scope</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"Unknown special object </span><span class="si">#{</span><span class="n">kind</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">setconstant</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">scope</span><span class="p">.</span><span class="nf">const_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="instanceclass-variables">Instance/Class variables</h5>

<p>Instance variables are always picked from the <code class="language-plaintext highlighter-rouge">self</code> of the current frame (they literally look like a simplified version of local variables that are always stored in <code class="language-plaintext highlighter-rouge">self</code> of the current scope):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'@a = 42; @a'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setinstancevariable</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getinstancevariable</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>I guess you know how the code should look like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getinstancevariable</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_setinstancevariable</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Class variables are similar, but it is possible to get it in the instance method, so it uses <code class="language-plaintext highlighter-rouge">self</code> if our current frame is a <code class="language-plaintext highlighter-rouge">ClassFrame</code> or <code class="language-plaintext highlighter-rouge">self.class</code> otherwise:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'@@a = 42; @@a'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setclassvariable</span><span class="p">,</span> <span class="ss">:@@a</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getclassvariable</span><span class="p">,</span> <span class="ss">:@@a</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">execute_setclassvariable</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class</span> <span class="k">unless</span> <span class="n">klass</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">class_variable_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_getclassvariable</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class</span> <span class="k">unless</span> <span class="n">klass</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">class_variable_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="literals">Literals</h5>

<p>But how can we construct arrays, hashes?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'[ [:foo,a,:bar], [4,5], 42 ]'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:foo</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newarray</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:duparray</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newarray</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>As you can see the strategy of building an array depends on its dynamicity:</p>

<ul>
  <li>for dynamic <code class="language-plaintext highlighter-rouge">[:foo, a, :bar]</code> MRI uses <code class="language-plaintext highlighter-rouge">newarray</code> (because <code class="language-plaintext highlighter-rouge">a</code> has to be computed in runtime)</li>
  <li>for primitive <code class="language-plaintext highlighter-rouge">[4, 5]</code> it uses <code class="language-plaintext highlighter-rouge">duparray</code> (because it’s faster)</li>
</ul>

<p>The whole array is also dynamic (because one of its elements is also dynamic). Let’s define them:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_duparray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="nf">dup</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_newarray</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">size</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">push</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Do hashes support inlining?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'{ primitive: { foo: :bar }, dynamic: { c: d } }'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:primitive</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:duphash</span><span class="p">,</span> <span class="p">{</span><span class="ss">:foo</span><span class="o">=&gt;</span><span class="ss">:bar</span><span class="p">}],</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:dynamic</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:c</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:d</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newhash</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:newhash</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Yes! <code class="language-plaintext highlighter-rouge">duphash</code> contains an inlined hash that should be pushed to the stack as is. <code class="language-plaintext highlighter-rouge">newhash</code> has a numeric argument that represents the number of keys and values on the hash (i.e. <code class="language-plaintext highlighter-rouge">keys * 2</code> or <code class="language-plaintext highlighter-rouge">values * 2</code>, there’s no difference). And once again, if at least one element of the hash is dynamic, the whole has is also dynamic and so it uses <code class="language-plaintext highlighter-rouge">newhash</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_duphash</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="nb">hash</span><span class="p">.</span><span class="nf">dup</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_newhash</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="nb">hash</span> <span class="o">=</span> <span class="n">size</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">to_h</span>
  <span class="n">push</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Why do we need <code class="language-plaintext highlighter-rouge">.dup</code> in <code class="language-plaintext highlighter-rouge">duphash</code> and <code class="language-plaintext highlighter-rouge">duparray</code>? The reason is simple: this instruction can be executed multiple times (if it’s a part of a method or block, for example), and so the same value will be pushed to the stack multiple times. One of the next instructions can modify it but literals have to stay static no matter what. Without using <code class="language-plaintext highlighter-rouge">.dup</code> the code like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">p</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">pop</span>
<span class="k">end</span>
</code></pre></div></div>

<p>would print <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">2</code>.</p>

<h5 id="splats">Splats</h5>

<p>Splat is one of the most beautiful features of Ruby. Splat is <code class="language-plaintext highlighter-rouge">foo, bar = *baz</code> (and also <code class="language-plaintext highlighter-rouge">[*foo, *bar]</code>):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a, b = *c, 42'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:c</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:splatarray</span><span class="p">,</span> <span class="kp">true</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newarray</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:concatarray</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:expandarray</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">splatarray</code> pops the object from the stack, converts it to <code class="language-plaintext highlighter-rouge">Array</code> by calling <code class="language-plaintext highlighter-rouge">to_a</code> (if it’s not an array; otherwise there’s no type casting), and pushes the result back to the stack.</p>

<p><code class="language-plaintext highlighter-rouge">concatarray</code> constructs an array from two top elements and pushes it back. So it changes the stack <code class="language-plaintext highlighter-rouge">[a, b]</code> to <code class="language-plaintext highlighter-rouge">[ [a,b] ]</code>. If items are arrays it expands and merges them.</p>

<p><code class="language-plaintext highlighter-rouge">expandarray</code> expands it by doing <code class="language-plaintext highlighter-rouge">pop</code> and pushing items back to the stack. It takes the number of elements that need to be returned, so if an array is bigger it drops some items, if it’s too small - it pushes as many <code class="language-plaintext highlighter-rouge">nil</code>s as needed.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_splatarray</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">to_a</span> <span class="k">unless</span> <span class="n">array</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_concatarray</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
  <span class="n">last</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">first</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">push</span><span class="p">([</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">])</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_expandarray</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">_flag</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="k">if</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">&lt;</span> <span class="n">size</span>
    <span class="n">array</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span> <span class="k">until</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="n">size</span>
  <span class="k">elsif</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">&gt;</span> <span class="n">size</span>
    <span class="n">array</span><span class="p">.</span><span class="nf">pop</span> <span class="k">until</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="n">size</span>
  <span class="k">else</span>
    <span class="c1"># they are equal</span>
  <span class="k">end</span>

  <span class="n">array</span><span class="p">.</span><span class="nf">reverse_each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="n">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In fact <code class="language-plaintext highlighter-rouge">expandarray</code> is much, much more complicated, you can go to the repository and check it if you want.</p>

<p>Keyword splats (like <code class="language-plaintext highlighter-rouge">{ **x, **y }</code>) are really similar to array splats, I’m not going to cover them here.</p>

<h5 id="conditions-ifunless">conditions (if/unless)</h5>

<p>To handle conditions Ruby uses local <code class="language-plaintext highlighter-rouge">goto</code> (just like in C). Target of the <code class="language-plaintext highlighter-rouge">goto</code>-like instruction is a label:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"a = b = c = 42; if a; b; else; c; end"</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:branchunless</span><span class="p">,</span> <span class="ss">:label_20</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:jump</span><span class="p">,</span> <span class="ss">:label_16</span><span class="p">],</span>

 <span class="ss">:label_16</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:jump</span><span class="p">,</span> <span class="ss">:label_22</span><span class="p">],</span>

 <span class="ss">:label_20</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>

 <span class="ss">:label_22</span><span class="p">,</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Do you see these <code class="language-plaintext highlighter-rouge">:label_&lt;NN&gt;</code> symbols? They are used as markers. <code class="language-plaintext highlighter-rouge">branchunless</code> takes a single argument: a label that it to jump to if the value on the top of the stack is <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">nil</code>. If it’s <code class="language-plaintext highlighter-rouge">true</code>-like it does nothing.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_branchunless</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="n">cond</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="k">unless</span> <span class="n">cond</span>
    <span class="n">jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="n">insns</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">iseq</span><span class="p">.</span><span class="nf">insns</span>
  <span class="n">insns</span><span class="p">.</span><span class="nf">drop_while</span> <span class="p">{</span> <span class="o">|</span><span class="n">insn</span><span class="o">|</span> <span class="n">insn</span> <span class="o">!=</span> <span class="n">label</span> <span class="p">}</span>
  <span class="n">insns</span><span class="p">.</span><span class="nf">shift</span> <span class="c1"># to drop the label too</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here we do <code class="language-plaintext highlighter-rouge">pop</code>, check it and call <code class="language-plaintext highlighter-rouge">jump</code> if it’s <code class="language-plaintext highlighter-rouge">false</code>. <code class="language-plaintext highlighter-rouge">jump</code> skips instructions until it sees a given label.</p>

<p>MRI also has <code class="language-plaintext highlighter-rouge">branchif</code> and <code class="language-plaintext highlighter-rouge">branchnil</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">branchif</code> does <code class="language-plaintext highlighter-rouge">if cond</code>  as a main check</li>
  <li><code class="language-plaintext highlighter-rouge">branchnil</code> does <code class="language-plaintext highlighter-rouge">if cond.nil?</code></li>
</ul>

<h5 id="string-interpolationconcatenation">String interpolation/concatenation</h5>

<p>Ruby has a few compile-time optimizations that optimize code like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"a""b"</span>
<span class="s2">"</span><span class="si">#{</span><span class="s1">'a'</span><span class="si">}#{</span><span class="s1">'b'</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>into a string <code class="language-plaintext highlighter-rouge">"ab"</code>. However more complicated cases with dynamic interpolation involve a few new instructions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'"#{a}#{:sym}"'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="s2">""</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">28</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:checktype</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:branchif</span><span class="p">,</span> <span class="ss">:label_18</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:to_s</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:tostring</span><span class="p">],</span>
 <span class="ss">:label_18</span><span class="p">,</span>

 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="ss">:sym</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:checktype</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:branchif</span><span class="p">,</span> <span class="ss">:label_31</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:dup</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:to_s</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:tostring</span><span class="p">],</span>
 <span class="ss">:label_31</span><span class="p">,</span>

 <span class="p">[</span><span class="ss">:concatstrings</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Parts above are split into sections.</p>

<ol>
  <li>There’s an “invisible” beginning of the string (<code class="language-plaintext highlighter-rouge">putobject ""</code>)</li>
  <li>Then we have an interpolated method call <code class="language-plaintext highlighter-rouge">a</code>:</li>
  <li>First we call <code class="language-plaintext highlighter-rouge">a</code> via <code class="language-plaintext highlighter-rouge">send</code></li>
  <li>then we run <code class="language-plaintext highlighter-rouge">checktype</code> instruction that checks for an argument <code class="language-plaintext highlighter-rouge">5</code> that what’s popped is a string. it pushes back a boolean value</li>
  <li>then we conditionally invoke <code class="language-plaintext highlighter-rouge">to_s</code> if the object is not a string</li>
  <li>then we have an interpolated symbol <code class="language-plaintext highlighter-rouge">:sym</code> that gets interpolated in the same way</li>
  <li>and finally we invoke <code class="language-plaintext highlighter-rouge">concatstrings 3</code> that does <code class="language-plaintext highlighter-rouge">pop</code> 3 times, concatenates 3 strings and pushes the result back to the stack</li>
</ol>

<p>First let’s take a look at the <code class="language-plaintext highlighter-rouge">checktype</code> instruction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">CHECK_TYPE</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">klass</span> <span class="o">===</span> <span class="n">obj</span>
<span class="p">}.</span><span class="nf">curry</span>

<span class="no">RB_OBJ_TYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mh">0x00</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_NONE</span>

  <span class="mh">0x01</span> <span class="o">=&gt;</span> <span class="no">CHECK_TYPE</span><span class="p">[</span><span class="no">Object</span><span class="p">],</span>                        <span class="c1"># RUBY_T_OBJECT</span>
  <span class="mh">0x02</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_CLASS</span>
  <span class="mh">0x03</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MODULE</span>
  <span class="mh">0x04</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FLOAT</span>
  <span class="mh">0x05</span> <span class="o">=&gt;</span> <span class="no">CHECK_TYPE</span><span class="p">[</span><span class="no">String</span><span class="p">],</span>                        <span class="c1"># RUBY_T_STRING</span>
  <span class="mh">0x06</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_REGEXP</span>
  <span class="mh">0x07</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_ARRAY</span>
  <span class="mh">0x08</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_HASH</span>
  <span class="mh">0x09</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_STRUCT</span>
  <span class="mh">0x0a</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_BIGNUM</span>
  <span class="mh">0x0b</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FILE</span>
  <span class="mh">0x0c</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_DATA</span>
  <span class="mh">0x0d</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MATCH</span>
  <span class="mh">0x0e</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_COMPLEX</span>
  <span class="mh">0x0f</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_RATIONAL</span>

  <span class="mh">0x11</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_NIL</span>
  <span class="mh">0x12</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_TRUE</span>
  <span class="mh">0x13</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FALSE</span>
  <span class="mh">0x14</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_SYMBOL</span>
  <span class="mh">0x15</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_FIXNUM</span>
  <span class="mh">0x16</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_UNDEF</span>

  <span class="mh">0x1a</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_IMEMO</span>
  <span class="mh">0x1b</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_NODE</span>
  <span class="mh">0x1c</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_ICLASS</span>
  <span class="mh">0x1d</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_ZOMBIE</span>
  <span class="mh">0x1e</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MOVED</span>

  <span class="mh">0x1f</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">NotImplementedError</span> <span class="p">},</span>     <span class="c1"># RUBY_T_MASK</span>
<span class="p">}.</span><span class="nf">freeze</span>

<span class="k">def</span> <span class="nf">execute_checktype</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
  <span class="n">item_to_check</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">check</span> <span class="o">=</span> <span class="no">RB_OBJ_TYPES</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s2">"checktype - unknown type </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">check</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">item_to_check</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I blindly took it from MRI and yes, this instruction supports many types. I implemented only two of them, but the rest looks simple (except <code class="language-plaintext highlighter-rouge">imemo</code> and friends). Honestly I have no idea why, but about 95% of specs from the RubySpec (only language group, I did not check the whole test suite) are passing with these missing parts. I have no idea how to trigger MRI to use them. Maybe it uses them internally?</p>

<p><code class="language-plaintext highlighter-rouge">concatstrings</code> looks just like <code class="language-plaintext highlighter-rouge">newarray</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_concatstrings</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
  <span class="n">strings</span> <span class="o">=</span> <span class="n">count</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">push</span><span class="p">(</span><span class="n">strings</span><span class="p">.</span><span class="nf">join</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="blocks">Blocks</h5>

<p>Blocks are passed to method calls as a third argument:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'m { |a| a + 42 }'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putself</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span>
  <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:m</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">},</span>
  <span class="kp">false</span><span class="p">,</span>
  <span class="p">[</span><span class="s2">"YARVInstructionSequence/SimpleDataFormat"</span><span class="p">,</span>
   <span class="mi">2</span><span class="p">,</span>
   <span class="mi">6</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
   <span class="p">{</span><span class="ss">:arg_size</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">:local_size</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">:stack_max</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span>
    <span class="ss">:node_id</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span>
    <span class="ss">:code_location</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">]},</span>
   <span class="s2">"block in &lt;compiled&gt;"</span><span class="p">,</span>
   <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
   <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
   <span class="ss">:block</span><span class="p">,</span>
   <span class="p">[</span><span class="ss">:a</span><span class="p">],</span>
   <span class="p">{</span><span class="ss">:lead_num</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:ambiguous_param0</span><span class="o">=&gt;</span><span class="kp">true</span><span class="p">},</span>
   <span class="p">[[</span><span class="ss">:redo</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:label_1</span><span class="p">,</span> <span class="ss">:label_9</span><span class="p">,</span> <span class="ss">:label_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:next</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:label_1</span><span class="p">,</span> <span class="ss">:label_9</span><span class="p">,</span> <span class="ss">:label_9</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
   <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">:RUBY_EVENT_B_CALL</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:nop</span><span class="p">],</span>
    <span class="ss">:label_1</span><span class="p">,</span>
    <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
    <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">16</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
    <span class="ss">:label_9</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:nop</span><span class="p">],</span>
    <span class="ss">:RUBY_EVENT_B_RETURN</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]]]</span>
</code></pre></div></div>

<p>Block definitely needs a frame that looks pretty much like a <code class="language-plaintext highlighter-rouge">MethodFrame</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">BlockFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:arg_values</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">arg_values</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">nesting</span>

    <span class="no">MethodArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">values: </span><span class="n">arg_values</span><span class="p">,</span>
      <span class="ss">locals: </span><span class="n">locals</span><span class="p">,</span>
      <span class="ss">block: </span><span class="kp">nil</span>
    <span class="p">).</span><span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="kp">false</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pretty_name</span>
    <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>(For simplicity let’s ignore that blocks can also take blocks; also let’s ignore lambdas, we will return to them later)</p>

<p>The code above looks <strong>almost</strong> like a method frame. The only difference is the <code class="language-plaintext highlighter-rouge">arity_check</code> value that we pass to the <code class="language-plaintext highlighter-rouge">MethodArguments</code> class.</p>

<p>But when should we create this frame? And how can we get a proc from it?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VM_CALL_ARGS_BLOCKARG</span>   <span class="o">=</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">execute_send</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">block_iseq</span><span class="p">)</span>
  <span class="n">_self</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:mid</span><span class="p">]</span>

  <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">block</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">block_iseq</span>
      <span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
        <span class="n">execute</span><span class="p">(</span><span class="n">block_iseq</span><span class="p">,</span> <span class="ss">self: </span><span class="n">_self</span><span class="p">,</span> <span class="ss">arg_values: </span><span class="n">args</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">elsif</span> <span class="n">flag</span> <span class="o">&amp;</span> <span class="no">VM_CALL_ARGS_BLOCKARG</span>
      <span class="n">pop</span>
    <span class="k">else</span>
      <span class="kp">nil</span>
    <span class="k">end</span>

  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>

  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It looks like a more generalized version of <code class="language-plaintext highlighter-rouge">opt_send_without_block</code>, because <code class="language-plaintext highlighter-rouge">opt_send_without_block</code> is a specialized implementation of <code class="language-plaintext highlighter-rouge">send</code>.</p>

<p>This instruction also pops a receiver and arguments, but what’s important, it also computes the block.</p>

<ol>
  <li>If <code class="language-plaintext highlighter-rouge">block_iseq</code> is given we create a proc that (once called) executes a block instruction (i.e. a block body) with given arguments. This block uses <code class="language-plaintext highlighter-rouge">self</code> of the place where it was created. (i.e. <code class="language-plaintext highlighter-rouge">self == proc { self }.call</code> always returns true)</li>
  <li>If there’s no <code class="language-plaintext highlighter-rouge">block_iseq</code> the block can be given via a <code class="language-plaintext highlighter-rouge">&amp;block</code> argument. MRI marks method call as <code class="language-plaintext highlighter-rouge">VM_CALL_ARGS_BLOCKARG</code> (this flag is just a bitmask)</li>
  <li>and then we simply call a method with a generated proc object.</li>
</ol>

<p>Implicit block like <code class="language-plaintext highlighter-rouge">b = proc {}; m(&amp;b)</code> does not need any additional implementation. Method <code class="language-plaintext highlighter-rouge">proc</code> here takes a block (handled by the first <code class="language-plaintext highlighter-rouge">if</code> branch), it gets stored in a local variable and we pass it to the method as a block argument (<code class="language-plaintext highlighter-rouge">elseif</code> branch).</p>

<h5 id="lambdas">Lambdas</h5>

<p>It’s complicated and I don’t have a complete solution that covers all cases (I guess because MRI does not expose enough APIs to do it. Or I’m just not smart enough).</p>

<p>Arrow lambda (<code class="language-plaintext highlighter-rouge">-&gt;(){}</code>) is just a method call <code class="language-plaintext highlighter-rouge">FrozenCore#lambda</code>, and so we can easily determine that it’s a lambda and not a proc. But what about <code class="language-plaintext highlighter-rouge">lambda {}</code>? It can be overwritten.</p>

<p>An incomplete (and somewhat unreliable) solution is to check that our receiver does not override <code class="language-plaintext highlighter-rouge">lambda</code> method inherited from a <code class="language-plaintext highlighter-rouge">Kernel</code> module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">creating_a_lambda</span> <span class="o">=</span> <span class="kp">false</span>

<span class="k">if</span> <span class="n">mid</span> <span class="o">==</span> <span class="ss">:lambda</span>
  <span class="k">if</span> <span class="n">recv</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="no">FrozenCore</span><span class="p">)</span>
    <span class="c1"># -&gt;{} syntax</span>
    <span class="n">creating_a_lambda</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">recv</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="ss">:lambda</span><span class="p">).</span><span class="nf">owner</span> <span class="o">==</span> <span class="no">Kernel</span>
    <span class="k">if</span> <span class="no">Kernel</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="ss">:lambda</span><span class="p">)</span> <span class="o">==</span> <span class="no">RubyRb</span><span class="o">::</span><span class="no">REAL_KERNEL_LAMBDA</span>
      <span class="c1"># an original "lambda" method from a Kernel module</span>
      <span class="n">creating_a_lambda</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then we can set it on our block frame as an attribute.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in the branch that creates a proc from the `block_iseq`</span>
<span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
  <span class="n">execute</span><span class="p">(</span><span class="n">block_iseq</span><span class="p">,</span> <span class="ss">self: </span><span class="n">_self</span><span class="p">,</span> <span class="ss">arg_values: </span><span class="n">args</span><span class="p">,</span> <span class="ss">is_lambda: </span><span class="n">creating_a_lambda</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">BlockFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:arg_values</span><span class="p">,</span> <span class="ss">:is_lambda</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">arg_values</span><span class="p">:,</span> <span class="n">is_lambda</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">is_lambda</span> <span class="o">=</span> <span class="n">is_lambda</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">nesting</span>

    <span class="no">MethodArguments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">iseq: </span><span class="n">iseq</span><span class="p">,</span>
      <span class="ss">values: </span><span class="n">arg_values</span><span class="p">,</span>
      <span class="ss">locals: </span><span class="n">locals</span><span class="p">,</span>
      <span class="ss">block: </span><span class="kp">nil</span>
    <span class="p">).</span><span class="nf">extract</span><span class="p">(</span><span class="ss">arity_check: </span><span class="n">is_lambda</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Arity check is enabled only if our proc is a lambda.</p>

<h5 id="calling-a-block">Calling a block</h5>

<p>If you remember when we define a method we tell it to save given block in a method frame:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">define_on</span><span class="p">.</span><span class="nf">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
  <span class="n">execute</span><span class="p">(</span><span class="n">body_iseq</span><span class="p">,</span> <span class="ss">_self: </span><span class="nb">self</span><span class="p">,</span> <span class="ss">method_args: </span><span class="n">method_args</span><span class="p">,</span> <span class="ss">block: </span><span class="n">block</span><span class="p">,</span> <span class="ss">parent_nesting: </span><span class="n">parent_nesting</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And the frame itself saves it in the <code class="language-plaintext highlighter-rouge">attr_reader</code>.</p>

<p>So both explicit and implicit blocks are available in a method body via <code class="language-plaintext highlighter-rouge">current_frame.block</code>. It’s possible to invoke it by calling <code class="language-plaintext highlighter-rouge">block.call(arguments)</code> (if it’s available as an explicit block argument) or to call <code class="language-plaintext highlighter-rouge">yield(arguments)</code> (in such case it does not even have to be declared in a method signature).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'def m; yield; end'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:invokeblock</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="kp">nil</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">16</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">}],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>Honestly even before I started working on this article I expected MRI to do something like this. <code class="language-plaintext highlighter-rouge">yield</code> is equivalent to <code class="language-plaintext highlighter-rouge">&lt;current block&gt;.call(args)</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_invokeblock</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>

  <span class="n">frame</span> <span class="o">=</span> <span class="n">current_frame</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">parent_frame</span> <span class="k">until</span> <span class="n">frame</span><span class="p">.</span><span class="nf">can_yield?</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="nf">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Do you see <code class="language-plaintext highlighter-rouge">frame = frame.parent_frame until frame.can_yield?</code>? The reason for this line is that you may have a code like</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="k">yield</span> <span class="n">item</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>^ <code class="language-plaintext highlighter-rouge">yield</code> here belongs to the method <code class="language-plaintext highlighter-rouge">m</code>, not to the <code class="language-plaintext highlighter-rouge">BlockFrame</code> of the <code class="language-plaintext highlighter-rouge">.each</code> method. There can be more nested blocks, so we have to go up until we see something that supports <code class="language-plaintext highlighter-rouge">yield</code>. Well, we know that only one frame can do <code class="language-plaintext highlighter-rouge">yield</code>: it’s a <code class="language-plaintext highlighter-rouge">MethodFrame</code>.</p>

<p>Our frame class factory need to be extended to generate this method by default and return false from it. <code class="language-plaintext highlighter-rouge">MethodFrame</code> has to override it and return <code class="language-plaintext highlighter-rouge">true</code>. Polymorphism!</p>

<h5 id="super">Super</h5>

<p>Calling <code class="language-plaintext highlighter-rouge">super</code> is very similar to calling <code class="language-plaintext highlighter-rouge">yield</code>: it can be replaced with <code class="language-plaintext highlighter-rouge">method(__method__).super_method.call(args)</code>.</p>

<p><code class="language-plaintext highlighter-rouge">__method__</code> can be retrieved from <code class="language-plaintext highlighter-rouge">current_frame.name</code>, <code class="language-plaintext highlighter-rouge">args</code> are processed using <code class="language-plaintext highlighter-rouge">options[:orig_argc]</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_invokesuper</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">super_method</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="n">mid</span><span class="p">).</span><span class="nf">super_method</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">super_method</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This implementation is incorrect, it can’t handle a sequence of <code class="language-plaintext highlighter-rouge">super</code> calls (<code class="language-plaintext highlighter-rouge">class A &lt; B &lt; C</code>, each has a method that calls <code class="language-plaintext highlighter-rouge">super</code>). I guess it’s possible to implement it by recording the class where the method was defined (i.e. by storing <code class="language-plaintext highlighter-rouge">current_frame._self</code> before calling <code class="language-plaintext highlighter-rouge">define_method</code> and passing it to the <code class="language-plaintext highlighter-rouge">MethodFrame</code> constructor as a <code class="language-plaintext highlighter-rouge">defined_in</code> attribute). This way we could do something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_invokesuper</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
  <span class="n">recv</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span>
  <span class="n">mid</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">name</span>

  <span class="n">dispatchers</span> <span class="o">=</span> <span class="n">recv</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span>
  <span class="n">current_dispatcher_idx</span> <span class="o">=</span> <span class="n">dispatchers</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">current_frame</span><span class="p">.</span><span class="nf">defined_in</span><span class="p">)</span>
  <span class="n">next_dispatcher</span> <span class="o">=</span> <span class="n">dispatchers</span><span class="p">[</span><span class="n">current_dispatcher_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

  <span class="n">super_method</span> <span class="o">=</span> <span class="n">next_dispatcher</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="n">mid</span><span class="p">).</span><span class="nf">bind</span><span class="p">(</span><span class="n">recv</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:orig_argc</span><span class="p">].</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">pop</span> <span class="p">}.</span><span class="nf">reverse</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">super_method</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I did not implement it because MSpec does not rely on it and I usually try to avoid sequences of <code class="language-plaintext highlighter-rouge">super</code> calls.</p>

<h5 id="global-variables">Global variables</h5>

<p>Similar to locals and instance variables, there are <code class="language-plaintext highlighter-rouge">getglobal</code>/<code class="language-plaintext highlighter-rouge">setglobal</code> instructions. They also take a variable name as an argument.</p>

<p>Unfortunately, Ruby has no API to dynamically get/set global variables. But we have <code class="language-plaintext highlighter-rouge">eval</code>!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_getglobal</span><span class="p">((</span><span class="nb">name</span><span class="p">))</span>
  <span class="n">push</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">execute_setglobal</span><span class="p">((</span><span class="nb">name</span><span class="p">))</span>
  <span class="c1"># there's no way to set a gvar by name/value</span>
  <span class="c1"># but eval can reference locals</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="nb">eval</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> = value"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="defined-keyword"><code class="language-plaintext highlighter-rouge">defined?</code> keyword</h5>

<p>As you may know this keyword can handle pretty much anything:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'defined?(42)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="s2">"expression"</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>

<span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a = 42; defined?(a)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="s2">"local-variable"</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>In some simple cases it does not do any computations. It’s obvious that <code class="language-plaintext highlighter-rouge">42</code> is an expression and <code class="language-plaintext highlighter-rouge">a</code> is a local variable (and there’s no way to remove it by any code between assignment and <code class="language-plaintext highlighter-rouge">defined?</code> check)</p>

<p>More advanced checks use a <code class="language-plaintext highlighter-rouge">defined</code> instruction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'@a = 42; defined?(@a)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setinstancevariable</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:defined</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">,</span> <span class="kp">true</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>The first argument is a special <code class="language-plaintext highlighter-rouge">enum</code> flag that specifies what are we trying to check here:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DefinedType</span>
  <span class="no">DEFINED_NOT_DEFINED</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="no">DEFINED_NIL</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="no">DEFINED_IVAR</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="no">DEFINED_LVAR</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="no">DEFINED_GVAR</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="no">DEFINED_CVAR</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="no">DEFINED_CONST</span> <span class="o">=</span> <span class="mi">6</span>
  <span class="no">DEFINED_METHOD</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="no">DEFINED_YIELD</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="no">DEFINED_ZSUPER</span> <span class="o">=</span> <span class="mi">9</span>
  <span class="no">DEFINED_SELF</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="no">DEFINED_TRUE</span> <span class="o">=</span> <span class="mi">11</span>
  <span class="no">DEFINED_FALSE</span> <span class="o">=</span> <span class="mi">12</span>
  <span class="no">DEFINED_ASGN</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="no">DEFINED_EXPR</span> <span class="o">=</span> <span class="mi">14</span>
  <span class="no">DEFINED_IVAR2</span> <span class="o">=</span> <span class="mi">15</span>
  <span class="no">DEFINED_REF</span> <span class="o">=</span> <span class="mi">16</span>
  <span class="no">DEFINED_FUNC</span> <span class="o">=</span> <span class="mi">17</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I’ll show you the branch that handles instance variables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_defined</span><span class="p">(</span><span class="n">defined_type</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">needstr</span><span class="p">)</span>
  <span class="c1"># used only in DEFINED_FUNC/DEFINED_METHOD branches</span>
  <span class="c1"># but we still have to do `pop` here (even if it's unused)</span>
  <span class="n">context</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="n">verdict</span> <span class="o">=</span>
    <span class="k">case</span> <span class="n">defined_type</span>
    <span class="k">when</span> <span class="no">DefinedType</span><span class="o">::</span><span class="no">DEFINED_IVAR</span>
      <span class="n">ivar_name</span> <span class="o">=</span> <span class="n">obj</span>
      <span class="k">if</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">_self</span><span class="p">.</span><span class="nf">instance_variable_defined?</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
        <span class="s1">'instance-variable'</span>
      <span class="k">end</span>
    <span class="c1"># ... other branches</span>
    <span class="k">end</span>

  <span class="n">push</span><span class="p">(</span><span class="n">verdict</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>All other branches are similar, they do some check and push a constant string or <code class="language-plaintext highlighter-rouge">nil</code> back to the stack.</p>

<h5 id="range-literals">Range literals</h5>

<p>For static ranges (like <code class="language-plaintext highlighter-rouge">(1..2)</code>) Ruby uses inlining and a well-known <code class="language-plaintext highlighter-rouge">putobject</code> instruction. But what if it’s dynamic? Like <code class="language-plaintext highlighter-rouge">(a..b)</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'a = 3; b = 4; p (a..b); p (a...b)'</span><span class="p">).</span><span class="nf">to_a</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putobject</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:setlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newrange</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:pop</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:newrange</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>

 <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
 <span class="p">[</span><span class="ss">:leave</span><span class="p">]]</span>
</code></pre></div></div>

<p>There’s a special <code class="language-plaintext highlighter-rouge">newrange</code> instruction that takes a flag as an argument to specify inclusion of the right side (i.e. to distinguish <code class="language-plaintext highlighter-rouge">..</code> vs <code class="language-plaintext highlighter-rouge">...</code>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_newrange</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
  <span class="n">high</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">low</span> <span class="o">=</span> <span class="n">pop</span>
  <span class="n">push</span><span class="p">(</span><span class="no">Range</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="long-jumps">Long jumps</h5>

<p>This is probably the most complicated part. What if you have a method that has a loop inside a loop that does <code class="language-plaintext highlighter-rouge">return</code>? You want to stop executing both loops and simply exit the method, right?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">m</span>
  <span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">m</span>
</code></pre></div></div>

<p>Of course you can just find the closest frame that supports <code class="language-plaintext highlighter-rouge">return</code> (i.e. a <code class="language-plaintext highlighter-rouge">MethodFrame</code>), but you also need to stop execution of two running methods and blocks. In our case it’s even more complicated because we don’t control them (they are written in C).</p>

<p>The only way I was able to find is to throw an exception. An exception destroys all frames (including YARV’s C frames) until it finds someone who can catch and handle it. If there’s no such frame the programs exits with an error.</p>

<p>Let’s create a special exception class called <code class="language-plaintext highlighter-rouge">VM::LongJumpError</code>. Each frame class has to know what it can handle (for example, you can do <code class="language-plaintext highlighter-rouge">break</code> in a block, but not in a method; <code class="language-plaintext highlighter-rouge">return</code> is normally supported only by methods and lambdas, etc):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LongJumpError</span>  <span class="o">&lt;</span> <span class="no">InternalError</span>
  <span class="nb">attr_reader</span> <span class="ss">:value</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">do_jump!</span>
    <span class="k">raise</span> <span class="no">InternalError</span><span class="p">,</span> <span class="s1">'Not implemented'</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">message</span>
    <span class="s2">"</span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="vi">@value</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ReturnError</span> <span class="o">&lt;</span> <span class="no">LongJumpError</span>
  <span class="k">def</span> <span class="nf">do_jump!</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">current_frame</span>

    <span class="k">if</span> <span class="n">frame</span><span class="p">.</span><span class="nf">can_return?</span>
      <span class="c1"># swallow and consume</span>
      <span class="n">frame</span><span class="p">.</span><span class="nf">returning</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">value</span>
    <span class="k">else</span>
      <span class="n">pop_frame</span><span class="p">(</span><span class="ss">reason: </span><span class="s2">"longjmp (return) </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
      <span class="k">raise</span> <span class="nb">self</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Each <code class="language-plaintext highlighter-rouge">longjmp</code> exception wraps the value that it “returns” with (or “breaks” with, for <code class="language-plaintext highlighter-rouge">break</code> we need a separate class, but I’m going to skip it here. <code class="language-plaintext highlighter-rouge">break</code>/<code class="language-plaintext highlighter-rouge">next</code> and other friends are really similar to <code class="language-plaintext highlighter-rouge">return</code>).</p>

<p>But we need to catch them, right? Without a <code class="language-plaintext highlighter-rouge">rescue</code> handler we will have something conceptually similar to segfault:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">iseq</span> <span class="o">=</span> <span class="no">ISeq</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">)</span>
  <span class="n">push_frame</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="c1"># here comes the difference:</span>
  <span class="c1"># we wrap executing instructions into a rescue handler</span>
  <span class="k">begin</span>
    <span class="n">evaluate_last_frame</span>
  <span class="k">rescue</span> <span class="no">LongJumpError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="n">e</span><span class="p">.</span><span class="nf">do_jump!</span>
  <span class="k">end</span>
  <span class="n">pop_frame</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The only missing thing is the implementation of <code class="language-plaintext highlighter-rouge">can_return?</code> method in our frames. All frames except <code class="language-plaintext highlighter-rouge">MethodFrame</code> (and <code class="language-plaintext highlighter-rouge">BlockFrame</code> it it’s marked as <code class="language-plaintext highlighter-rouge">lambda</code>) must return <code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">MethodFrame</code> must return <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>MRI uses a special instruction called <code class="language-plaintext highlighter-rouge">throw</code> that has a single argument that is a <code class="language-plaintext highlighter-rouge">throw_type</code> (an <code class="language-plaintext highlighter-rouge">enum</code>, for <code class="language-plaintext highlighter-rouge">return</code> it’s 1, <code class="language-plaintext highlighter-rouge">break</code> is 3, <code class="language-plaintext highlighter-rouge">next</code> is 4, there are also <code class="language-plaintext highlighter-rouge">retry</code>/<code class="language-plaintext highlighter-rouge">redo</code> and a few more). The value that must be attached to the thrown exception comes from the stack (so this instruction does a single <code class="language-plaintext highlighter-rouge">pop</code>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VM_THROW_STATE_MASK</span> <span class="o">=</span> <span class="mh">0xff</span>

<span class="no">RUBY_TAG_NONE</span> <span class="o">=</span> <span class="mh">0x0</span>
<span class="no">RUBY_TAG_RETURN</span> <span class="o">=</span> <span class="mh">0x1</span>
<span class="no">RUBY_TAG_BREAK</span> <span class="o">=</span> <span class="mh">0x2</span>
<span class="no">RUBY_TAG_NEXT</span> <span class="o">=</span> <span class="mh">0x3</span>
<span class="no">RUBY_TAG_RETRY</span> <span class="o">=</span> <span class="mh">0x4</span>
<span class="no">RUBY_TAG_REDO</span> <span class="o">=</span> <span class="mh">0x5</span>
<span class="no">RUBY_TAG_RAISE</span> <span class="o">=</span> <span class="mh">0x6</span>
<span class="no">RUBY_TAG_THROW</span> <span class="o">=</span> <span class="mh">0x7</span>
<span class="no">RUBY_TAG_FATAL</span> <span class="o">=</span> <span class="mh">0x8</span>
<span class="no">RUBY_TAG_MASK</span> <span class="o">=</span> <span class="mh">0xf</span>

<span class="k">def</span> <span class="nf">execute_throw</span><span class="p">(</span><span class="n">throw_type</span><span class="p">)</span>
  <span class="n">throw_type</span> <span class="o">=</span> <span class="n">throw_type</span> <span class="o">&amp;</span> <span class="no">VM_THROW_STATE_MASK</span>
  <span class="n">throw_obj</span> <span class="o">=</span> <span class="n">pop</span>

  <span class="k">case</span> <span class="n">throw_type</span>
  <span class="k">when</span> <span class="no">RUBY_TAG_RETURN</span>
    <span class="k">raise</span> <span class="no">VM</span><span class="o">::</span><span class="no">ReturnError</span><span class="p">,</span> <span class="n">throw_obj</span>
  <span class="k">when</span> <span class="no">RUBY_TAG_BREAK</span>
    <span class="k">raise</span> <span class="no">VM</span><span class="o">::</span><span class="no">BreakError</span><span class="p">,</span> <span class="n">throw_obj</span>
  <span class="k">when</span> <span class="no">RUBY_TAG_NEXT</span>
    <span class="k">raise</span> <span class="no">VM</span><span class="o">::</span><span class="no">NextError</span><span class="p">,</span> <span class="n">throw_obj</span>
  <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="longjmp-in-mri"><code class="language-plaintext highlighter-rouge">longjmp</code> in MRI</h5>

<p>But does it work in the same way in MRI? C does not have exceptions. And at the same time there is a bunch of places where MRI does something like</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ARY_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eArgError</span><span class="p">,</span> <span class="s">"array size too big"</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// handle validated data</span>
</code></pre></div></div>

<p>This <code class="language-plaintext highlighter-rouge">rb_raise</code> somehow exits a C function. Well, here’s the trick: non-local <code class="language-plaintext highlighter-rouge">goto</code>.</p>

<p>There are C calls that perform a <code class="language-plaintext highlighter-rouge">goto</code> to any place (that was previously marked of course, similar to jump to labels for a local <code class="language-plaintext highlighter-rouge">goto</code>):</p>

<ul>
  <li><a href="https://linux.die.net/man/3/sigsetjmp"><code class="language-plaintext highlighter-rouge">setjmp</code></a></li>
  <li><a href="https://linux.die.net/man/3/longjmp"><code class="language-plaintext highlighter-rouge">longjmp</code></a></li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">setjmp()</code> saves the stack context/environment in <code class="language-plaintext highlighter-rouge">env</code> for later use by <code class="language-plaintext highlighter-rouge">longjmp</code></p>
</blockquote>

<p>… also known as “context switch”. And it’s relatively expensive.</p>

<p>Even if you don’t <code class="language-plaintext highlighter-rouge">raise</code> an exception and only do <code class="language-plaintext highlighter-rouge">begin; ...; rescue; end</code> in your code you still have to save the context (to jump to it once you <code class="language-plaintext highlighter-rouge">raise</code> an error). MRI does not know at compile time which methods can throw an error (and do you throw them at all), so each <code class="language-plaintext highlighter-rouge">rescue</code> produces a <code class="language-plaintext highlighter-rouge">setjmp</code> call (and each <code class="language-plaintext highlighter-rouge">raise</code> triggers a <code class="language-plaintext highlighter-rouge">longjmp</code> and passes <code class="language-plaintext highlighter-rouge">closest rescue</code> -&gt; <code class="language-plaintext highlighter-rouge">saved env</code> as an argument)</p>

<h5 id="rescueensure"><code class="language-plaintext highlighter-rouge">rescue</code>/<code class="language-plaintext highlighter-rouge">ensure</code></h5>

<p>So now we know that raise/rescue works via long jumps under the hood. Let’s implement our own exceptions.</p>

<p>By sticking to MRI exceptions we can unwrap both internal and our stacks at the same time. I’m not going to override <code class="language-plaintext highlighter-rouge">raise</code>, it should do what it originally does, but we still need to support our own <code class="language-plaintext highlighter-rouge">rescue</code> blocks. Let’s see what MRI gives us:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pp</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s1">'begin; p "x"; rescue A; p "y"; end'</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">[</span> <span class="c1"># ...snip</span>
 <span class="p">[[</span><span class="ss">:rescue</span><span class="p">,</span>
   <span class="p">[</span> <span class="c1"># ...snip</span>
    <span class="s2">"rescue in &lt;compiled&gt;"</span><span class="p">,</span>
    <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
    <span class="s2">"&lt;compiled&gt;"</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="ss">:rescue</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:"</span><span class="se">\#</span><span class="ss">$!"</span><span class="p">],</span>
    <span class="p">{},</span>
    <span class="p">[],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:putnil</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:getconstant</span><span class="p">,</span> <span class="ss">:A</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:checkmatch</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:branchif</span><span class="p">,</span> <span class="ss">:label_11</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:jump</span><span class="p">,</span> <span class="ss">:label_19</span><span class="p">],</span>
     <span class="ss">:label_11</span><span class="p">,</span>
     <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:putstring</span><span class="p">,</span> <span class="s2">"y"</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:leave</span><span class="p">],</span>
     <span class="ss">:label_19</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:getlocal_WC_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="ss">:throw</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span>
   <span class="ss">:label_0</span><span class="p">,</span>
   <span class="ss">:label_7</span><span class="p">,</span>
   <span class="ss">:label_8</span><span class="p">,</span>
   <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:retry</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">:label_7</span><span class="p">,</span> <span class="ss">:label_8</span><span class="p">,</span> <span class="ss">:label_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
 <span class="p">[</span><span class="ss">:label_0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span>
  <span class="ss">:RUBY_EVENT_LINE</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:putself</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:putstring</span><span class="p">,</span> <span class="s2">"x"</span><span class="p">],</span>
  <span class="p">[</span><span class="ss">:send</span><span class="p">,</span> <span class="p">{</span><span class="ss">:mid</span><span class="o">=&gt;</span><span class="ss">:p</span><span class="p">,</span> <span class="ss">:flag</span><span class="o">=&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="ss">:orig_argc</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">],</span>
  <span class="ss">:label_7</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:nop</span><span class="p">],</span>
  <span class="ss">:label_8</span><span class="p">,</span>
  <span class="p">[</span><span class="ss">:leave</span><span class="p">]]]</span>
</code></pre></div></div>

<p>An instruction sequence that has some <code class="language-plaintext highlighter-rouge">rescue</code> blocks inside includes all information about them (in the element #12, right above an instructions list). Each rescue handler is a frame with its own list of variables and instructions. Its <code class="language-plaintext highlighter-rouge">kind</code> is <code class="language-plaintext highlighter-rouge">:rescue</code> and is has at least one local variable: <code class="language-plaintext highlighter-rouge">$!</code>. It starts with a dollar sign, but it’s a local variable. According to its semantics it has to be a local variable, but unfortunately it can’t look like a local variable (because it’d would potentially conflict with method calls). I mean, that’s how I explain it to myself, I don’t know for sure what was the initial reason to design it this way.</p>

<p>It also has a few labels at the bottom - <code class="language-plaintext highlighter-rouge">:label_7, :label_8, :label_0</code>:</p>

<ul>
  <li>the first label is a “begin” label. It marks where the (potentially) critical section of your code begins</li>
  <li>the second label is an “end” label</li>
  <li>the third label is an “exit” label. It marks where we should jump to if the error has been caught and handled.</li>
</ul>

<p>A top-level instruction also contains these labels, and the meaning of them is:</p>

<ul>
  <li>if we evaluate instructions and we see a label that is a “begin” label of some rescue handler we <strong>enable</strong> the handler</li>
  <li>if we see a label that is an “end” of some rescue handler we <strong>disable</strong> it</li>
  <li>if we execute a single instruction and catch an exception we:
    <ul>
      <li>iterate over all <strong>enabled</strong> rescue handlers</li>
      <li>and for each of them we push a <code class="language-plaintext highlighter-rouge">RescueFrame</code> with a rescue iseq</li>
      <li>and we set a <code class="language-plaintext highlighter-rouge">$!</code> variable in this frame to the error that we have just caught</li>
      <li>the rescue frame decides where to go next:
        <ul>
          <li>back to the original frame via <code class="language-plaintext highlighter-rouge">jump</code> to the “exit” label after doing <code class="language-plaintext highlighter-rouge">pop_frame</code></li>
          <li>or somewhere else via re-raise (if the iseq contains it)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Let’s code it!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ISeq</span>
  <span class="nb">attr_reader</span> <span class="ss">:rescue_handlers</span>
  <span class="nb">attr_reader</span> <span class="ss">:ensure_handlers</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ruby_iseq</span><span class="p">)</span>
    <span class="vi">@ruby_iseq</span> <span class="o">=</span> <span class="n">ruby_iseq</span>
    <span class="n">reset!</span>
    <span class="n">setup_rescue_handlers!</span>
    <span class="n">setup_ensure_handlers!</span>
  <span class="k">end</span>

  <span class="c1"># ... other existing methods on ISeq class</span>

  <span class="k">def</span> <span class="nf">setup_rescue_handlers!</span>
    <span class="vi">@rescue_handler</span> <span class="o">=</span> <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:rescue</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span><span class="o">|</span> <span class="no">Handler</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">setup_ensure_handlers!</span>
    <span class="vi">@ensure_handler</span> <span class="o">=</span> <span class="vi">@ruby_iseq</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:ensure</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span><span class="o">|</span> <span class="no">Handler</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Handler</span>
    <span class="nb">attr_reader</span> <span class="ss">:iseq</span>
    <span class="nb">attr_reader</span> <span class="ss">:begin_label</span><span class="p">,</span> <span class="ss">:end_label</span><span class="p">,</span> <span class="ss">:exit_label</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span><span class="p">)</span>
      <span class="vi">@iseq</span> <span class="o">=</span> <span class="n">iseq</span>
      <span class="vi">@begin_label</span><span class="p">,</span> <span class="vi">@end_label</span><span class="p">,</span> <span class="vi">@exit_label</span> <span class="o">=</span> <span class="n">begin_label</span><span class="p">,</span> <span class="n">end_label</span><span class="p">,</span> <span class="n">exit_label</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So now each <code class="language-plaintext highlighter-rouge">iseq</code> object has two getters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">rescue_handlers</code></li>
  <li><code class="language-plaintext highlighter-rouge">ensure_handlers</code></li>
</ul>

<p>Frames must know which handlers are active (but not instruction sequences, because methods can recursively call themselves and so the same iseq will be reused; it’s a per-frame property):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrameClass</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span>
    <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
      <span class="c1"># Both must be set to `Set.new` in the constructor</span>
      <span class="nb">attr_accessor</span> <span class="ss">:enabled_rescue_handlers</span>
      <span class="nb">attr_accessor</span> <span class="ss">:enabled_ensure_handlers</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So this way all frames have it too. Every time when we see a label in our execution loop we need to check if it matches any <code class="language-plaintext highlighter-rouge">begin_label</code> or <code class="language-plaintext highlighter-rouge">end_label</code> of our <code class="language-plaintext highlighter-rouge">current_frame.iseq.rescue_handlers</code> (or <code class="language-plaintext highlighter-rouge">ensure_handlers</code>):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">on_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">current_iseq</span><span class="p">.</span><span class="nf">rescue_handlers</span> <span class="o">=&gt;</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">enabled_rescue_handlers</span><span class="p">,</span>
    <span class="n">current_iseq</span><span class="p">.</span><span class="nf">ensure_handlers</span> <span class="o">=&gt;</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">enabled_ensure_handlers</span><span class="p">,</span>
  <span class="p">}.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">all_handlers</span><span class="p">,</span> <span class="n">enabled_handlers</span><span class="o">|</span>
    <span class="n">all_handlers</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">.</span><span class="nf">begin_label</span> <span class="o">==</span> <span class="n">label</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">enabled_handlers</span> <span class="o">&lt;&lt;</span> <span class="n">handler</span> <span class="p">}</span>

    <span class="n">all_handlers</span>
      <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">handler</span><span class="p">.</span><span class="nf">end_label</span> <span class="o">==</span> <span class="n">label</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="n">enabled_handlers</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>side note: when we do a local <code class="language-plaintext highlighter-rouge">jump</code> we should also walk through skipped instructions and enable/disable our handlers; this is important</p>

<p>OK, now the only missing part is the reworked execution loop:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># a generic runner that is used inside the loop</span>
<span class="k">def</span> <span class="nf">execute_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">insn</span>
  <span class="k">when</span> <span class="p">[</span><span class="ss">:leave</span><span class="p">]</span>
    <span class="n">current_frame</span><span class="p">.</span><span class="nf">returning</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">when</span> <span class="no">Array</span>
    <span class="nb">name</span><span class="p">,</span> <span class="o">*</span><span class="n">payload</span> <span class="o">=</span> <span class="n">insn</span>

    <span class="n">with_error_handling</span> <span class="k">do</span>
      <span class="nb">send</span><span class="p">(</span><span class="ss">:"execute_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="ss">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="c1"># -- new branch for labels --</span>
  <span class="k">when</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"label_</span><span class="se">\\</span><span class="s2">d+"</span><span class="p">)</span>
    <span class="n">on_label</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="c1"># ignore</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># a wrapper that catches and handles error</span>
<span class="k">def</span> <span class="nf">with_error_handling</span>
  <span class="k">yield</span>
<span class="k">rescue</span> <span class="no">VM</span><span class="o">::</span><span class="no">InternalError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># internal errors like LongJumpError should be invisible for users</span>
  <span class="k">raise</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">handle_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rescue_handler</span> <span class="o">=</span> <span class="n">current_frame</span><span class="p">.</span><span class="nf">enabled_rescue_handler</span><span class="p">.</span><span class="nf">first</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">rescue_handler</span><span class="p">.</span><span class="nf">iseq</span><span class="p">,</span> <span class="ss">caught: </span><span class="n">error</span><span class="p">,</span> <span class="ss">exit_to: </span><span class="n">rescue_handler</span><span class="p">.</span><span class="nf">exit_label</span><span class="p">)</span>
    <span class="n">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="n">error</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># This guy also needs customization to support `jump(exit_label)`</span>
<span class="k">def</span> <span class="nf">pop_frame</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="vi">@frame_stack</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">if</span> <span class="n">frame</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">RescueFrame</span><span class="p">)</span>
    <span class="n">jump</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="nf">exit_to</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">frame</span><span class="p">.</span><span class="nf">returning</span>
<span class="k">end</span>

<span class="c1"># And here's the rescue frame implementation</span>
<span class="no">RescueFrame</span> <span class="o">=</span> <span class="no">FrameClass</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">attr_reader</span> <span class="ss">:parent_frame</span><span class="p">,</span> <span class="ss">:caught</span><span class="p">,</span> <span class="ss">:exit_to</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">parent_frame</span><span class="p">:,</span> <span class="n">caught</span><span class="p">:,</span> <span class="n">exit_to</span><span class="p">:)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">_self</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">_self</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">nesting</span> <span class="o">=</span> <span class="n">parent_frame</span><span class="p">.</span><span class="nf">nesting</span>

    <span class="vi">@parent_frame</span> <span class="o">=</span> <span class="n">parent_frame</span>
    <span class="vi">@caught</span> <span class="o">=</span> <span class="n">caught</span>
    <span class="vi">@exit_to</span> <span class="o">=</span> <span class="n">exit_to</span>

    <span class="c1"># $! always has an ID = 3</span>
    <span class="n">locals</span><span class="p">.</span><span class="nf">declare</span><span class="p">(</span><span class="ss">id: </span><span class="mi">3</span><span class="p">,</span> <span class="ss">name: :"</span><span class="se">\#</span><span class="ss">$!"</span><span class="p">)</span>
    <span class="n">locals</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="ss">id: </span><span class="mi">3</span><span class="p">).</span><span class="nf">set</span><span class="p">(</span><span class="n">caught</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>But why do we handle only the first handler? Can there be multiple handlers? The answer is no, because:</p>

<ul>
  <li>MRI merges multiple consecutive <code class="language-plaintext highlighter-rouge">rescue</code> handlers (by using <code class="language-plaintext highlighter-rouge">case error</code> branching in a rescue body)</li>
  <li><code class="language-plaintext highlighter-rouge">rescue</code> itself is frame, and so nested <code class="language-plaintext highlighter-rouge">rescue</code> is a rescue handler of the rescue handler</li>
</ul>

<h5 id="throwcatch-methods"><code class="language-plaintext highlighter-rouge">throw</code>/<code class="language-plaintext highlighter-rouge">catch</code> methods</h5>

<p>As a side (and I personally think a very interesting) note, while I was working on this project I have realized that specs for <code class="language-plaintext highlighter-rouge">Kernel#throw</code> are not working for me at all. They were literally completely broken (even after I finished working on a very basic implementation of exceptions):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">catch</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">begin</span>
    <span class="kp">throw</span> <span class="ss">:x</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="nb">puts</span> <span class="n">e</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This code does not print anything. However, if you do just <code class="language-plaintext highlighter-rouge">throw :x</code> you get an exception:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kp">throw</span> <span class="ss">:x</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">14</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">14</span><span class="ss">:in</span> <span class="sb">`throw'
UncaughtThrowError (uncaught throw :x)
</span></code></pre></div></div>

<p>Huh, what’s going on? Let’s take a look at the implementation of <code class="language-plaintext highlighter-rouge">Kernel#throw</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">rb_throw_obj</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">tag</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">rb_execution_context_t</span> <span class="o">*</span><span class="n">ec</span> <span class="o">=</span> <span class="n">GET_EC</span><span class="p">();</span>
    <span class="k">struct</span> <span class="n">rb_vm_tag</span> <span class="o">*</span><span class="n">tt</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tt</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">tt</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">tt</span> <span class="o">=</span> <span class="n">tt</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tt</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">VALUE</span> <span class="n">desc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
      <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
      <span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
      <span class="n">desc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rb_str_new_cstr</span><span class="p">(</span><span class="s">"uncaught throw %p"</span><span class="p">);</span>
      <span class="n">rb_exc_raise</span><span class="p">(</span><span class="n">rb_class_new_instance</span><span class="p">(</span><span class="n">numberof</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="n">desc</span><span class="p">,</span> <span class="n">rb_eUncaughtThrow</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">ec</span><span class="o">-&gt;</span><span class="n">errinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span><span class="p">)</span><span class="n">THROW_DATA_NEW</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TAG_THROW</span><span class="p">);</span>
    <span class="n">EC_JUMP_TAG</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">TAG_THROW</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code raises an instance of <code class="language-plaintext highlighter-rouge">rb_eUncaughtThrow</code> only in one case: if there’s no frame above that may “catch” it (like in the case when we did just <code class="language-plaintext highlighter-rouge">throw :x</code>).</p>

<p>However if there’s a frame somewhere above that has the same tag MRI performs a manual <code class="language-plaintext highlighter-rouge">longjmp</code>. This is why we can’t catch this exception. There’s simply no exception if there’s a <code class="language-plaintext highlighter-rouge">catch(:x)</code> above (but there would be an exception if we would do <code class="language-plaintext highlighter-rouge">catch(:y) { throw :x }</code>).</p>

<p>Is it faster? Let’s see</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'benchmark/ips'</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">config</span><span class="p">(</span><span class="ss">:time</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span>

  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'raise'</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="k">raise</span> <span class="s1">'x'</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'throw'</span><span class="p">)</span> <span class="k">do</span>
    <span class="kp">catch</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="k">do</span>
      <span class="kp">throw</span> <span class="ss">:x</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">x</span><span class="p">.</span><span class="nf">compare!</span>
<span class="k">end</span>

<span class="err">$</span> <span class="n">ruby</span> <span class="n">benchmark</span><span class="p">.</span><span class="nf">rb</span>
<span class="no">Warming</span> <span class="n">up</span> <span class="o">--------------------------------------</span>
               <span class="k">raise</span>   <span class="mf">101.832</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
               <span class="kp">throw</span>   <span class="mf">256.893</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
<span class="no">Calculating</span> <span class="o">-------------------------------------</span>
               <span class="k">raise</span>      <span class="mf">1.310</span><span class="no">M</span> <span class="p">(</span><span class="err">±</span> <span class="mf">4.2</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>      <span class="mf">3.971</span><span class="no">M</span> <span class="k">in</span>   <span class="mf">3.037942</span><span class="n">s</span>
               <span class="kp">throw</span>      <span class="mf">4.853</span><span class="no">M</span> <span class="p">(</span><span class="err">±</span> <span class="mf">3.0</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>     <span class="mf">14.643</span><span class="no">M</span> <span class="k">in</span>   <span class="mf">3.020227</span><span class="n">s</span>

<span class="no">Comparison</span><span class="p">:</span>
               <span class="ss">throw:  </span><span class="mf">4852821.4</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span>
               <span class="ss">raise:  </span><span class="mf">1309915.6</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span> <span class="mf">3.70</span><span class="n">x</span>  <span class="n">slower</span>
</code></pre></div></div>

<p>As expected, it’s faster. But what’s more important, let’s see what if there are more frames between <code class="language-plaintext highlighter-rouge">raise/rescue</code> and <code class="language-plaintext highlighter-rouge">throw/catch</code>. First, let’s create a small method that wraps given code into N frames:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">in_n_frames</span><span class="p">(</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">blk</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">n</span>
    <span class="n">blk</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">else</span>
    <span class="n">in_n_frames</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">blk</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">begin</span>
  <span class="n">in_n_frames</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="nb">proc</span> <span class="p">{</span> <span class="k">raise</span> <span class="s1">'err'</span> <span class="p">})</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="nb">p</span> <span class="n">e</span><span class="p">.</span><span class="nf">backtrace</span><span class="p">.</span><span class="nf">length</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It prints <code class="language-plaintext highlighter-rouge">1003</code>, because there’s also a <code class="language-plaintext highlighter-rouge">TopFrame</code> and a <code class="language-plaintext highlighter-rouge">BlockFrame</code> (and a small bug that does +1), but that’s absolutely fine for us.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="n">benchmark</span><span class="p">.</span><span class="nf">rb</span>
<span class="no">Warming</span> <span class="n">up</span> <span class="o">--------------------------------------</span>
               <span class="k">raise</span>     <span class="mf">1.061</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
               <span class="kp">throw</span>     <span class="mf">1.115</span><span class="n">k</span> <span class="n">i</span><span class="o">/</span><span class="mi">100</span><span class="n">ms</span>
<span class="no">Calculating</span> <span class="o">-------------------------------------</span>
               <span class="k">raise</span>     <span class="mf">10.628</span><span class="n">k</span> <span class="p">(</span><span class="err">±</span> <span class="mf">1.3</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>     <span class="mf">32.891</span><span class="n">k</span> <span class="k">in</span>   <span class="mf">3.095347</span><span class="n">s</span>
               <span class="kp">throw</span>     <span class="mf">11.183</span><span class="n">k</span> <span class="p">(</span><span class="err">±</span> <span class="mf">1.5</span><span class="o">%</span><span class="p">)</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span>     <span class="mf">34.565</span><span class="n">k</span> <span class="k">in</span>   <span class="mf">3.091514</span><span class="n">s</span>

<span class="no">Comparison</span><span class="p">:</span>
               <span class="ss">throw:    </span><span class="mf">11183.1</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span>
               <span class="ss">raise:    </span><span class="mf">10627.8</span> <span class="n">i</span><span class="o">/</span><span class="n">s</span> <span class="o">-</span> <span class="mf">1.05</span><span class="n">x</span>  <span class="n">slower</span>
</code></pre></div></div>

<p>There’s almost no difference! The reason is simple: the only thing that is different is creation of the exception object. <code class="language-plaintext highlighter-rouge">throw</code> does not do it.</p>

<h5 id="utility-instructions">Utility instructions</h5>

<p>There are also a few interesting instructions that MRI uses to evaluate your complex code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">adjuststack(n)</code> - does <code class="language-plaintext highlighter-rouge">n.times { pop }</code></li>
  <li><code class="language-plaintext highlighter-rouge">nop</code> - literally does nothing</li>
  <li><code class="language-plaintext highlighter-rouge">dupn(n)</code> - does <code class="language-plaintext highlighter-rouge">pop</code> N times and then pushes them twice (or basically duplicates N last items)</li>
  <li><code class="language-plaintext highlighter-rouge">setn(n)</code> - does <code class="language-plaintext highlighter-rouge">stack[-n-1] = stack.top</code></li>
  <li><code class="language-plaintext highlighter-rouge">topn(n)</code> - does <code class="language-plaintext highlighter-rouge">push(stack[-n-1])</code></li>
  <li><code class="language-plaintext highlighter-rouge">swap</code> - swaps top two stack elements</li>
  <li><code class="language-plaintext highlighter-rouge">dup</code> - like <code class="language-plaintext highlighter-rouge">dupn(1)</code></li>
  <li><code class="language-plaintext highlighter-rouge">reverse(n)</code> - reverses N stack elements (i.e. does <code class="language-plaintext highlighter-rouge">n.times.map { pop }.each { |value| push(value) }</code>)</li>
</ul>

<h3 id="final-words">Final words</h3>

<p>First of all, I’d like to say thank you to everyone who made YARV. I was not able to find a single place where MRI behaves inefficiently (and I spent many hours looking into instructions).</p>

<p>Once again, the code is available <a href="https://github.com/iliabylich/my.rb">here</a>, feel free to create issues/message me in Twitter. And please, don’t use it in the real world.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
    <li>
      <h3>
        <a href="/2021/12/27/writing-bindings-upside-down.html">
          Writing bindings upside down
          <small>27 Dec 2021</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/2020/11/22/lib-ruby-parser.html">
          lib-ruby-parser
          <small>22 Nov 2020</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/2018/07/18/my-favorite-parts-of-ruby.html">
          My favorite parts of Ruby
          <small>18 Jul 2018</small>
        </a>
      </h3>
    </li>
    
  </ul>
</div>


<iframe src="https://commentary.ilyabylich.me/commentary/index?post_id=evaluating-ruby-in-ruby" frameborder="0" scrolling="no" width="100%">
</iframe>

<script type="text/javascript">
  window.addEventListener("message", ({ data }) => {
    if (data.type === "resize") {
      document.querySelector("iframe").style.height = `${data.height}px`;
    }
  })
</script>


    </div>
  </body>
</html>
